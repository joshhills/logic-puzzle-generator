(function(){"use strict";var B=(u=>(u[u.NOMINAL=0]="NOMINAL",u[u.ORDINAL=1]="ORDINAL",u))(B||{}),g=(u=>(u[u.BINARY=0]="BINARY",u[u.ORDINAL=1]="ORDINAL",u[u.SUPERLATIVE=2]="SUPERLATIVE",u[u.UNARY=3]="UNARY",u[u.CROSS_ORDINAL=4]="CROSS_ORDINAL",u))(g||{}),ee=(u=>(u[u.MATCH=0]="MATCH",u[u.NOT_MATCH=1]="NOT_MATCH",u))(ee||{}),_=(u=>(u[u.IS=0]="IS",u[u.IS_NOT=1]="IS_NOT",u))(_||{}),z=(u=>(u[u.GREATER_THAN=0]="GREATER_THAN",u[u.LESS_THAN=1]="LESS_THAN",u[u.NOT_GREATER_THAN=2]="NOT_GREATER_THAN",u[u.NOT_LESS_THAN=3]="NOT_LESS_THAN",u))(z||{}),G=(u=>(u[u.MIN=0]="MIN",u[u.MAX=1]="MAX",u[u.NOT_MIN=2]="NOT_MIN",u[u.NOT_MAX=3]="NOT_MAX",u))(G||{}),X=(u=>(u[u.IS_ODD=0]="IS_ODD",u[u.IS_EVEN=1]="IS_EVEN",u))(X||{});class ie extends Error{constructor(t){super(t),this.name="LogicPuzzleError"}}class D extends ie{constructor(t){super(t),this.name="ConfigurationError"}}class H{constructor(t){this.validateConfig(t),this.categories=t,this.valueMap=new Map(t.map(e=>[e.id,new Map(e.values.map((i,s)=>[i,s]))])),this.grid=new Map;for(const e of t){const i=new Map;for(const s of e.values){const o=new Map;for(const l of t)e.id!==l.id&&o.set(l.id,Array(l.values.length).fill(!0));i.set(s,o)}this.grid.set(e.id,i)}}validateConfig(t){const e=new Set;let i=-1;for(const s of t){if(e.has(s.id))throw new D(`Duplicate category ID found: ${s.id}`);if(e.add(s.id),new Set(s.values).size!==s.values.length)throw new D(`Category '${s.id}' has duplicate values.`);if(i===-1)i=s.values.length;else if(s.values.length!==i)throw new D(`Category '${s.id}' has ${s.values.length} values, expected ${i}. All categories must be the same size.`)}}setPossibility(t,e,i,s,o){var a,r;const l=(a=this.valueMap.get(i))==null?void 0:a.get(s);if(l!==void 0){const f=this.grid.get(t);if(f){const m=f.get(e);if(m){const c=m.get(i);c&&(c[l]=o)}}}const n=(r=this.valueMap.get(t))==null?void 0:r.get(e);if(n!==void 0){const f=this.grid.get(i);if(f){const m=f.get(s);if(m){const c=m.get(t);c&&(c[n]=o)}}}}isPossible(t,e,i,s){var r;if(t===i)return e===s;const o=(r=this.valueMap.get(i))==null?void 0:r.get(s);if(o===void 0)return!1;const l=this.grid.get(t);if(!l)return!1;const n=l.get(e);if(!n)return!1;const a=n.get(i);return a?a[o]:!1}getPossibilitiesCount(t,e,i){var o,l;const s=(l=(o=this.grid.get(t))==null?void 0:o.get(e))==null?void 0:l.get(i);return s?s.filter(n=>n).length:0}getGridStats(){var n,a,r;let t=0;const e=this.categories.length,i=((n=this.categories[0])==null?void 0:n.values.length)||0;if(i===0||e<2)return{totalPossible:0,currentPossible:0,solutionPossible:0};const s=e*(e-1)/2,o=s*i*i,l=s*i;for(const f of this.categories)for(const m of f.values)for(const c of this.categories){if(f.id>=c.id)continue;const d=(r=(a=this.grid.get(f.id))==null?void 0:a.get(m))==null?void 0:r.get(c.id);d&&(t+=d.filter(p=>p).length)}return{totalPossible:o,currentPossible:t,solutionPossible:l}}clone(){const t=new H(this.categories);return t.grid=new Map([...this.grid.entries()].map(([e,i])=>[e,new Map([...i.entries()].map(([s,o])=>[s,new Map([...o.entries()].map(([l,n])=>[l,[...n]]))]))])),t}}class te{applyClue(t,e){let i=0;switch(e.type){case g.BINARY:i+=this.applyBinaryClue(t,e);break;case g.SUPERLATIVE:i+=this.applySuperlativeClue(t,e);break;case g.ORDINAL:i+=this.applyOrdinalClue(t,e);break;case g.UNARY:i+=this.applyUnaryClue(t,e);break;case g.CROSS_ORDINAL:i+=this.applyCrossOrdinalClue(t,e);break}let s;do s=this.runDeductionLoop(t),i+=s;while(s>0);return{grid:t,deductions:i}}applyCrossOrdinalClue(t,e){let i=0;const s=t.categories,o=s.find(m=>m.id===e.ordinal1),l=s.find(m=>m.id===e.ordinal2);if(!o||!l)return 0;const n=e.operator===ee.NOT_MATCH,a=(m,c,d,p)=>p.values.map((v,h)=>({val:v,idx:h})).filter(v=>t.isPossible(m,c,d,v.val)),r=a(e.item1Cat,e.item1Val,e.ordinal1,o),f=a(e.item2Cat,e.item2Val,e.ordinal2,l);if(n){if(r.length===1&&f.length===1){const m=r[0].idx+e.offset1,c=f[0].idx+e.offset2,d=o.values[m],p=l.values[c];d!==void 0&&p!==void 0&&t.isPossible(e.ordinal1,d,e.ordinal2,p)&&(t.setPossibility(e.ordinal1,d,e.ordinal2,p,!1),i++)}for(const m of r){const c=m.idx+e.offset1;if(o.values[c]!==void 0)for(const p of f){const v=p.idx+e.offset2;l.values[v]}}if(r.length===1){const m=r[0].idx+e.offset1,c=o.values[m];if(c!==void 0)for(const d of f){const p=d.idx+e.offset2,v=l.values[p];v!==void 0&&t.isPossible(e.ordinal1,c,e.ordinal2,v)&&(t.setPossibility(e.item2Cat,e.item2Val,e.ordinal2,d.val,!1),i++)}}if(f.length===1){const m=f[0].idx+e.offset2,c=l.values[m];if(c!==void 0)for(const d of r){const p=d.idx+e.offset1,v=o.values[p];v!==void 0&&t.isPossible(e.ordinal1,v,e.ordinal2,c)&&(t.setPossibility(e.item1Cat,e.item1Val,e.ordinal1,d.val,!1),i++)}}}else{for(const d of r){const p=d.idx+e.offset1,v=o.values[p];if(v===void 0){t.setPossibility(e.item1Cat,e.item1Val,e.ordinal1,d.val,!1),i++;continue}let h=!1;for(const y of f){const b=y.idx+e.offset2,R=l.values[b];if(R!==void 0&&t.isPossible(e.ordinal1,v,e.ordinal2,R)){h=!0;break}}h||(t.setPossibility(e.item1Cat,e.item1Val,e.ordinal1,d.val,!1),i++)}for(const d of f){const p=d.idx+e.offset2,v=l.values[p];if(v===void 0){t.setPossibility(e.item2Cat,e.item2Val,e.ordinal2,d.val,!1),i++;continue}let h=!1;for(const y of r){const b=y.idx+e.offset1,R=o.values[b];if(R!==void 0&&t.isPossible(e.ordinal1,R,e.ordinal2,v)){h=!0;break}}h||(t.setPossibility(e.item2Cat,e.item2Val,e.ordinal2,d.val,!1),i++)}const m=a(e.item1Cat,e.item1Val,e.ordinal1,o),c=a(e.item2Cat,e.item2Val,e.ordinal2,l);if(m.length===1&&c.length===1){const d=m[0].idx+e.offset1,p=c[0].idx+e.offset2,v=o.values[d],h=l.values[p];v!==void 0&&h!==void 0&&t.getPossibilitiesCount(e.ordinal1,v,e.ordinal2)>1&&(t.setPossibility(e.ordinal1,v,e.ordinal2,h,!0),i++)}}return i}applyUnaryClue(t,e){let i=0;const o=t.categories.find(n=>n.id===e.ordinalCat);if(!o||o.type!==B.ORDINAL||!o.values.every(n=>typeof n=="number"))return 0;const l=e.filter===X.IS_EVEN;for(const n of o.values){const a=n;(l?a%2!==0:a%2===0)&&t.isPossible(e.targetCat,e.targetVal,e.ordinalCat,n)&&(t.setPossibility(e.targetCat,e.targetVal,e.ordinalCat,n,!1),i++)}return i}applyBinaryClue(t,e){let i=0;const s=t.categories,o=s.find(n=>n.id===e.cat1),l=s.find(n=>n.id===e.cat2);if(!o||!l)return 0;if(e.operator===_.IS){t.isPossible(e.cat1,e.val1,e.cat2,e.val2),t.setPossibility(e.cat1,e.val1,e.cat2,e.val2,!0);for(const n of l.values)n!==e.val2&&t.isPossible(e.cat1,e.val1,e.cat2,n)&&(t.setPossibility(e.cat1,e.val1,e.cat2,n,!1),i++);for(const n of o.values)n!==e.val1&&t.isPossible(e.cat1,n,e.cat2,e.val2)&&(t.setPossibility(e.cat1,n,e.cat2,e.val2,!1),i++)}else t.isPossible(e.cat1,e.val1,e.cat2,e.val2)&&(t.setPossibility(e.cat1,e.val1,e.cat2,e.val2,!1),i++);return i}runDeductionLoop(t){let e=0;const i=t.categories;for(const s of i)for(const o of s.values)for(const l of i){if(s.id===l.id)continue;const n=l.values.filter(a=>t.isPossible(s.id,o,l.id,a));if(n.length===1){const a=n[0];for(const r of s.values)r!==o&&t.isPossible(s.id,r,l.id,a)&&(t.setPossibility(s.id,r,l.id,a,!1),e++)}for(const a of i){if(s.id===a.id||l.id===a.id)continue;const r=n.length===1?n[0]:null;if(r){const f=a.values.filter(m=>t.isPossible(l.id,r,a.id,m));if(f.length===1){const m=f[0];t.isPossible(s.id,o,a.id,m)===!1||t.getPossibilitiesCount(s.id,o,a.id)>1&&(t.setPossibility(s.id,o,a.id,m,!0),e++)}}for(const f of a.values)t.isPossible(s.id,o,a.id,f)&&(l.values.some(c=>t.isPossible(s.id,o,l.id,c)&&t.isPossible(l.id,c,a.id,f))||(t.setPossibility(s.id,o,a.id,f,!1),e++))}}return e}applyOrdinalClue(t,e){let i=0;const o=t.categories.find(a=>a.id===e.ordinalCat);if(!o||o.type!==B.ORDINAL)return 0;const l=o.values.map((a,r)=>({val:a,idx:r})).filter(a=>t.isPossible(e.item1Cat,e.item1Val,e.ordinalCat,a.val)),n=o.values.map((a,r)=>({val:a,idx:r})).filter(a=>t.isPossible(e.item2Cat,e.item2Val,e.ordinalCat,a.val));if(l.length===0||n.length===0)return 0;if(e.operator===z.GREATER_THAN)for(const a of l)n.some(f=>a.idx>f.idx)||t.isPossible(e.item1Cat,e.item1Val,e.ordinalCat,a.val)&&(t.setPossibility(e.item1Cat,e.item1Val,e.ordinalCat,a.val,!1),i++);else if(e.operator===z.LESS_THAN)for(const a of l)n.some(f=>a.idx<f.idx)||t.isPossible(e.item1Cat,e.item1Val,e.ordinalCat,a.val)&&(t.setPossibility(e.item1Cat,e.item1Val,e.ordinalCat,a.val,!1),i++);else if(e.operator===z.NOT_GREATER_THAN)for(const a of l)n.some(f=>a.idx<=f.idx)||t.isPossible(e.item1Cat,e.item1Val,e.ordinalCat,a.val)&&(t.setPossibility(e.item1Cat,e.item1Val,e.ordinalCat,a.val,!1),i++);else if(e.operator===z.NOT_LESS_THAN)for(const a of l)n.some(f=>a.idx>=f.idx)||t.isPossible(e.item1Cat,e.item1Val,e.ordinalCat,a.val)&&(t.setPossibility(e.item1Cat,e.item1Val,e.ordinalCat,a.val,!1),i++);if(e.operator===z.GREATER_THAN)for(const a of n)l.some(f=>a.idx<f.idx)||t.isPossible(e.item2Cat,e.item2Val,e.ordinalCat,a.val)&&(t.setPossibility(e.item2Cat,e.item2Val,e.ordinalCat,a.val,!1),i++);else if(e.operator===z.LESS_THAN)for(const a of n)l.some(f=>a.idx>f.idx)||t.isPossible(e.item2Cat,e.item2Val,e.ordinalCat,a.val)&&(t.setPossibility(e.item2Cat,e.item2Val,e.ordinalCat,a.val,!1),i++);else if(e.operator===z.NOT_GREATER_THAN)for(const a of n)l.some(f=>a.idx>=f.idx)||t.isPossible(e.item2Cat,e.item2Val,e.ordinalCat,a.val)&&(t.setPossibility(e.item2Cat,e.item2Val,e.ordinalCat,a.val,!1),i++);else if(e.operator===z.NOT_LESS_THAN)for(const a of n)l.some(f=>a.idx<=f.idx)||t.isPossible(e.item2Cat,e.item2Val,e.ordinalCat,a.val)&&(t.setPossibility(e.item2Cat,e.item2Val,e.ordinalCat,a.val,!1),i++);return i}applySuperlativeClue(t,e){const s=t.categories.find(a=>a.id===e.ordinalCat);if(!s||s.type!==B.ORDINAL)return 0;let o,l=!1;switch(e.operator){case G.MAX:o=s.values[s.values.length-1];break;case G.MIN:o=s.values[0];break;case G.NOT_MAX:o=s.values[s.values.length-1],l=!0;break;case G.NOT_MIN:o=s.values[0],l=!0;break;default:return 0}const n={type:g.BINARY,cat1:e.targetCat,val1:e.targetVal,cat2:e.ordinalCat,val2:o,operator:l?_.IS_NOT:_.IS};return this.applyBinaryClue(t,n)}}class ae{constructor(t,e,i,s,o,l){this.generator=t,this.categories=e,this.solution=i,this.reverseSolution=s,this.valueMap=o,this.targetFact=l,this.availableClues=[],this.proofChain=[],this.historyStack=[],this.grid=new H(e),this.solver=new te,this.availableClues=this.generator.generateAllPossibleClues(e,void 0,s,o)}getTotalClueCount(){return this.availableClues.length}getMatchingClueCount(t){return this.filterClues(t).length}getMatchingClues(t,e=50){return this.filterClues(t).slice(0,e)}getScoredMatchingClues(t,e=50){const l=this.filterClues(t).slice(0,200).map(n=>{const a=this.grid.clone(),{deductions:r}=this.solver.applyClue(a,n),f=this.generator.calculateClueScore(this.grid,this.targetFact,r,n,this.proofChain,this.solution,this.reverseSolution);let m=!1;if(n.type===g.BINARY&&n.operator===_.IS){const d=n,p=d.cat1===this.targetFact.category1Id&&d.val1===this.targetFact.value1&&d.cat2===this.targetFact.category2Id,v=d.cat2===this.targetFact.category1Id&&d.val2===this.targetFact.value1&&d.cat1===this.targetFact.category2Id;(p||v)&&(m=!0)}return{clue:n,score:f,deductions:r,isDirectAnswer:m}});return l.sort((n,a)=>a.score-n.score),l.slice(0,e)}useClue(t){return this.applyAndSave(t),{remaining:this.availableClues.length,solved:this.generator.isPuzzleSolved(this.grid,this.solution,this.reverseSolution)}}filterClues(t){return this.availableClues.filter(e=>{if(t!=null&&t.allowedClueTypes&&!t.allowedClueTypes.includes(e.type))return!1;if(t!=null&&t.includeSubjects&&(t!=null&&t.excludeSubjects)){const i=t.includeSubjects.filter(s=>t.excludeSubjects.includes(s));if(i.length>0)throw new Error(`Constraint Error: The following subjects are both included and excluded: ${i.join(", ")}`)}if(t!=null&&t.includeSubjects||t!=null&&t.excludeSubjects){const i=this.extractValuesFromClue(e);if(t.includeSubjects&&!t.includeSubjects.some(o=>i.includes(o))||t.excludeSubjects&&t.excludeSubjects.some(o=>i.includes(o)))return!1}return!0})}applyAndSave(t){this.historyStack.push(this.grid.clone()),this.solver.applyClue(this.grid,t),this.proofChain.push(t);const e=this.availableClues.indexOf(t);e>-1&&this.availableClues.splice(e,1)}getNextClue(t){const e=this.filterClues(t);let i=null,s=-1/0;const o=[...e].sort(()=>Math.random()-.5),l=50;let n=0;const a=(t==null?void 0:t.minDeductions)??0;for(const r of o){if(n++,n>l&&i)break;const f=this.grid.clone(),{deductions:m}=this.solver.applyClue(f,r);if(m<a)continue;const c=this.generator.calculateClueScore(this.grid,this.targetFact,m,r,this.proofChain,this.solution,this.reverseSolution);c>s&&(s=c,i=r)}return i?(this.applyAndSave(i),{clue:i,remaining:this.availableClues.length,solved:this.generator.isPuzzleSolved(this.grid,this.solution,this.reverseSolution)}):{clue:null,remaining:e.length,solved:this.generator.isPuzzleSolved(this.grid,this.solution,this.reverseSolution)}}async getNextClueAsync(t){return new Promise((e,i)=>{setTimeout(()=>{try{const s=this.getNextClue(t);e(s)}catch(s){i(s)}},0)})}rollbackLastClue(){if(this.historyStack.length===0)return{success:!1,clue:null};const t=this.historyStack.pop();t&&(this.grid=t);const e=this.proofChain.pop();return e?(this.availableClues.push(e),{success:!0,clue:e}):{success:!1,clue:null}}isUseful(t){return!0}getGrid(){return this.grid}getProofChain(){return this.proofChain}getSolution(){return this.solution}getValueMap(){return this.valueMap}extractValuesFromClue(t){const e=[],i=s=>{s!==void 0&&e.push(String(s))};return i(t.val1),i(t.val2),i(t.item1Val),i(t.item2Val),i(t.targetVal),e}}const se={"2x3":{min:2,max:2},"2x4":{min:3,max:10},"2x5":{min:4,max:17},"2x6":{min:5,max:26},"2x7":{min:6,max:37},"2x8":{min:7,max:50},"2x9":{min:8,max:65},"2x10":{min:9,max:82},"3x3":{min:3,max:9},"3x4":{min:5,max:26},"3x5":{min:7,max:47},"3x6":{min:9,max:72},"3x7":{min:11,max:100},"3x8":{min:13,max:130},"3x9":{min:15,max:160},"3x10":{min:17,max:200},"4x3":{min:5,max:16},"4x4":{min:8,max:44},"4x5":{min:11,max:87},"4x6":{min:14,max:140},"4x7":{min:17,max:200},"4x8":{min:20,max:260},"4x9":{min:23,max:330},"4x10":{min:26,max:400},"5x3":{min:7,max:25},"5x4":{min:11,max:70},"5x5":{min:15,max:130},"5x6":{min:19,max:200},"5x7":{min:23,max:280},"5x8":{min:27,max:370},"5x9":{min:31,max:470},"5x10":{min:35,max:580}},oe=(u,t)=>{const e=`${u}x${t}`;if(se[e])return se[e];const i=(u-1)*t,s=Math.max(5,Math.floor(i*.7)),o=Math.floor(i*5);return{min:s,max:o}};function ne(u){return function(){u|=0,u=u+1831565813|0;var t=Math.imul(u^u>>>15,1|u);return t=t+Math.imul(t^t>>>7,61|t)^t,((t^t>>>14)>>>0)/4294967296}}class W{constructor(t){this.solution={},this.valueMap=new Map,this.reverseSolution=new Map,this.seed=t,this.random=ne(t),this.solver=new te}getClueCountBounds(t,e,i=10){let s=1/0,o=0;for(let l=0;l<i;l++){const n=this.seed+l+1,a=new W(n);try{const r=a.internalGenerate(t,e,"min");r&&(s=Math.min(s,r.clues.length))}catch{}try{const f=new W(n).internalGenerate(t,e,"max");f&&(o=Math.max(o,f.clues.length))}catch{}}return s===1/0&&(s=0),{min:s,max:o}}generatePuzzle(t,e,i={}){if(t.length<2)throw new D("Puzzle must have at least 2 categories.");const{targetClueCount:s,maxCandidates:o=50,timeoutMs:l=1e4}=i,n=e||this.generateRandomTarget(t);this.validateTarget(t,n);const a=i.constraints;if(a!=null&&a.allowedClueTypes){const r=a.allowedClueTypes,f=t.some(d=>d.type===B.ORDINAL),m=r.includes(g.ORDINAL),c=r.includes(g.CROSS_ORDINAL);if(m&&!f&&!r.includes(g.BINARY))throw new D("Invalid Constraints: Ordinal-based clue types were requested, but no Ordinal categories exist. Please add an ordinal category or allow Binary clues.");if(c&&t.filter(p=>p.type===B.ORDINAL).length<2)throw new D("Invalid Constraints: Cross-Ordinal clues require at least 2 Ordinal Categories.")}return this.internalGenerate(t,n,"standard",{maxCandidates:o,targetClueCount:s,timeoutMs:l,constraints:i.constraints,onTrace:i.onTrace})}validateTarget(t,e){const i=new Set(t.map(s=>s.id));if(!i.has(e.category1Id)||!i.has(e.category2Id))throw new D("Target fact refers to non-existent categories.");if(e.category1Id===e.category2Id)throw new D("Target fact must refer to two different categories.")}generateRandomTarget(t){const e=Math.floor(this.random()*t.length);let i=Math.floor(this.random()*t.length);for(;i===e;)i=Math.floor(this.random()*t.length);const s=t[e],o=t[i],l=Math.floor(this.random()*s.values.length);return{category1Id:s.id,value1:s.values[l],category2Id:o.id}}async generatePuzzleAsync(t,e,i={}){return new Promise((s,o)=>{setTimeout(()=>{try{const l=this.generatePuzzle(t,e,i);s(l)}catch(l){o(l)}},0)})}async getClueCountBoundsAsync(t,e,i=10){return new Promise((s,o)=>{setTimeout(()=>{try{const l=this.getClueCountBounds(t,e,i);s(l)}catch(l){o(l)}},0)})}startSession(t,e){if(t.length<2)throw new D("Must have at least 2 categories.");let i=e;if(!i){const n=Math.floor(this.random()*t.length);let a=Math.floor(this.random()*t.length);for(;a===n;)a=Math.floor(this.random()*t.length);const r=t[n],f=t[a],m=Math.floor(this.random()*r.values.length);i={category1Id:r.id,value1:r.values[m],category2Id:f.id}}const s=new Map,o={},l=new Map;return this.createSolution(t,s,o,l),new ae(this,t,o,l,s,i)}internalGenerate(t,e,i,s){if(!t||t.length<2)throw new D("At least 2 categories are required to generate a puzzle.");const o=(s==null?void 0:s.maxCandidates)??1/0,l=s==null?void 0:s.targetClueCount,n=s==null?void 0:s.constraints;s!=null&&s.onTrace&&s.onTrace("Generator: internalGenerate started.");const a=t.find(d=>d.id===e.category1Id);if(a&&!a.values.includes(e.value1))throw new D(`Target value '${e.value1}' does not exist in category '${e.category1Id}'.`);if(n!=null&&n.allowedClueTypes){const d=[g.BINARY,g.ORDINAL,g.CROSS_ORDINAL],p=n.allowedClueTypes.some(N=>d.includes(N));if(n.allowedClueTypes.length>0&&!p)throw new D("Invalid Constraints: The selected clue types are ambiguous on their own. Please allow at least one identity-resolving type (Binary, Ordinal, or Cross-Ordinal).");const v=t.filter(N=>N.type===B.ORDINAL),h=v.length,y=h>0,b=[g.ORDINAL,g.SUPERLATIVE,g.UNARY,g.CROSS_ORDINAL];if(n.allowedClueTypes.some(N=>b.includes(N))&&!y&&!n.allowedClueTypes.includes(g.BINARY))throw new D("Invalid Constraints: Ordinal-based clue types were requested, but no Ordinal categories exist. Please add an ordinal category or allow Binary clues.");if(n.allowedClueTypes.includes(g.CROSS_ORDINAL)&&h<2)throw new D("Invalid Constraints: Cross-Ordinal clues require at least two separate Ordinal categories.");if(n.allowedClueTypes.includes(g.UNARY)&&!v.some(x=>{const w=x.values.map(I=>Number(I)).filter(I=>!isNaN(I)),A=w.some(I=>I%2!==0),E=w.some(I=>I%2===0);return A&&E}))throw new D("Invalid Constraints: Unary clues (Even/Odd) require at least one Ordinal category to contain both odd and even values.")}for(const d of t)if(d.type===B.ORDINAL&&d.values.some(v=>typeof v!="number"&&isNaN(Number(v))))throw new D(`Category '${d.id}' is ORDINAL but contains non-numeric values.`);if(this.valueMap=new Map,this.solution={},this.reverseSolution=new Map,s!=null&&s.onTrace&&s.onTrace("Generator: Creating solution..."),this.createSolution(t,this.valueMap,this.solution,this.reverseSolution),s!=null&&s.onTrace&&s.onTrace("Generator: Solution created."),l!==void 0){const d=t.length,p=t[0].values.length,v=oe(d,p);s!=null&&s.onTrace&&s.onTrace(`Generator: Feasibility check complete. Recommended bounds: ${v.min}-${v.max}`);const h=0;let y=l;v.min>0&&l<v.min-h&&(console.warn(`Target clue count ${l} is too low (Estimated min: ${v.min}). Auto-adjusting to ${v.min}.`),y=v.min);try{return this.generateWithBacktracking(t,e,y,o,i,(s==null?void 0:s.timeoutMs)??1e4,s==null?void 0:s.constraints,s==null?void 0:s.onTrace)}catch(b){throw b}}s!=null&&s.onTrace&&s.onTrace("Generator: Generating all possible clues...");let r=this.generateAllPossibleClues(t,s==null?void 0:s.constraints,this.reverseSolution,this.valueMap);s!=null&&s.onTrace&&s.onTrace(`Generator: Generated ${r.length} candidate clues.`);const f=new H(t),m=[],c=100;for(;m.length<c;){if(s!=null&&s.onTrace){const x=m.length,w=f.getGridStats(),A=Math.max(1,w.totalPossible-w.solutionPossible),E=Math.max(0,w.currentPossible-w.solutionPossible),I=Math.min(100,Math.round((A-E)/A*100));if(s.onTrace(`Depth ${x}: ${I}% Solved. Candidates: ${r.length}`),I>=100&&this.isPuzzleSolved(f,this.solution,this.reverseSolution)){s.onTrace("Generator: Puzzle Solved (100%).");break}}let d=null,p=null;if(o<r.length)for(let x=r.length-1;x>0;x--){const w=Math.floor(this.random()*(x+1));[r[x],r[w]]=[r[w],r[x]]}const v=Math.min(r.length,o);let h=0;for(let x=r.length-1;x>=0&&!(h>=v);x--){const w=r[x],A=f.clone(),{deductions:E}=this.solver.applyClue(A,w);if(E===0){r.splice(x,1);continue}h++;let I=0;i==="min"?I=E*1e3:i==="max"?I=100/E:I=this.calculateClueScore(A,e,E,w,m.map(U=>U.clue),this.solution,this.reverseSolution),w.type;const k=this.solution[e.category2Id][e.value1],K=A.isPossible(e.category1Id,e.value1,e.category2Id,k)&&A.getPossibilitiesCount(e.category1Id,e.value1,e.category2Id)===1,J=this.isPuzzleSolved(A,this.solution,this.reverseSolution);K&&(J?p={clue:w,score:I+1e6}:I=-1e6),I>-999999&&(!d||I>d.score)&&(d={clue:w,score:I})}const y=p||d;if(!y)break;const b=y.clue,{deductions:R}=this.solver.applyClue(f,b);m.push({clue:b,deductions:R});const N=r.findIndex(x=>JSON.stringify(x)===JSON.stringify(b));if(N>-1&&r.splice(N,1),this.isPuzzleSolved(f,this.solution,this.reverseSolution))break}return{solution:this.solution,clues:m.map(d=>d.clue),proofChain:m,categories:t,targetFact:e}}generateWithBacktracking(t,e,i,s,o,l=1e4,n,a){const r=this.generateAllPossibleClues(t,n,this.reverseSolution,this.valueMap),f=new H(t);let m=0;const c=Date.now(),d=(v,h,y,b)=>{const x=1+(Date.now()-c)/l*3;if(a&&h.length%1===0){const C=h.length+1,T=v.getGridStats(),P=Math.round((T.totalPossible-T.currentPossible)/(T.totalPossible-T.solutionPossible)*100);Math.random()<.05&&a(`Depth ${C}/${i}: ${P}% Solved. Bias: ${x.toFixed(2)} (Backtracks: ${m})`)}if(this.isPuzzleSolved(v,this.solution,this.reverseSolution))return h.length===i?(a&&a(`SOLVED! Exact match at ${i} clues.`),h):null;if(h.length>=i)return null;const A=v.getGridStats(),E=(A.totalPossible-A.currentPossible)/(A.totalPossible-A.solutionPossible),I=h.length+1;let k=[];if(s<y.length)for(let C=y.length-1;C>0;C--){const T=Math.floor(this.random()*(C+1));[y[C],y[T]]=[y[T],y[C]]}const J=Math.max(1,Math.floor((b?3:s===1/0?50:s)/Math.pow(x,2))),U=Math.min(y.length,J);a&&Math.random()<.001&&a(`Pruning: Limit reduced to ${U} (Bias ${x.toFixed(1)})`);let S=0;for(let C=0;C<y.length&&!(S>=U);C++){const T=y[C],P=v.clone(),{deductions:V}=this.solver.applyClue(P,T);if(V===0||(S++,this.isPuzzleSolved(P,this.solution,this.reverseSolution)&&I<i))continue;let j=this.calculateClueScore(P,e,V,T,h.map(Y=>Y.clue),this.solution,this.reverseSolution);if(i){const Y=I/i,Q=(A.totalPossible-P.getGridStats().currentPossible)/(A.totalPossible-A.solutionPossible),$=Math.pow(Y,1.8),Z=Q-$;j-=Z*V*50}k.push({clue:T,deductions:V,score:j,grid:P,index:C})}let M=[],L,O;if(b){const C=b==="STALL";M=k.sort((T,P)=>{const V=T.deductions-P.deductions;return C?V:-V})}else k.sort((C,T)=>T.score-C.score),L=k[0];if(!b){if(O=k[0],i){const C=Math.pow(I/i,1.8);E>C?O=[...k].sort((P,V)=>P.deductions!==V.deductions?P.deductions-V.deductions:V.score-P.score)[0]:O=[...k].sort((P,V)=>P.deductions!==V.deductions?V.deductions-P.deductions:V.score-P.score)[0]}L&&M.push(L),O&&O!==L&&M.push(O);for(const C of k)C!==L&&C!==O&&M.push(C)}for(const C of M){const T=1+(Date.now()-c)/l*4;if(i&&h.length>4&&T>1.1&&!(!!b||C===L||C===O))break;const P=[...y];P.splice(C.index,1);const V=C===L,q=C===O&&C!==L;let j=b,Y="";if(!b&&q&&i){const $=E>I/i,Z=`(Prog ${E.toFixed(2)} vs Exp ${(I/i).toFixed(2)})`;j=$?"STALL":"SPEED",Y=$?`(Stalling - Weakest) ${Z}`:`(Speeding - Strongest) ${Z}`}else b&&(Y=`(Continued ${b})`);if(a&&(q||b||Math.random()<.05)){const $=b?`STICKY ${b}`:V?"Primary":q?"CORRECTION":"Rest";q?a(`[BACKTRACK] Depth ${h.length}: Primary Strategy Failed. Switching to ${Y}. Ded: ${C.deductions}`):b?Math.random()<.1&&a(`Depth ${h.length}: ${Math.round(E*100)}% Solved. Strategy: ${$}. Ded: ${C.deductions}`):a(`Depth ${h.length}: ${Math.round(E*100)}% Solved. Trying ${$} Cand. Ded: ${C.deductions}`)}const Q=d(C.grid,[...h,{clue:C.clue,deductions:C.deductions}],P,j);if(Q)return Q}return m++,null},p=d(f,[],[...r]);if(p)return{solution:this.solution,clues:p.map(h=>h.clue),proofChain:p,categories:t,targetFact:e};throw new D(`Could not generate puzzle with exactly ${i} clues within timeout.`)}createSolution(t,e,i,s){var l;const o=t[0];o.values.forEach(n=>{e.set(n,{[o.id]:n})});for(let n=1;n<t.length;n++){const a=t[n],r=[...a.values].sort(()=>this.random()-.5);let f=0;for(const m of o.values){const c=e.get(m);c&&(c[a.id]=r[f++])}}for(const n of t)i[n.id]={},s.set(n.id,new Map);for(const n of o.values){const a=e.get(n);if(a)for(const r in a)i[r][n]=a[r],(l=s.get(r))==null||l.set(a[r],n)}}generateAllPossibleClues(t,e,i,s){var n,a,r,f,m;const o=[];t[0];const l=c=>!(e!=null&&e.allowedClueTypes)||e.allowedClueTypes.includes(c);if(l(g.BINARY))for(const c of t)for(const d of c.values)for(const p of t){if(c.id>=p.id)continue;const v=(n=i.get(c.id))==null?void 0:n.get(d);if(!v)continue;const h=s.get(v);if(h)for(const y of p.values){const b=h[p.id];y===b?o.push({type:g.BINARY,operator:_.IS,cat1:c.id,val1:d,cat2:p.id,val2:y}):o.push({type:g.BINARY,operator:_.IS_NOT,cat1:c.id,val1:d,cat2:p.id,val2:y})}}for(const c of t.filter(d=>d.type===B.ORDINAL)){const d=[...c.values].sort((h,y)=>h-y),p=d[0],v=d[d.length-1];if(l(g.SUPERLATIVE)){for(const h of t)if(h.id!==c.id)for(const y of h.values){const b=(a=i.get(h.id))==null?void 0:a.get(y);if(!b)continue;const R=s.get(b);if(!R)continue;const N=R[c.id];N===p?o.push({type:g.SUPERLATIVE,operator:G.MIN,targetCat:h.id,targetVal:y,ordinalCat:c.id}):o.push({type:g.SUPERLATIVE,operator:G.NOT_MIN,targetCat:h.id,targetVal:y,ordinalCat:c.id}),N===v?o.push({type:g.SUPERLATIVE,operator:G.MAX,targetCat:h.id,targetVal:y,ordinalCat:c.id}):o.push({type:g.SUPERLATIVE,operator:G.NOT_MAX,targetCat:h.id,targetVal:y,ordinalCat:c.id})}}if(l(g.ORDINAL)){for(const h of t)if(h.id!==c.id){for(const y of t)if(y.id!==c.id)for(const b of h.values)for(const R of y.values){if(h.id===y.id&&b===R)continue;const N=(r=i.get(h.id))==null?void 0:r.get(b),x=(f=i.get(y.id))==null?void 0:f.get(R);if(!N||!x||N===x)continue;const w=s.get(N),A=s.get(x);if(!w||!A)continue;const E=w[c.id],I=A[c.id];E>I?(o.push({type:g.ORDINAL,operator:z.GREATER_THAN,item1Cat:h.id,item1Val:b,item2Cat:y.id,item2Val:R,ordinalCat:c.id}),o.push({type:g.ORDINAL,operator:z.NOT_LESS_THAN,item1Cat:h.id,item1Val:b,item2Cat:y.id,item2Val:R,ordinalCat:c.id})):E<I&&(o.push({type:g.ORDINAL,operator:z.LESS_THAN,item1Cat:h.id,item1Val:b,item2Cat:y.id,item2Val:R,ordinalCat:c.id}),o.push({type:g.ORDINAL,operator:z.NOT_GREATER_THAN,item1Cat:h.id,item1Val:b,item2Cat:y.id,item2Val:R,ordinalCat:c.id}))}}}}if(l(g.UNARY)){for(const c of t)if(c.type===B.ORDINAL&&c.values.every(d=>typeof d=="number")){for(const d of t)if(d.id!==c.id)for(const p of d.values){const v=(m=i.get(d.id))==null?void 0:m.get(p);if(!v)continue;const h=s.get(v);if(!h)continue;h[c.id]%2===0?o.push({type:g.UNARY,filter:X.IS_EVEN,targetCat:d.id,targetVal:p,ordinalCat:c.id}):o.push({type:g.UNARY,filter:X.IS_ODD,targetCat:d.id,targetVal:p,ordinalCat:c.id})}}}return o}calculateClueScore(t,e,i,s,o,l,n){var U;const a=s.type,r=(U=n.get(e.category1Id))==null?void 0:U.get(e.value1);let f;r!==void 0&&(f=l[e.category2Id][r]);const m=f!==void 0&&t.isPossible(e.category1Id,e.value1,e.category2Id,f)&&t.getPossibilitiesCount(e.category1Id,e.value1,e.category2Id)===1,c=this.isPuzzleSolved(t,l,n);if(s.type===g.BINARY&&s.operator===_.IS){const S=s;if(S.cat1===e.category1Id&&S.val1===e.value1&&S.cat2===e.category2Id&&S.val2===f||S.cat1===e.category2Id&&S.val1===f&&S.cat2===e.category1Id&&S.val2===e.value1)return-1/0}if(m&&c)return 1e6;if(m&&!c)return-1e6;const d=i,{totalPossible:p,currentPossible:v,solutionPossible:h}=t.getGridStats(),y=p-h,b=p-v,R=y>0?b/y:0;let N=0;switch(a){case g.ORDINAL:N=1.5,s.operator>=2&&(N=5);break;case g.SUPERLATIVE:N=1.2,s.operator>=2&&(N=5);break;case g.UNARY:N=1.2;break;case g.BINARY:N=1,s.operator===_.IS_NOT&&(N=5);break}let x=0;const w=S=>{const M=(C,T)=>{var P;return(P=this.reverseSolution.get(C))==null?void 0:P.get(T)};let L=[],O=[];switch(S.type){case g.BINARY:const C=S;L.push(M(C.cat1,C.val1)),C.operator===_.IS_NOT&&O.push(M(C.cat2,C.val2));break;case g.SUPERLATIVE:const T=S;L.push(M(T.targetCat,T.targetVal));break;case g.ORDINAL:const P=S;L.push(M(P.item1Cat,P.item1Val)),O.push(M(P.item2Cat,P.item2Val));break;case g.UNARY:const V=S;L.push(M(V.targetCat,V.targetVal));break}return{primary:L.filter(C=>!!C),secondary:O.filter(C=>!!C)}},A=new Set;for(const S of o){const{primary:M,secondary:L}=w(S);M.forEach(O=>A.add(O)),L.forEach(O=>A.add(O))}const{primary:E,secondary:I}=w(s);E.forEach(S=>{A.has(S)&&(x+=1)}),I.forEach(S=>{A.has(S)&&(x+=.5)});const k=s.ordinalCat;if(k)for(const S of o){const M=S.ordinalCat;k===M&&(x+=.5)}if(o.length>0){const S=o[o.length-1];if(s.type===S.type&&(x+=2,s.type===g.BINARY&&s.operator===_.IS&&S.operator===_.IS&&(x+=2)),o.length>1){const C=o[o.length-2];s.type===S.type&&s.type===C.type&&(x+=5)}const M=C=>{switch(C.type){case g.SUPERLATIVE:return 1;case g.BINARY:return C.operator===_.IS?1:3;case g.ORDINAL:return 3;case g.UNARY:return 3;case g.CROSS_ORDINAL:return 4;default:return 2}},L=M(s),O=M(S);L===O&&(x+=1.5)}const K=Math.pow(.4,x);return(d*N+R*5)*K}isPuzzleSolved(t,e,i){var o;const s=t.categories;s[0];for(const l of s)for(const n of l.values)for(const a of s){if(l.id>=a.id)continue;const r=(o=i.get(l.id))==null?void 0:o.get(n);if(!r)return!1;const f=e[a.id][r];if(t.getPossibilitiesCount(l.id,n,a.id)>1||!t.isPossible(l.id,n,a.id,f))return!1}return!0}}const F=self;F.onmessage=u=>{const{type:t}=u.data;if(t==="start"){const{categories:e,targetFact:i,options:s}=u.data;s&&s.targetClueCount&&(s.targetClueCount=parseInt(String(s.targetClueCount),10));try{const o=new W(s==null?void 0:s.seed),l={...s,onTrace:a=>{F.postMessage({type:"trace",message:a})}};let n;try{n=o.generatePuzzle(e,i,l)}catch(a){if(s.targetClueCount&&a.message&&a.message.includes("Could not generate puzzle")){F.postMessage({type:"trace",message:`⚠️ Strict generation failed (${a.message}). Falling back to best-effort generation...`});const r={...l,targetClueCount:void 0};n=o.generatePuzzle(e,i,r)}else throw a}F.postMessage({type:"done",puzzle:n})}catch(o){console.error("Worker Generation Error:",o),F.postMessage({type:"error",message:o.message||"Unknown worker error"})}}}})();
