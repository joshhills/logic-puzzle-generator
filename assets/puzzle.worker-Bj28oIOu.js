(function(){"use strict";var B=(f=>(f[f.NOMINAL=0]="NOMINAL",f[f.ORDINAL=1]="ORDINAL",f))(B||{}),C=(f=>(f[f.BINARY=0]="BINARY",f[f.ORDINAL=1]="ORDINAL",f[f.SUPERLATIVE=2]="SUPERLATIVE",f[f.UNARY=3]="UNARY",f[f.CROSS_ORDINAL=4]="CROSS_ORDINAL",f))(C||{}),ee=(f=>(f[f.MATCH=0]="MATCH",f[f.NOT_MATCH=1]="NOT_MATCH",f))(ee||{}),z=(f=>(f[f.IS=0]="IS",f[f.IS_NOT=1]="IS_NOT",f))(z||{}),D=(f=>(f[f.GREATER_THAN=0]="GREATER_THAN",f[f.LESS_THAN=1]="LESS_THAN",f[f.NOT_GREATER_THAN=2]="NOT_GREATER_THAN",f[f.NOT_LESS_THAN=3]="NOT_LESS_THAN",f))(D||{}),G=(f=>(f[f.MIN=0]="MIN",f[f.MAX=1]="MAX",f[f.NOT_MIN=2]="NOT_MIN",f[f.NOT_MAX=3]="NOT_MAX",f))(G||{}),W=(f=>(f[f.IS_ODD=0]="IS_ODD",f[f.IS_EVEN=1]="IS_EVEN",f))(W||{});class ie extends Error{constructor(t){super(t),this.name="LogicPuzzleError"}}class _ extends ie{constructor(t){super(t),this.name="ConfigurationError"}}class H{constructor(t){this.validateConfig(t),this.categories=t,this.valueMap=new Map(t.map(e=>[e.id,new Map(e.values.map((a,s)=>[a,s]))])),this.grid=new Map;for(const e of t){const a=new Map;for(const s of e.values){const o=new Map;for(const l of t)e.id!==l.id&&o.set(l.id,Array(l.values.length).fill(!0));a.set(s,o)}this.grid.set(e.id,a)}}validateConfig(t){const e=new Set;let a=-1;for(const s of t){if(e.has(s.id))throw new _(`Duplicate category ID found: ${s.id}`);if(e.add(s.id),new Set(s.values).size!==s.values.length)throw new _(`Category '${s.id}' has duplicate values.`);if(a===-1)a=s.values.length;else if(s.values.length!==a)throw new _(`Category '${s.id}' has ${s.values.length} values, expected ${a}. All categories must be the same size.`)}}setPossibility(t,e,a,s,o){var i,r;const l=(i=this.valueMap.get(a))==null?void 0:i.get(s);if(l!==void 0){const d=this.grid.get(t);if(d){const m=d.get(e);if(m){const c=m.get(a);c&&(c[l]=o)}}}const n=(r=this.valueMap.get(t))==null?void 0:r.get(e);if(n!==void 0){const d=this.grid.get(a);if(d){const m=d.get(s);if(m){const c=m.get(t);c&&(c[n]=o)}}}}isPossible(t,e,a,s){var r;if(t===a)return e===s;const o=(r=this.valueMap.get(a))==null?void 0:r.get(s);if(o===void 0)return!1;const l=this.grid.get(t);if(!l)return!1;const n=l.get(e);if(!n)return!1;const i=n.get(a);return i?i[o]:!1}getPossibilitiesCount(t,e,a){var o,l;const s=(l=(o=this.grid.get(t))==null?void 0:o.get(e))==null?void 0:l.get(a);return s?s.filter(n=>n).length:0}getGridStats(){var n,i,r;let t=0;const e=this.categories.length,a=((n=this.categories[0])==null?void 0:n.values.length)||0;if(a===0||e<2)return{totalPossible:0,currentPossible:0,solutionPossible:0};const s=e*(e-1)/2,o=s*a*a,l=s*a;for(const d of this.categories)for(const m of d.values)for(const c of this.categories){if(d.id>=c.id)continue;const u=(r=(i=this.grid.get(d.id))==null?void 0:i.get(m))==null?void 0:r.get(c.id);u&&(t+=u.filter(b=>b).length)}return{totalPossible:o,currentPossible:t,solutionPossible:l}}clone(){const t=new H(this.categories);return t.grid=new Map([...this.grid.entries()].map(([e,a])=>[e,new Map([...a.entries()].map(([s,o])=>[s,new Map([...o.entries()].map(([l,n])=>[l,[...n]]))]))])),t}}class te{applyClue(t,e){let a=0;switch(e.type){case C.BINARY:a+=this.applyBinaryClue(t,e);break;case C.SUPERLATIVE:a+=this.applySuperlativeClue(t,e);break;case C.ORDINAL:a+=this.applyOrdinalClue(t,e);break;case C.UNARY:a+=this.applyUnaryClue(t,e);break;case C.CROSS_ORDINAL:a+=this.applyCrossOrdinalClue(t,e);break}let s;do s=this.runDeductionLoop(t),a+=s;while(s>0);return{grid:t,deductions:a}}applyCrossOrdinalClue(t,e){let a=0;const s=t.categories,o=s.find(m=>m.id===e.ordinal1),l=s.find(m=>m.id===e.ordinal2);if(!o||!l)return 0;const n=e.operator===ee.NOT_MATCH,i=(m,c,u,b)=>b.values.map((v,h)=>({val:v,idx:h})).filter(v=>t.isPossible(m,c,u,v.val)),r=i(e.item1Cat,e.item1Val,e.ordinal1,o),d=i(e.item2Cat,e.item2Val,e.ordinal2,l);if(n){if(r.length===1&&d.length===1){const m=r[0].idx+e.offset1,c=d[0].idx+e.offset2,u=o.values[m],b=l.values[c];u!==void 0&&b!==void 0&&t.isPossible(e.ordinal1,u,e.ordinal2,b)&&(t.setPossibility(e.ordinal1,u,e.ordinal2,b,!1),a++)}for(const m of r){const c=m.idx+e.offset1;if(o.values[c]!==void 0)for(const b of d){const v=b.idx+e.offset2;l.values[v]}}if(r.length===1){const m=r[0].idx+e.offset1,c=o.values[m];if(c!==void 0)for(const u of d){const b=u.idx+e.offset2,v=l.values[b];v!==void 0&&t.isPossible(e.ordinal1,c,e.ordinal2,v)&&(t.setPossibility(e.item2Cat,e.item2Val,e.ordinal2,u.val,!1),a++)}}if(d.length===1){const m=d[0].idx+e.offset2,c=l.values[m];if(c!==void 0)for(const u of r){const b=u.idx+e.offset1,v=o.values[b];v!==void 0&&t.isPossible(e.ordinal1,v,e.ordinal2,c)&&(t.setPossibility(e.item1Cat,e.item1Val,e.ordinal1,u.val,!1),a++)}}}else{for(const u of r){const b=u.idx+e.offset1,v=o.values[b];if(v===void 0){t.setPossibility(e.item1Cat,e.item1Val,e.ordinal1,u.val,!1),a++;continue}let h=!1;for(const p of d){const y=p.idx+e.offset2,R=l.values[y];if(R!==void 0&&t.isPossible(e.ordinal1,v,e.ordinal2,R)){h=!0;break}}h||(t.setPossibility(e.item1Cat,e.item1Val,e.ordinal1,u.val,!1),a++)}for(const u of d){const b=u.idx+e.offset2,v=l.values[b];if(v===void 0){t.setPossibility(e.item2Cat,e.item2Val,e.ordinal2,u.val,!1),a++;continue}let h=!1;for(const p of r){const y=p.idx+e.offset1,R=o.values[y];if(R!==void 0&&t.isPossible(e.ordinal1,R,e.ordinal2,v)){h=!0;break}}h||(t.setPossibility(e.item2Cat,e.item2Val,e.ordinal2,u.val,!1),a++)}const m=i(e.item1Cat,e.item1Val,e.ordinal1,o),c=i(e.item2Cat,e.item2Val,e.ordinal2,l);if(m.length===1&&c.length===1){const u=m[0].idx+e.offset1,b=c[0].idx+e.offset2,v=o.values[u],h=l.values[b];v!==void 0&&h!==void 0&&t.getPossibilitiesCount(e.ordinal1,v,e.ordinal2)>1&&(t.setPossibility(e.ordinal1,v,e.ordinal2,h,!0),a++)}}return a}applyUnaryClue(t,e){let a=0;const o=t.categories.find(n=>n.id===e.ordinalCat);if(!o||o.type!==B.ORDINAL||!o.values.every(n=>typeof n=="number"))return 0;const l=e.filter===W.IS_EVEN;for(const n of o.values){const i=n;(l?i%2!==0:i%2===0)&&t.isPossible(e.targetCat,e.targetVal,e.ordinalCat,n)&&(t.setPossibility(e.targetCat,e.targetVal,e.ordinalCat,n,!1),a++)}return a}applyBinaryClue(t,e){let a=0;const s=t.categories,o=s.find(n=>n.id===e.cat1),l=s.find(n=>n.id===e.cat2);if(!o||!l)return 0;if(e.operator===z.IS){t.isPossible(e.cat1,e.val1,e.cat2,e.val2),t.setPossibility(e.cat1,e.val1,e.cat2,e.val2,!0);for(const n of l.values)n!==e.val2&&t.isPossible(e.cat1,e.val1,e.cat2,n)&&(t.setPossibility(e.cat1,e.val1,e.cat2,n,!1),a++);for(const n of o.values)n!==e.val1&&t.isPossible(e.cat1,n,e.cat2,e.val2)&&(t.setPossibility(e.cat1,n,e.cat2,e.val2,!1),a++)}else t.isPossible(e.cat1,e.val1,e.cat2,e.val2)&&(t.setPossibility(e.cat1,e.val1,e.cat2,e.val2,!1),a++);return a}runDeductionLoop(t){let e=0;const a=t.categories;for(const s of a)for(const o of s.values)for(const l of a){if(s.id===l.id)continue;const n=l.values.filter(i=>t.isPossible(s.id,o,l.id,i));if(n.length===1){const i=n[0];for(const r of s.values)r!==o&&t.isPossible(s.id,r,l.id,i)&&(t.setPossibility(s.id,r,l.id,i,!1),e++)}for(const i of a){if(s.id===i.id||l.id===i.id)continue;const r=n.length===1?n[0]:null;if(r){const d=i.values.filter(m=>t.isPossible(l.id,r,i.id,m));if(d.length===1){const m=d[0];t.isPossible(s.id,o,i.id,m)===!1||t.getPossibilitiesCount(s.id,o,i.id)>1&&(t.setPossibility(s.id,o,i.id,m,!0),e++)}}for(const d of i.values)t.isPossible(s.id,o,i.id,d)&&(l.values.some(c=>t.isPossible(s.id,o,l.id,c)&&t.isPossible(l.id,c,i.id,d))||(t.setPossibility(s.id,o,i.id,d,!1),e++))}}return e}applyOrdinalClue(t,e){let a=0;const o=t.categories.find(i=>i.id===e.ordinalCat);if(!o||o.type!==B.ORDINAL)return 0;const l=o.values.map((i,r)=>({val:i,idx:r})).filter(i=>t.isPossible(e.item1Cat,e.item1Val,e.ordinalCat,i.val)),n=o.values.map((i,r)=>({val:i,idx:r})).filter(i=>t.isPossible(e.item2Cat,e.item2Val,e.ordinalCat,i.val));if(l.length===0||n.length===0)return 0;if(e.operator===D.GREATER_THAN)for(const i of l)n.some(d=>i.idx>d.idx)||t.isPossible(e.item1Cat,e.item1Val,e.ordinalCat,i.val)&&(t.setPossibility(e.item1Cat,e.item1Val,e.ordinalCat,i.val,!1),a++);else if(e.operator===D.LESS_THAN)for(const i of l)n.some(d=>i.idx<d.idx)||t.isPossible(e.item1Cat,e.item1Val,e.ordinalCat,i.val)&&(t.setPossibility(e.item1Cat,e.item1Val,e.ordinalCat,i.val,!1),a++);else if(e.operator===D.NOT_GREATER_THAN)for(const i of l)n.some(d=>i.idx<=d.idx)||t.isPossible(e.item1Cat,e.item1Val,e.ordinalCat,i.val)&&(t.setPossibility(e.item1Cat,e.item1Val,e.ordinalCat,i.val,!1),a++);else if(e.operator===D.NOT_LESS_THAN)for(const i of l)n.some(d=>i.idx>=d.idx)||t.isPossible(e.item1Cat,e.item1Val,e.ordinalCat,i.val)&&(t.setPossibility(e.item1Cat,e.item1Val,e.ordinalCat,i.val,!1),a++);if(e.operator===D.GREATER_THAN)for(const i of n)l.some(d=>i.idx<d.idx)||t.isPossible(e.item2Cat,e.item2Val,e.ordinalCat,i.val)&&(t.setPossibility(e.item2Cat,e.item2Val,e.ordinalCat,i.val,!1),a++);else if(e.operator===D.LESS_THAN)for(const i of n)l.some(d=>i.idx>d.idx)||t.isPossible(e.item2Cat,e.item2Val,e.ordinalCat,i.val)&&(t.setPossibility(e.item2Cat,e.item2Val,e.ordinalCat,i.val,!1),a++);else if(e.operator===D.NOT_GREATER_THAN)for(const i of n)l.some(d=>i.idx>=d.idx)||t.isPossible(e.item2Cat,e.item2Val,e.ordinalCat,i.val)&&(t.setPossibility(e.item2Cat,e.item2Val,e.ordinalCat,i.val,!1),a++);else if(e.operator===D.NOT_LESS_THAN)for(const i of n)l.some(d=>i.idx<=d.idx)||t.isPossible(e.item2Cat,e.item2Val,e.ordinalCat,i.val)&&(t.setPossibility(e.item2Cat,e.item2Val,e.ordinalCat,i.val,!1),a++);return a}applySuperlativeClue(t,e){const s=t.categories.find(i=>i.id===e.ordinalCat);if(!s||s.type!==B.ORDINAL)return 0;let o,l=!1;switch(e.operator){case G.MAX:o=s.values[s.values.length-1];break;case G.MIN:o=s.values[0];break;case G.NOT_MAX:o=s.values[s.values.length-1],l=!0;break;case G.NOT_MIN:o=s.values[0],l=!0;break;default:return 0}const n={type:C.BINARY,cat1:e.targetCat,val1:e.targetVal,cat2:e.ordinalCat,val2:o,operator:l?z.IS_NOT:z.IS};return this.applyBinaryClue(t,n)}}class ae{constructor(t,e,a,s,o,l){this.generator=t,this.categories=e,this.solution=a,this.reverseSolution=s,this.valueMap=o,this.targetFact=l,this.availableClues=[],this.proofChain=[],this.historyStack=[],this.grid=new H(e),this.solver=new te,this.availableClues=this.generator.generateAllPossibleClues(e,void 0,s,o)}getNextClue(t){const e=this.availableClues.filter(i=>!(t!=null&&t.allowedClueTypes&&!t.allowedClueTypes.includes(i.type)));let a=null,s=-1/0;const o=[...e].sort(()=>Math.random()-.5),l=50;let n=0;for(const i of o){if(n++,n>l&&a)break;this.generator.calculateClueScore(this.grid,this.targetFact,0,i,this.proofChain,this.solution,this.reverseSolution);const r=this.grid.clone(),{deductions:d}=this.solver.applyClue(r,i);if(d===0&&!this.isUseful(r))continue;const m=this.generator.calculateClueScore(this.grid,this.targetFact,d,i,this.proofChain,this.solution,this.reverseSolution);m>s&&(s=m,a=i)}if(a){this.historyStack.push(this.grid.clone()),this.solver.applyClue(this.grid,a),this.proofChain.push(a);const i=this.availableClues.indexOf(a);return i>-1&&this.availableClues.splice(i,1),{clue:a,remaining:this.availableClues.length,solved:this.generator.isPuzzleSolved(this.grid,this.solution,this.reverseSolution)}}return{clue:null,remaining:e.length,solved:this.generator.isPuzzleSolved(this.grid,this.solution,this.reverseSolution)}}rollbackLastClue(){if(this.historyStack.length===0)return{success:!1,clue:null};const t=this.historyStack.pop();t&&(this.grid=t);const e=this.proofChain.pop();return e?(this.availableClues.push(e),{success:!0,clue:e}):{success:!1,clue:null}}isUseful(t){return!0}getGrid(){return this.grid}getProofChain(){return this.proofChain}getSolution(){return this.solution}getValueMap(){return this.valueMap}}const se={"2x3":{min:2,max:2},"2x4":{min:3,max:10},"2x5":{min:4,max:17},"2x6":{min:5,max:26},"2x7":{min:6,max:37},"2x8":{min:7,max:50},"2x9":{min:8,max:65},"2x10":{min:9,max:82},"3x3":{min:3,max:9},"3x4":{min:5,max:26},"3x5":{min:7,max:47},"3x6":{min:9,max:72},"3x7":{min:11,max:100},"3x8":{min:13,max:130},"3x9":{min:15,max:160},"3x10":{min:17,max:200},"4x3":{min:5,max:16},"4x4":{min:8,max:44},"4x5":{min:11,max:87},"4x6":{min:14,max:140},"4x7":{min:17,max:200},"4x8":{min:20,max:260},"4x9":{min:23,max:330},"4x10":{min:26,max:400},"5x3":{min:7,max:25},"5x4":{min:11,max:70},"5x5":{min:15,max:130},"5x6":{min:19,max:200},"5x7":{min:23,max:280},"5x8":{min:27,max:370},"5x9":{min:31,max:470},"5x10":{min:35,max:580}},oe=(f,t)=>{const e=`${f}x${t}`;if(se[e])return se[e];const a=(f-1)*t,s=Math.max(5,Math.floor(a*.7)),o=Math.floor(a*5);return{min:s,max:o}};function ne(f){return function(){f|=0,f=f+1831565813|0;var t=Math.imul(f^f>>>15,1|f);return t=t+Math.imul(t^t>>>7,61|t)^t,((t^t>>>14)>>>0)/4294967296}}class j{constructor(t){this.solution={},this.valueMap=new Map,this.reverseSolution=new Map,this.seed=t,this.random=ne(t),this.solver=new te}getClueCountBounds(t,e,a=10){let s=1/0,o=0;for(let l=0;l<a;l++){const n=this.seed+l+1,i=new j(n);try{const r=i.internalGenerate(t,e,"min");r&&(s=Math.min(s,r.clues.length))}catch{}try{const d=new j(n).internalGenerate(t,e,"max");d&&(o=Math.max(o,d.clues.length))}catch{}}return s===1/0&&(s=0),{min:s,max:o}}generatePuzzle(t,e,a={}){const{targetClueCount:s,maxCandidates:o=50,timeoutMs:l=1e4}=a;if(t.length<2)throw new _("Must have at least 2 categories.");if(s!==void 0&&s<1)throw new _("Target clue count must be at least 1");if(o<1)throw new _("maxCandidates must be at least 1");let n=e;if(!n){const r=Math.floor(this.random()*t.length);let d=Math.floor(this.random()*t.length);for(;d===r;)d=Math.floor(this.random()*t.length);const m=t[r],c=t[d],u=Math.floor(this.random()*m.values.length);n={category1Id:m.id,value1:m.values[u],category2Id:c.id}}const i=new Set(t.map(r=>r.id));if(!i.has(n.category1Id)||!i.has(n.category2Id))throw new _("Target fact refers to non-existent categories.");if(n.category1Id===n.category2Id)throw new _("Target fact must refer to two different categories.");return this.internalGenerate(t,n,"standard",{maxCandidates:o,targetClueCount:s,timeoutMs:l,constraints:a.constraints,onTrace:a.onTrace})}startSession(t,e){if(t.length<2)throw new _("Must have at least 2 categories.");let a=e;if(!a){const n=Math.floor(this.random()*t.length);let i=Math.floor(this.random()*t.length);for(;i===n;)i=Math.floor(this.random()*t.length);const r=t[n],d=t[i],m=Math.floor(this.random()*r.values.length);a={category1Id:r.id,value1:r.values[m],category2Id:d.id}}const s=new Map,o={},l=new Map;return this.createSolution(t,s,o,l),new ae(this,t,o,l,s,a)}internalGenerate(t,e,a,s){if(!t||t.length<2)throw new _("At least 2 categories are required to generate a puzzle.");const o=(s==null?void 0:s.maxCandidates)??1/0,l=s==null?void 0:s.targetClueCount,n=s==null?void 0:s.constraints;s!=null&&s.onTrace&&s.onTrace("Generator: internalGenerate started.");const i=t.find(u=>u.id===e.category1Id);if(i&&!i.values.includes(e.value1))throw new _(`Target value '${e.value1}' does not exist in category '${e.category1Id}'.`);if(n!=null&&n.allowedClueTypes){const u=[C.BINARY,C.ORDINAL,C.CROSS_ORDINAL],b=n.allowedClueTypes.some(N=>u.includes(N));if(n.allowedClueTypes.length>0&&!b)throw new _("Invalid Constraints: The selected clue types are ambiguous on their own. Please allow at least one identity-resolving type (Binary, Ordinal, or Cross-Ordinal).");const v=t.filter(N=>N.type===B.ORDINAL),h=v.length,p=h>0,y=[C.ORDINAL,C.SUPERLATIVE,C.UNARY,C.CROSS_ORDINAL];if(n.allowedClueTypes.some(N=>y.includes(N))&&!p&&!n.allowedClueTypes.includes(C.BINARY))throw new _("Invalid Constraints: Ordinal-based clue types were requested, but no Ordinal categories exist. Please add an ordinal category or allow Binary clues.");if(n.allowedClueTypes.includes(C.CROSS_ORDINAL)&&h<2)throw new _("Invalid Constraints: Cross-Ordinal clues require at least two separate Ordinal categories.");if(n.allowedClueTypes.includes(C.UNARY)&&!v.some(x=>{const w=x.values.map(I=>Number(I)).filter(I=>!isNaN(I)),A=w.some(I=>I%2!==0),V=w.some(I=>I%2===0);return A&&V}))throw new _("Invalid Constraints: Unary clues (Even/Odd) require at least one Ordinal category to contain both odd and even values.")}for(const u of t)if(u.type===B.ORDINAL&&u.values.some(v=>typeof v!="number"&&isNaN(Number(v))))throw new _(`Category '${u.id}' is ORDINAL but contains non-numeric values.`);if(this.valueMap=new Map,this.solution={},this.reverseSolution=new Map,s!=null&&s.onTrace&&s.onTrace("Generator: Creating solution..."),this.createSolution(t,this.valueMap,this.solution,this.reverseSolution),s!=null&&s.onTrace&&s.onTrace("Generator: Solution created."),l!==void 0){const u=t.length,b=t[0].values.length,v=oe(u,b);s!=null&&s.onTrace&&s.onTrace(`Generator: Feasibility check complete. Recommended bounds: ${v.min}-${v.max}`);const h=0;let p=l;v.min>0&&l<v.min-h&&(console.warn(`Target clue count ${l} is too low (Estimated min: ${v.min}). Auto-adjusting to ${v.min}.`),p=v.min);try{return this.generateWithBacktracking(t,e,p,o,a,(s==null?void 0:s.timeoutMs)??1e4,s==null?void 0:s.constraints,s==null?void 0:s.onTrace)}catch(y){throw y}}s!=null&&s.onTrace&&s.onTrace("Generator: Generating all possible clues...");let r=this.generateAllPossibleClues(t,s==null?void 0:s.constraints,this.reverseSolution,this.valueMap);s!=null&&s.onTrace&&s.onTrace(`Generator: Generated ${r.length} candidate clues.`);const d=new H(t),m=[],c=100;for(;m.length<c;){if(s!=null&&s.onTrace){const x=m.length,w=d.getGridStats(),A=Math.max(1,w.totalPossible-w.solutionPossible),V=Math.max(0,w.currentPossible-w.solutionPossible),I=Math.min(100,Math.round((A-V)/A*100));if(s.onTrace(`Depth ${x}: ${I}% Solved. Candidates: ${r.length}`),I>=100&&this.isPuzzleSolved(d,this.solution,this.reverseSolution)){s.onTrace("Generator: Puzzle Solved (100%).");break}}let u=null,b=null;if(o<r.length)for(let x=r.length-1;x>0;x--){const w=Math.floor(this.random()*(x+1));[r[x],r[w]]=[r[w],r[x]]}const v=Math.min(r.length,o);let h=0;for(let x=r.length-1;x>=0&&!(h>=v);x--){const w=r[x],A=d.clone(),{deductions:V}=this.solver.applyClue(A,w);if(V===0){r.splice(x,1);continue}h++;let I=0;a==="min"?I=V*1e3:a==="max"?I=100/V:I=this.calculateClueScore(A,e,V,w,m.map(U=>U.clue),this.solution,this.reverseSolution),w.type;const k=this.solution[e.category2Id][e.value1],K=A.isPossible(e.category1Id,e.value1,e.category2Id,k)&&A.getPossibilitiesCount(e.category1Id,e.value1,e.category2Id)===1,J=this.isPuzzleSolved(A,this.solution,this.reverseSolution);K&&(J?b={clue:w,score:I+1e6}:I=-1e6),I>-999999&&(!u||I>u.score)&&(u={clue:w,score:I})}const p=b||u;if(!p)break;const y=p.clue,{deductions:R}=this.solver.applyClue(d,y);m.push({clue:y,deductions:R});const N=r.findIndex(x=>JSON.stringify(x)===JSON.stringify(y));if(N>-1&&r.splice(N,1),this.isPuzzleSolved(d,this.solution,this.reverseSolution))break}return{solution:this.solution,clues:m.map(u=>u.clue),proofChain:m,categories:t,targetFact:e}}generateWithBacktracking(t,e,a,s,o,l=1e4,n,i){const r=this.generateAllPossibleClues(t,n,this.reverseSolution,this.valueMap),d=new H(t);let m=0;const c=Date.now(),u=(v,h,p,y)=>{const x=1+(Date.now()-c)/l*3;if(i&&h.length%1===0){const g=h.length+1,T=v.getGridStats(),S=Math.round((T.totalPossible-T.currentPossible)/(T.totalPossible-T.solutionPossible)*100);Math.random()<.05&&i(`Depth ${g}/${a}: ${S}% Solved. Bias: ${x.toFixed(2)} (Backtracks: ${m})`)}if(this.isPuzzleSolved(v,this.solution,this.reverseSolution))return h.length===a?(i&&i(`SOLVED! Exact match at ${a} clues.`),h):null;if(h.length>=a)return null;const A=v.getGridStats(),V=(A.totalPossible-A.currentPossible)/(A.totalPossible-A.solutionPossible),I=h.length+1;let k=[];if(s<p.length)for(let g=p.length-1;g>0;g--){const T=Math.floor(this.random()*(g+1));[p[g],p[T]]=[p[T],p[g]]}const J=Math.max(1,Math.floor((y?3:s===1/0?50:s)/Math.pow(x,2))),U=Math.min(p.length,J);i&&Math.random()<.001&&i(`Pruning: Limit reduced to ${U} (Bias ${x.toFixed(1)})`);let P=0;for(let g=0;g<p.length&&!(P>=U);g++){const T=p[g],S=v.clone(),{deductions:E}=this.solver.applyClue(S,T);if(E===0||(P++,this.isPuzzleSolved(S,this.solution,this.reverseSolution)&&I<a))continue;let X=this.calculateClueScore(S,e,E,T,h.map(Y=>Y.clue),this.solution,this.reverseSolution);if(a){const Y=I/a,Q=(A.totalPossible-S.getGridStats().currentPossible)/(A.totalPossible-A.solutionPossible),$=Math.pow(Y,1.8),Z=Q-$;X-=Z*E*50}k.push({clue:T,deductions:E,score:X,grid:S,index:g})}let M=[],O,L;if(y){const g=y==="STALL";M=k.sort((T,S)=>{const E=T.deductions-S.deductions;return g?E:-E})}else k.sort((g,T)=>T.score-g.score),O=k[0];if(!y){if(L=k[0],a){const g=Math.pow(I/a,1.8);V>g?L=[...k].sort((S,E)=>S.deductions!==E.deductions?S.deductions-E.deductions:E.score-S.score)[0]:L=[...k].sort((S,E)=>S.deductions!==E.deductions?E.deductions-S.deductions:E.score-S.score)[0]}O&&M.push(O),L&&L!==O&&M.push(L);for(const g of k)g!==O&&g!==L&&M.push(g)}for(const g of M){const T=1+(Date.now()-c)/l*4;if(a&&h.length>4&&T>1.1&&!(!!y||g===O||g===L))break;const S=[...p];S.splice(g.index,1);const E=g===O,F=g===L&&g!==O;let X=y,Y="";if(!y&&F&&a){const $=V>I/a,Z=`(Prog ${V.toFixed(2)} vs Exp ${(I/a).toFixed(2)})`;X=$?"STALL":"SPEED",Y=$?`(Stalling - Weakest) ${Z}`:`(Speeding - Strongest) ${Z}`}else y&&(Y=`(Continued ${y})`);if(i&&(F||y||Math.random()<.05)){const $=y?`STICKY ${y}`:E?"Primary":F?"CORRECTION":"Rest";F?i(`[BACKTRACK] Depth ${h.length}: Primary Strategy Failed. Switching to ${Y}. Ded: ${g.deductions}`):y?Math.random()<.1&&i(`Depth ${h.length}: ${Math.round(V*100)}% Solved. Strategy: ${$}. Ded: ${g.deductions}`):i(`Depth ${h.length}: ${Math.round(V*100)}% Solved. Trying ${$} Cand. Ded: ${g.deductions}`)}const Q=u(g.grid,[...h,{clue:g.clue,deductions:g.deductions}],S,X);if(Q)return Q}return m++,null},b=u(d,[],[...r]);if(b)return{solution:this.solution,clues:b.map(h=>h.clue),proofChain:b,categories:t,targetFact:e};throw new _(`Could not generate puzzle with exactly ${a} clues within timeout.`)}createSolution(t,e,a,s){var l;const o=t[0];o.values.forEach(n=>{e.set(n,{[o.id]:n})});for(let n=1;n<t.length;n++){const i=t[n],r=[...i.values].sort(()=>this.random()-.5);let d=0;for(const m of o.values){const c=e.get(m);c&&(c[i.id]=r[d++])}}for(const n of t)a[n.id]={},s.set(n.id,new Map);for(const n of o.values){const i=e.get(n);if(i)for(const r in i)a[r][n]=i[r],(l=s.get(r))==null||l.set(i[r],n)}}generateAllPossibleClues(t,e,a,s){var n,i,r,d,m;const o=[];t[0];const l=c=>!(e!=null&&e.allowedClueTypes)||e.allowedClueTypes.includes(c);if(l(C.BINARY))for(const c of t)for(const u of c.values)for(const b of t){if(c.id>=b.id)continue;const v=(n=a.get(c.id))==null?void 0:n.get(u);if(!v)continue;const h=s.get(v);if(h)for(const p of b.values){const y=h[b.id];p===y?o.push({type:C.BINARY,operator:z.IS,cat1:c.id,val1:u,cat2:b.id,val2:p}):o.push({type:C.BINARY,operator:z.IS_NOT,cat1:c.id,val1:u,cat2:b.id,val2:p})}}for(const c of t.filter(u=>u.type===B.ORDINAL)){const u=[...c.values].sort((h,p)=>h-p),b=u[0],v=u[u.length-1];if(l(C.SUPERLATIVE)){for(const h of t)if(h.id!==c.id)for(const p of h.values){const y=(i=a.get(h.id))==null?void 0:i.get(p);if(!y)continue;const R=s.get(y);if(!R)continue;const N=R[c.id];N===b?o.push({type:C.SUPERLATIVE,operator:G.MIN,targetCat:h.id,targetVal:p,ordinalCat:c.id}):o.push({type:C.SUPERLATIVE,operator:G.NOT_MIN,targetCat:h.id,targetVal:p,ordinalCat:c.id}),N===v?o.push({type:C.SUPERLATIVE,operator:G.MAX,targetCat:h.id,targetVal:p,ordinalCat:c.id}):o.push({type:C.SUPERLATIVE,operator:G.NOT_MAX,targetCat:h.id,targetVal:p,ordinalCat:c.id})}}if(l(C.ORDINAL)){for(const h of t)if(h.id!==c.id){for(const p of t)if(p.id!==c.id)for(const y of h.values)for(const R of p.values){if(h.id===p.id&&y===R)continue;const N=(r=a.get(h.id))==null?void 0:r.get(y),x=(d=a.get(p.id))==null?void 0:d.get(R);if(!N||!x||N===x)continue;const w=s.get(N),A=s.get(x);if(!w||!A)continue;const V=w[c.id],I=A[c.id];V>I?(o.push({type:C.ORDINAL,operator:D.GREATER_THAN,item1Cat:h.id,item1Val:y,item2Cat:p.id,item2Val:R,ordinalCat:c.id}),o.push({type:C.ORDINAL,operator:D.NOT_LESS_THAN,item1Cat:h.id,item1Val:y,item2Cat:p.id,item2Val:R,ordinalCat:c.id})):V<I&&(o.push({type:C.ORDINAL,operator:D.LESS_THAN,item1Cat:h.id,item1Val:y,item2Cat:p.id,item2Val:R,ordinalCat:c.id}),o.push({type:C.ORDINAL,operator:D.NOT_GREATER_THAN,item1Cat:h.id,item1Val:y,item2Cat:p.id,item2Val:R,ordinalCat:c.id}))}}}}if(l(C.UNARY)){for(const c of t)if(c.type===B.ORDINAL&&c.values.every(u=>typeof u=="number")){for(const u of t)if(u.id!==c.id)for(const b of u.values){const v=(m=a.get(u.id))==null?void 0:m.get(b);if(!v)continue;const h=s.get(v);if(!h)continue;h[c.id]%2===0?o.push({type:C.UNARY,filter:W.IS_EVEN,targetCat:u.id,targetVal:b,ordinalCat:c.id}):o.push({type:C.UNARY,filter:W.IS_ODD,targetCat:u.id,targetVal:b,ordinalCat:c.id})}}}return o}calculateClueScore(t,e,a,s,o,l,n){var U;const i=s.type,r=(U=n.get(e.category1Id))==null?void 0:U.get(e.value1);let d;r!==void 0&&(d=l[e.category2Id][r]);const m=d!==void 0&&t.isPossible(e.category1Id,e.value1,e.category2Id,d)&&t.getPossibilitiesCount(e.category1Id,e.value1,e.category2Id)===1,c=this.isPuzzleSolved(t,l,n);if(s.type===C.BINARY&&s.operator===z.IS){const P=s;if(P.cat1===e.category1Id&&P.val1===e.value1&&P.cat2===e.category2Id&&P.val2===d||P.cat1===e.category2Id&&P.val1===d&&P.cat2===e.category1Id&&P.val2===e.value1)return-1/0}if(m&&c)return 1e6;if(m&&!c)return-1e6;const u=a,{totalPossible:b,currentPossible:v,solutionPossible:h}=t.getGridStats(),p=b-h,y=b-v,R=p>0?y/p:0;let N=0;switch(i){case C.ORDINAL:N=1.5,s.operator>=2&&(N=5);break;case C.SUPERLATIVE:N=1.2,s.operator>=2&&(N=5);break;case C.UNARY:N=1.2;break;case C.BINARY:N=1,s.operator===z.IS_NOT&&(N=5);break}let x=0;const w=P=>{const M=(g,T)=>{var S;return(S=this.reverseSolution.get(g))==null?void 0:S.get(T)};let O=[],L=[];switch(P.type){case C.BINARY:const g=P;O.push(M(g.cat1,g.val1)),g.operator===z.IS_NOT&&L.push(M(g.cat2,g.val2));break;case C.SUPERLATIVE:const T=P;O.push(M(T.targetCat,T.targetVal));break;case C.ORDINAL:const S=P;O.push(M(S.item1Cat,S.item1Val)),L.push(M(S.item2Cat,S.item2Val));break;case C.UNARY:const E=P;O.push(M(E.targetCat,E.targetVal));break}return{primary:O.filter(g=>!!g),secondary:L.filter(g=>!!g)}},A=new Set;for(const P of o){const{primary:M,secondary:O}=w(P);M.forEach(L=>A.add(L)),O.forEach(L=>A.add(L))}const{primary:V,secondary:I}=w(s);V.forEach(P=>{A.has(P)&&(x+=1)}),I.forEach(P=>{A.has(P)&&(x+=.5)});const k=s.ordinalCat;if(k)for(const P of o){const M=P.ordinalCat;k===M&&(x+=.5)}if(o.length>0){const P=o[o.length-1];if(s.type===P.type&&(x+=2,s.type===C.BINARY&&s.operator===z.IS&&P.operator===z.IS&&(x+=2)),o.length>1){const g=o[o.length-2];s.type===P.type&&s.type===g.type&&(x+=5)}const M=g=>{switch(g.type){case C.SUPERLATIVE:return 1;case C.BINARY:return g.operator===z.IS?1:3;case C.ORDINAL:return 3;case C.UNARY:return 3;case C.CROSS_ORDINAL:return 4;default:return 2}},O=M(s),L=M(P);O===L&&(x+=1.5)}const K=Math.pow(.4,x);return(u*N+R*5)*K}isPuzzleSolved(t,e,a){var o;const s=t.categories;s[0];for(const l of s)for(const n of l.values)for(const i of s){if(l.id>=i.id)continue;const r=(o=a.get(l.id))==null?void 0:o.get(n);if(!r)return!1;const d=e[i.id][r];if(t.getPossibilitiesCount(l.id,n,i.id)>1||!t.isPossible(l.id,n,i.id,d))return!1}return!0}}const q=self;q.onmessage=f=>{const{type:t}=f.data;if(t==="start"){const{categories:e,targetFact:a,options:s}=f.data;s&&s.targetClueCount&&(s.targetClueCount=parseInt(String(s.targetClueCount),10));try{const o=new j(s==null?void 0:s.seed),l={...s,onTrace:i=>{q.postMessage({type:"trace",message:i})}};let n;try{n=o.generatePuzzle(e,a,l)}catch(i){if(s.targetClueCount&&i.message&&i.message.includes("Could not generate puzzle")){q.postMessage({type:"trace",message:`⚠️ Strict generation failed (${i.message}). Falling back to best-effort generation...`});const r={...l,targetClueCount:void 0};n=o.generatePuzzle(e,a,r)}else throw i}q.postMessage({type:"done",puzzle:n})}catch(o){console.error("Worker Generation Error:",o),q.postMessage({type:"error",message:o.message||"Unknown worker error"})}}}})();
