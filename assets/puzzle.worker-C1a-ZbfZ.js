(function(){"use strict";var H=(m=>(m[m.NOMINAL=0]="NOMINAL",m[m.ORDINAL=1]="ORDINAL",m))(H||{}),h=(m=>(m[m.BINARY=0]="BINARY",m[m.ORDINAL=1]="ORDINAL",m[m.SUPERLATIVE=2]="SUPERLATIVE",m[m.UNARY=3]="UNARY",m[m.CROSS_ORDINAL=4]="CROSS_ORDINAL",m[m.BETWEEN=5]="BETWEEN",m[m.ADJACENCY=6]="ADJACENCY",m[m.OR=7]="OR",m[m.ARITHMETIC=8]="ARITHMETIC",m))(h||{}),et=(m=>(m[m.MATCH=0]="MATCH",m[m.NOT_MATCH=1]="NOT_MATCH",m))(et||{}),z=(m=>(m[m.IS=0]="IS",m[m.IS_NOT=1]="IS_NOT",m))(z||{}),_=(m=>(m[m.GREATER_THAN=0]="GREATER_THAN",m[m.LESS_THAN=1]="LESS_THAN",m[m.NOT_GREATER_THAN=2]="NOT_GREATER_THAN",m[m.NOT_LESS_THAN=3]="NOT_LESS_THAN",m))(_||{}),Y=(m=>(m[m.MIN=0]="MIN",m[m.MAX=1]="MAX",m[m.NOT_MIN=2]="NOT_MIN",m[m.NOT_MAX=3]="NOT_MAX",m))(Y||{}),K=(m=>(m[m.IS_ODD=0]="IS_ODD",m[m.IS_EVEN=1]="IS_EVEN",m))(K||{});class st extends Error{constructor(e){super(e),this.name="LogicPuzzleError"}}class G extends st{constructor(e){super(e),this.name="ConfigurationError"}}class J{constructor(e){this.validateConfig(e),this.categories=e,this.valueMap=new Map(e.map(t=>[t.id,new Map(t.values.map((a,s)=>[a,s]))])),this.grid=new Map;for(const t of e){const a=new Map;for(const s of t.values){const n=new Map;for(const o of e)t.id!==o.id&&n.set(o.id,Array(o.values.length).fill(!0));a.set(s,n)}this.grid.set(t.id,a)}}validateConfig(e){const t=new Set;let a=-1;for(const s of e){if(t.has(s.id))throw new G(`Duplicate category ID found: ${s.id}`);if(t.add(s.id),new Set(s.values).size!==s.values.length)throw new G(`Category '${s.id}' has duplicate values.`);if(a===-1)a=s.values.length;else if(s.values.length!==a)throw new G(`Category '${s.id}' has ${s.values.length} values, expected ${a}. All categories must be the same size.`)}}setPossibility(e,t,a,s,n){var l,i;const o=(l=this.valueMap.get(a))==null?void 0:l.get(s);if(o!==void 0){const c=this.grid.get(e);if(c){const d=c.get(t);if(d){const f=d.get(a);f&&(f[o]=n)}}}const r=(i=this.valueMap.get(e))==null?void 0:i.get(t);if(r!==void 0){const c=this.grid.get(a);if(c){const d=c.get(s);if(d){const f=d.get(e);f&&(f[r]=n)}}}}isPossible(e,t,a,s){var i;if(e===a)return t===s;const n=(i=this.valueMap.get(a))==null?void 0:i.get(s);if(n===void 0)return!1;const o=this.grid.get(e);if(!o)return!1;const r=o.get(t);if(!r)return!1;const l=r.get(a);return l?l[n]:!1}getPossibilitiesCount(e,t,a){var n,o;const s=(o=(n=this.grid.get(e))==null?void 0:n.get(t))==null?void 0:o.get(a);return s?s.filter(r=>r).length:0}getGridStats(){var r,l,i;let e=0;const t=this.categories.length,a=((r=this.categories[0])==null?void 0:r.values.length)||0;if(a===0||t<2)return{totalPossible:0,currentPossible:0,solutionPossible:0};const s=t*(t-1)/2,n=s*a*a,o=s*a;for(const c of this.categories)for(const d of c.values)for(const f of this.categories){if(c.id>=f.id)continue;const V=(i=(l=this.grid.get(c.id))==null?void 0:l.get(d))==null?void 0:i.get(f.id);V&&(e+=V.filter(C=>C).length)}return{totalPossible:n,currentPossible:e,solutionPossible:o}}clone(){const e=new J(this.categories);return e.grid=new Map([...this.grid.entries()].map(([t,a])=>[t,new Map([...a.entries()].map(([s,n])=>[s,new Map([...n.entries()].map(([o,r])=>[o,[...r]]))]))])),e}compareVisualState(e){var s,n;let t=0;const a=this.categories;for(const o of a)for(const r of o.values)for(const l of a){if(o.id>=l.id)continue;const i=(s=this.grid.get(o.id))==null?void 0:s.get(r),c=(n=e.grid.get(o.id))==null?void 0:n.get(r);if(i&&c){const V=i.get(l.id),C=c.get(l.id);if(V&&C)for(let x=0;x<V.length;x++)C[x]&&!V[x]&&t++}const d=e.getPossibilitiesCount(o.id,r,l.id),f=this.getPossibilitiesCount(o.id,r,l.id);d>1&&f===1&&t++}return t}isValid(){for(const[e,t]of this.grid)for(const[a,s]of t)for(const[n,o]of s){let r=!1;for(let l=0;l<o.length;l++)if(o[l]){r=!0;break}if(!r)return!1}return!0}}class tt{applyClue(e,t){let a=0;const s=[];switch(t.type){case h.BINARY:a+=this.applyBinaryClue(e,t,s);break;case h.SUPERLATIVE:a+=this.applySuperlativeClue(e,t,s);break;case h.ORDINAL:a+=this.applyOrdinalClue(e,t,s);break;case h.UNARY:a+=this.applyUnaryClue(e,t,s);break;case h.CROSS_ORDINAL:case h.CROSS_ORDINAL:a+=this.applyCrossOrdinalClue(e,t,s);break;case h.BETWEEN:a+=this.applyBetweenClue(e,t,s);break;case h.ADJACENCY:a+=this.applyAdjacencyClue(e,t,s);break;case h.OR:a+=this.applyDisjunctionClue(e,t,s);break;case h.ARITHMETIC:a+=this.applyArithmeticClue(e,t,s);break}let n;do n=this.runDeductionLoop(e,s),a+=n;while(n>0);return{grid:e,deductions:a,reasons:s}}applyCrossOrdinalClue(e,t,a){let s=0;const n=e.categories,o=n.find(f=>f.id===t.ordinal1),r=n.find(f=>f.id===t.ordinal2);if(!o||!r)return 0;const l=t.operator===et.NOT_MATCH,i=(f,V,C,x)=>x.values.map((v,T)=>({val:v,idx:T})).filter(v=>e.isPossible(f,V,C,v.val)),c=i(t.item1Cat,t.item1Val,t.ordinal1,o),d=i(t.item2Cat,t.item2Val,t.ordinal2,r);if(l){if(c.length===1&&d.length===1){const f=c[0].idx+t.offset1,V=d[0].idx+t.offset2,C=o.values[f],x=r.values[V];C!==void 0&&x!==void 0&&e.isPossible(t.ordinal1,C,t.ordinal2,x)&&(e.setPossibility(t.ordinal1,C,t.ordinal2,x,!1),s++,a.push({type:"cross_ordinal",description:`Cross-Ordinal NOT: ${C} cannot be ${x} because positions are forbidden.`,cells:[{cat:t.ordinal1,val:C},{cat:t.ordinal2,val:x}]}))}for(const f of c){const V=f.idx+t.offset1;if(o.values[V]!==void 0)for(const x of d){const v=x.idx+t.offset2;r.values[v]}}if(c.length===1){const f=c[0].idx+t.offset1,V=o.values[f];if(V!==void 0)for(const C of d){const x=C.idx+t.offset2,v=r.values[x];v!==void 0&&e.isPossible(t.ordinal1,V,t.ordinal2,v)&&(e.setPossibility(t.item2Cat,t.item2Val,t.ordinal2,C.val,!1),s++,a.push({type:"cross_ordinal",description:`Cross-Ordinal NOT: ${t.item2Val} cannot be ${C.val} because it implies forbidden link to ${V}.`,cells:[{cat:t.item2Cat,val:t.item2Val},{cat:t.ordinal2,val:C.val}]}))}}if(d.length===1){const f=d[0].idx+t.offset2,V=r.values[f];if(V!==void 0)for(const C of c){const x=C.idx+t.offset1,v=o.values[x];v!==void 0&&e.isPossible(t.ordinal1,v,t.ordinal2,V)&&(e.setPossibility(t.item1Cat,t.item1Val,t.ordinal1,C.val,!1),s++,a.push({type:"cross_ordinal",description:`Cross-Ordinal NOT: ${t.item1Val} cannot be ${C.val} because it implies forbidden link to ${V}.`,cells:[{cat:t.item1Cat,val:t.item1Val},{cat:t.ordinal1,val:C.val}]}))}}}else{for(const C of c){const x=C.idx+t.offset1,v=o.values[x];if(v===void 0){e.setPossibility(t.item1Cat,t.item1Val,t.ordinal1,C.val,!1),s++,a.push({type:"cross_ordinal",description:`Cross-Ordinal: ${t.item1Val} cannot be ${C.val} because offset ${t.offset1} goes out of bounds.`,cells:[{cat:t.item1Cat,val:t.item1Val},{cat:t.ordinal1,val:C.val}]});continue}let T=!1;for(const u of d){const y=u.idx+t.offset2,b=r.values[y];if(b!==void 0&&e.isPossible(t.ordinal1,v,t.ordinal2,b)){T=!0;break}}T||(e.setPossibility(t.item1Cat,t.item1Val,t.ordinal1,C.val,!1),s++,a.push({type:"cross_ordinal",description:`Cross-Ordinal: ${t.item1Val} as ${C.val} finds no compatible ${t.item2Val} at offset pair.`,cells:[{cat:t.item1Cat,val:t.item1Val},{cat:t.ordinal1,val:C.val}]}))}for(const C of d){const x=C.idx+t.offset2,v=r.values[x];if(v===void 0){e.setPossibility(t.item2Cat,t.item2Val,t.ordinal2,C.val,!1),s++,a.push({type:"cross_ordinal",description:`Cross-Ordinal: ${t.item2Val} cannot be ${C.val} because offset ${t.offset2} goes out of bounds.`,cells:[{cat:t.item2Cat,val:t.item2Val},{cat:t.ordinal1,val:C.val}]});continue}let T=!1;for(const u of c){const y=u.idx+t.offset1,b=o.values[y];if(b!==void 0&&e.isPossible(t.ordinal1,b,t.ordinal2,v)){T=!0;break}}T||(e.setPossibility(t.item2Cat,t.item2Val,t.ordinal2,C.val,!1),s++,a.push({type:"cross_ordinal",description:`Cross-Ordinal: ${t.item2Val} as ${C.val} finds no compatible ${t.item1Val} at offset pair.`,cells:[{cat:t.item2Cat,val:t.item2Val},{cat:t.ordinal2,val:C.val}]}))}const f=i(t.item1Cat,t.item1Val,t.ordinal1,o),V=i(t.item2Cat,t.item2Val,t.ordinal2,r);if(f.length===1&&V.length===1){const C=f[0].idx+t.offset1,x=V[0].idx+t.offset2,v=o.values[C],T=r.values[x];v!==void 0&&T!==void 0&&e.getPossibilitiesCount(t.ordinal1,v,t.ordinal2)>1&&(e.setPossibility(t.ordinal1,v,t.ordinal2,T,!0),s++,a.push({type:"cross_ordinal",description:`Cross-Ordinal Link: ${v} must be ${T} based on forced offsets.`,cells:[{cat:t.ordinal1,val:v},{cat:t.ordinal2,val:T}]}))}}return s}applyUnaryClue(e,t,a){let s=0;const o=e.categories.find(l=>l.id===t.ordinalCat);if(!o||o.type!==H.ORDINAL||!o.values.every(l=>typeof l=="number"))return 0;const r=t.filter===K.IS_EVEN;for(const l of o.values){const i=l;(r?i%2!==0:i%2===0)&&e.isPossible(t.targetCat,t.targetVal,t.ordinalCat,l)&&(e.setPossibility(t.targetCat,t.targetVal,t.ordinalCat,l,!1),s++,a.push({type:"unary",description:`Unary Rule: ${l} eliminated for ${t.targetVal} because it is ${r?"not even":"not odd"}.`,cells:[{cat:t.targetCat,val:t.targetVal},{cat:t.ordinalCat,val:String(l)}]}))}return s}applyAdjacencyClue(e,t,a){let s=0;const o=e.categories.find(d=>d.id===t.ordinalCat);if(!o||o.type!==H.ORDINAL)return 0;const r=o.values,l=new Map;r.forEach((d,f)=>l.set(d,f));const i=d=>{const f=l.get(d);if(f===void 0)return[];const V=[];return f>0&&V.push(r[f-1]),f<r.length-1&&V.push(r[f+1]),V},c=(d,f,V,C,x)=>{let v=0;for(const T of r)e.isPossible(d,f,t.ordinalCat,T)&&(i(T).some(b=>e.isPossible(V,C,t.ordinalCat,b))||(e.setPossibility(d,f,t.ordinalCat,T,!1),v++,a.push({type:"ordinal",description:`Adjacency: ${T} eliminated for ${f} because it represents ${x}, and no valid adjacent value exists for ${C}.`,cells:[{cat:d,val:f},{cat:t.ordinalCat,val:String(T)}]})));return v};return s+=c(t.item1Cat,t.item1Val,t.item2Cat,t.item2Val,"Item 1"),s+=c(t.item2Cat,t.item2Val,t.item1Cat,t.item1Val,"Item 2"),s}applyBetweenClue(e,t,a){let s=0;const n={type:h.ORDINAL,operator:_.GREATER_THAN,item1Cat:t.targetCat,item1Val:t.targetVal,item2Cat:t.lowerCat,item2Val:t.lowerVal,ordinalCat:t.ordinalCat},o={type:h.ORDINAL,operator:_.GREATER_THAN,item1Cat:t.upperCat,item1Val:t.upperVal,item2Cat:t.targetCat,item2Val:t.targetVal,ordinalCat:t.ordinalCat};let r=0;do{r=0;const l=this.applyOrdinalClue(e,n,a),i=this.applyOrdinalClue(e,o,a);r=l+i,s+=r}while(r>0);return s}applyBinaryClue(e,t,a){let s=0;const n=e.categories,o=n.find(l=>l.id===t.cat1),r=n.find(l=>l.id===t.cat2);if(!o||!r)return 0;if(t.operator===z.IS){e.getPossibilitiesCount(t.cat1,t.val1,t.cat2)>1&&(s++,a.push({type:"confirmation",description:`Directly from clue: ${t.val1} is ${t.val2}.`,cells:[{cat:t.cat1,val:t.val1},{cat:t.cat2,val:t.val2}]})),e.isPossible(t.cat1,t.val1,t.cat2,t.val2);for(const l of r.values)l!==t.val2&&e.isPossible(t.cat1,t.val1,t.cat2,l)&&(e.setPossibility(t.cat1,t.val1,t.cat2,l,!1),s++,a.push({type:"elimination",description:`Since ${t.val1} is ${t.val2}, it cannot be ${l}.`,cells:[{cat:t.cat1,val:t.val1},{cat:t.cat2,val:l}]}));for(const l of o.values)l!==t.val1&&e.isPossible(t.cat1,l,t.cat2,t.val2)&&(e.setPossibility(t.cat1,l,t.cat2,t.val2,!1),s++,a.push({type:"elimination",description:`Since ${t.val2} is ${t.val1}, it cannot be ${l}.`,cells:[{cat:t.cat1,val:l},{cat:t.cat2,val:t.val2}]}))}else e.isPossible(t.cat1,t.val1,t.cat2,t.val2)&&(e.setPossibility(t.cat1,t.val1,t.cat2,t.val2,!1),s++,a.push({type:"elimination",description:`Directly from clue: ${t.val1} is NOT ${t.val2}.`,cells:[{cat:t.cat1,val:t.val1},{cat:t.cat2,val:t.val2}]}));return s}runDeductionLoop(e,t){let a=0;const s=e.categories;for(const n of s)for(const o of n.values)for(const r of s){if(n.id===r.id)continue;const l=r.values.filter(i=>e.isPossible(n.id,o,r.id,i));if(l.length===1){const i=l[0];for(const c of n.values)c!==o&&e.isPossible(n.id,c,r.id,i)&&(e.setPossibility(n.id,c,r.id,i,!1),a++,t.push({type:"uniqueness",description:`Since ${i} is uniquely ${o} in ${n.id}, it cannot be ${c}.`,cells:[{cat:n.id,val:o},{cat:r.id,val:i},{cat:n.id,val:c}]}))}for(const i of s){if(n.id===i.id||r.id===i.id)continue;const c=l.length===1?l[0]:null;if(c){const d=i.values.filter(f=>e.isPossible(r.id,c,i.id,f));if(d.length===1){const f=d[0];e.isPossible(n.id,o,i.id,f)===!1||e.getPossibilitiesCount(n.id,o,i.id)>1&&(e.setPossibility(n.id,o,i.id,f,!0),a++,t.push({type:"transitivity",description:`Since ${n.id}:${o} is ${r.id}:${c}, and that is ${i.id}:${f}, ${o} must be ${f}.`,cells:[{cat:n.id,val:o},{cat:r.id,val:c},{cat:i.id,val:f}]}))}}for(const d of i.values)e.isPossible(n.id,o,i.id,d)&&(r.values.some(V=>e.isPossible(n.id,o,r.id,V)&&e.isPossible(r.id,V,i.id,d))||(e.setPossibility(n.id,o,i.id,d,!1),a++,t.push({type:"transitivity",description:`Negative Transitivity: No path exists between ${o} and ${d} via ${r.id}.`,cells:[{cat:n.id,val:o},{cat:i.id,val:d}]})))}}return a}applyOrdinalClue(e,t,a){let s=0;const o=e.categories.find(i=>i.id===t.ordinalCat);if(!o||o.type!==H.ORDINAL)return 0;const r=o.values.map((i,c)=>({val:i,idx:c})).filter(i=>e.isPossible(t.item1Cat,t.item1Val,t.ordinalCat,i.val)),l=o.values.map((i,c)=>({val:i,idx:c})).filter(i=>e.isPossible(t.item2Cat,t.item2Val,t.ordinalCat,i.val));if(r.length===0||l.length===0)return 0;if(t.operator===_.GREATER_THAN)for(const i of r)l.some(d=>i.idx>d.idx)||e.isPossible(t.item1Cat,t.item1Val,t.ordinalCat,i.val)&&(e.setPossibility(t.item1Cat,t.item1Val,t.ordinalCat,i.val,!1),s++,a.push({type:"ordinal",description:`${t.item1Val} cannot be ${i.val} (idx ${i.idx}) because it must be > ${t.item2Val}.`,cells:[{cat:t.item1Cat,val:t.item1Val},{cat:t.ordinalCat,val:i.val}]}));else if(t.operator===_.LESS_THAN)for(const i of r)l.some(d=>i.idx<d.idx)||e.isPossible(t.item1Cat,t.item1Val,t.ordinalCat,i.val)&&(e.setPossibility(t.item1Cat,t.item1Val,t.ordinalCat,i.val,!1),s++,a.push({type:"ordinal",description:`${t.item1Val} cannot be ${i.val} (idx ${i.idx}) because it must be < ${t.item2Val}.`,cells:[{cat:t.item1Cat,val:t.item1Val},{cat:t.ordinalCat,val:i.val}]}));else if(t.operator===_.NOT_GREATER_THAN)for(const i of r)l.some(d=>i.idx<=d.idx)||e.isPossible(t.item1Cat,t.item1Val,t.ordinalCat,i.val)&&(e.setPossibility(t.item1Cat,t.item1Val,t.ordinalCat,i.val,!1),s++,a.push({type:"ordinal",description:`${t.item1Val} cannot be ${i.val} (idx ${i.idx}) because it must be <= ${t.item2Val}.`,cells:[{cat:t.item1Cat,val:t.item1Val},{cat:t.ordinalCat,val:i.val}]}));else if(t.operator===_.NOT_LESS_THAN)for(const i of r)l.some(d=>i.idx>=d.idx)||e.isPossible(t.item1Cat,t.item1Val,t.ordinalCat,i.val)&&(e.setPossibility(t.item1Cat,t.item1Val,t.ordinalCat,i.val,!1),s++,a.push({type:"ordinal",description:`${t.item1Val} cannot be ${i.val} (idx ${i.idx}) because it must be >= ${t.item2Val}.`,cells:[{cat:t.item1Cat,val:t.item1Val},{cat:t.ordinalCat,val:i.val}]}));if(t.operator===_.GREATER_THAN)for(const i of l)r.some(d=>i.idx<d.idx)||e.isPossible(t.item2Cat,t.item2Val,t.ordinalCat,i.val)&&(e.setPossibility(t.item2Cat,t.item2Val,t.ordinalCat,i.val,!1),s++,a.push({type:"ordinal",description:`${t.item2Val} cannot be ${i.val} (idx ${i.idx}) because it must be < ${t.item1Val}.`,cells:[{cat:t.item2Cat,val:t.item2Val},{cat:t.ordinalCat,val:i.val}]}));else if(t.operator===_.LESS_THAN)for(const i of l)r.some(d=>i.idx>d.idx)||e.isPossible(t.item2Cat,t.item2Val,t.ordinalCat,i.val)&&(e.setPossibility(t.item2Cat,t.item2Val,t.ordinalCat,i.val,!1),s++,a.push({type:"ordinal",description:`${t.item2Val} cannot be ${i.val} (idx ${i.idx}) because it must be > ${t.item1Val}.`,cells:[{cat:t.item2Cat,val:t.item2Val},{cat:t.ordinalCat,val:i.val}]}));else if(t.operator===_.NOT_GREATER_THAN)for(const i of l)r.some(d=>i.idx>=d.idx)||e.isPossible(t.item2Cat,t.item2Val,t.ordinalCat,i.val)&&(e.setPossibility(t.item2Cat,t.item2Val,t.ordinalCat,i.val,!1),s++,a.push({type:"ordinal",description:`${t.item2Val} cannot be ${i.val} (idx ${i.idx}) because it must be >= ${t.item1Val}.`,cells:[{cat:t.item2Cat,val:t.item2Val},{cat:t.ordinalCat,val:i.val}]}));else if(t.operator===_.NOT_LESS_THAN)for(const i of l)r.some(d=>i.idx<=d.idx)||e.isPossible(t.item2Cat,t.item2Val,t.ordinalCat,i.val)&&(e.setPossibility(t.item2Cat,t.item2Val,t.ordinalCat,i.val,!1),s++,a.push({type:"ordinal",description:`${t.item2Val} cannot be ${i.val} (idx ${i.idx}) because it must be <= ${t.item1Val}.`,cells:[{cat:t.item2Cat,val:t.item2Val},{cat:t.ordinalCat,val:i.val}]}));return s}applySuperlativeClue(e,t,a){const n=e.categories.find(i=>i.id===t.ordinalCat);if(!n||n.type!==H.ORDINAL)return 0;let o,r=!1;switch(t.operator){case Y.MAX:o=n.values[n.values.length-1];break;case Y.MIN:o=n.values[0];break;case Y.NOT_MAX:o=n.values[n.values.length-1],r=!0;break;case Y.NOT_MIN:o=n.values[0],r=!0;break;default:return 0}const l={type:h.BINARY,cat1:t.targetCat,val1:t.targetVal,cat2:t.ordinalCat,val2:o,operator:r?z.IS_NOT:z.IS};return this.applyBinaryClue(e,l,a)}applyDisjunctionClue(e,t,a){const s=this.isClueContradicted(e,t.clue1),n=this.isClueContradicted(e,t.clue2);if(s&&n)return 0;if(s){a.push({type:"disjunction",description:"Disjunction Resolved: First option is impossible, so the second option must be true."});const o=this.applyClue(e,t.clue2);return a.push(...o.reasons),o.deductions}if(n){a.push({type:"disjunction",description:"Disjunction Resolved: Second option is impossible, so the first option must be true."});const o=this.applyClue(e,t.clue1);return a.push(...o.reasons),o.deductions}return 0}isClueContradicted(e,t){const a=e.clone();return this.applyClue(a,t),!a.isValid()}applyArithmeticClue(e,t,a){let s=0;const o=e.categories.find(b=>b.id===t.ordinalCat);if(!o||o.type!==H.ORDINAL)return 0;const r=o.values,l=(b,S)=>r.filter(g=>e.isPossible(b,S,t.ordinalCat,g)),i=l(t.item1Cat,t.item1Val),c=l(t.item2Cat,t.item2Val),d=l(t.item3Cat,t.item3Val),f=l(t.item4Cat,t.item4Val),V=new Set,C=new Set,x=new Set,v=new Set,T=new Map;for(const b of i)for(const S of c){const g=Math.abs(b-S);T.has(g)||T.set(g,[]),T.get(g).push({v1:b,v2:S})}const u=new Map;for(const b of d)for(const S of f){const g=Math.abs(b-S);u.has(g)||u.set(g,[]),u.get(g).push({v3:b,v4:S})}for(const[b,S]of T.entries()){const g=u.get(b);g&&(S.forEach(p=>{V.add(p.v1),C.add(p.v2)}),g.forEach(p=>{x.add(p.v3),v.add(p.v4)}))}const y=(b,S,g,p)=>{let A=0;for(const I of p)g.has(I)||e.isPossible(b,S,t.ordinalCat,I)&&(e.setPossibility(b,S,t.ordinalCat,I,!1),A++);return A>0&&a.push({type:"clue",description:`Arithmetic Constraint: Value ${S} in ${b} restricted to [${Array.from(g).join(", ")}] to satisfy equal difference.`,cells:[{cat:b,val:S}]}),A};return s+=y(t.item1Cat,t.item1Val,V,i),s+=y(t.item2Cat,t.item2Val,C,c),s+=y(t.item3Cat,t.item3Val,x,d),s+=y(t.item4Cat,t.item4Val,v,f),s}}class at{constructor(e,t,a,s,n,o){this.generator=e,this.categories=t,this.solution=a,this.reverseSolution=s,this.valueMap=n,this.targetFact=o,this.availableClues=[],this.proofChain=[],this.targetSolvedStepIndex=-1,this.historyStack=[],this.grid=new J(t),this.solver=new tt,this.checkTargetSolved(),this.availableClues=this.generator.generateAllPossibleClues(t,void 0,s,n)}getTotalClueCount(){return this.availableClues.length}getTargetSolvedStepIndex(){return this.targetSolvedStepIndex}getMatchingClueCount(e){return this.filterClues(e).length}getMatchingClues(e,t=50){return this.filterClues(e).slice(0,t)}getScoredMatchingClues(e,t=50){const a=this.filterClues(e),s=[],n=(e==null?void 0:e.minDeductions)??0,o=e==null?void 0:e.maxDeductions;if(o!==void 0&&n>o)throw new G(`Invalid constraints: minDeductions (${n}) cannot be greater than maxDeductions (${o}).`);for(const r of a){const l=this.grid.clone(),{deductions:i}=this.solver.applyClue(l,r);if(i<n||o!==void 0&&i>o)continue;const c=this.generator.calculateClueScore(this.grid,this.targetFact,i,r,this.proofChain,this.solution,this.reverseSolution);let d=!1;if(r.type===h.BINARY&&r.operator===z.IS){const u=r,y=u.cat1===this.targetFact.category1Id&&u.val1===this.targetFact.value1&&u.cat2===this.targetFact.category2Id,b=u.cat2===this.targetFact.category1Id&&u.val2===this.targetFact.value1&&u.cat1===this.targetFact.category2Id;(y||b)&&(d=!0)}const f=l.getGridStats(),V=f.totalPossible-f.solutionPossible,C=f.totalPossible-f.currentPossible;let x=0;V>0?x=Math.min(100,Math.max(0,C/V*100)):x=100;const v=l.compareVisualState(this.grid);s.push({clue:r,score:c,deductions:i,updates:v,isDirectAnswer:d,percentComplete:x})}return s.sort((r,l)=>l.score-r.score).slice(0,t)}useClue(e){if(!this.generator.checkClueConsistency(e,this.solution,this.reverseSolution,this.valueMap,this.categories))throw new Error("Invalid Clue: This clue contradicts the puzzle solution.");return this.applyAndSave(e),{remaining:this.availableClues.length,solved:this.generator.isPuzzleSolved(this.grid,this.solution,this.reverseSolution)}}filterClues(e){return this.availableClues.filter(t=>{if(e!=null&&e.allowedClueTypes&&!e.allowedClueTypes.includes(t.type))return!1;if(e!=null&&e.includeSubjects&&(e!=null&&e.excludeSubjects)){const a=e.includeSubjects.filter(s=>e.excludeSubjects.includes(s));if(a.length>0)throw new Error(`Constraint Error: The following subjects are both included and excluded: ${a.join(", ")}`)}if(e!=null&&e.includeSubjects||e!=null&&e.excludeSubjects){const a=this.extractValuesFromClue(t);if(e.includeSubjects&&!e.includeSubjects.some(n=>a.includes(n))||e.excludeSubjects&&e.excludeSubjects.some(n=>a.includes(n)))return!1}return!0})}applyAndSave(e){this.historyStack.push(this.grid.clone());const t=this.solver.applyClue(this.grid,e);e.deductions=t.deductions,e.reasons=t.reasons;const a=this.grid.getGridStats(),s=a.totalPossible-a.solutionPossible,n=a.totalPossible-a.currentPossible;s>0?e.percentComplete=Math.min(100,Math.max(0,n/s*100)):e.percentComplete=100;const o=this.historyStack[this.historyStack.length-1];o?e.updates=this.grid.compareVisualState(o):e.updates=e.deductions,this.proofChain.push(e),this.targetSolvedStepIndex===-1&&this.checkTargetSolvedInternal()&&(this.targetSolvedStepIndex=this.proofChain.length-1);const r=this.availableClues.indexOf(e);r>-1&&this.availableClues.splice(r,1)}checkTargetSolvedInternal(){return this.grid.getPossibilitiesCount(this.targetFact.category1Id,this.targetFact.value1,this.targetFact.category2Id)===1}checkTargetSolved(){this.checkTargetSolvedInternal()}getNextClue(e){const t=this.filterClues(e);let a=null,s=-1/0;const n=[...t].sort(()=>Math.random()-.5),o=50;let r=0;const l=(e==null?void 0:e.minDeductions)??0,i=e==null?void 0:e.maxDeductions;if(i!==void 0&&l>i)throw new G(`Invalid constraints: minDeductions (${l}) cannot be greater than maxDeductions (${i}).`);for(const c of n){if(r++,r>o&&a)break;const d=this.grid.clone(),{deductions:f}=this.solver.applyClue(d,c);if(f<l||i!==void 0&&f>i)continue;const V=this.generator.calculateClueScore(this.grid,this.targetFact,f,c,this.proofChain,this.solution,this.reverseSolution),C=d.getGridStats();C.totalPossible-C.solutionPossible,C.totalPossible-C.currentPossible,V>s&&(s=V,a=c)}return a?(this.applyAndSave(a),{clue:a,remaining:this.availableClues.length,solved:this.generator.isPuzzleSolved(this.grid,this.solution,this.reverseSolution)}):{clue:null,remaining:t.length,solved:this.generator.isPuzzleSolved(this.grid,this.solution,this.reverseSolution)}}async getNextClueAsync(e){return new Promise((t,a)=>{setTimeout(()=>{try{const s=this.getNextClue(e);t(s)}catch(s){a(s)}},0)})}rollbackLastClue(){if(this.historyStack.length===0)return{success:!1,clue:null};const e=this.historyStack.pop();e&&(this.grid=e);const t=this.proofChain.pop();return t?(this.availableClues.push(t),{success:!0,clue:t}):{success:!1,clue:null}}isUseful(e){return!0}removeClueAt(e){if(e<0||e>=this.proofChain.length)return!1;const t=this.proofChain[e];return this.proofChain.splice(e,1),this.availableClues.push(t),this.replayProofChain()}moveClue(e,t){if(e<0||e>=this.proofChain.length||t<0||t>=this.proofChain.length)return!1;if(e===t)return!0;const a=this.proofChain[e];return this.proofChain.splice(e,1),this.proofChain.splice(t,0,a),this.replayProofChain()}replayProofChain(){this.grid=new J(this.categories),this.historyStack=[],this.solver=new tt,this.targetSolvedStepIndex=-1,this.checkTargetSolvedInternal(),this.availableClues.push(...this.proofChain);const e=[...this.proofChain];this.proofChain=[];for(const t of e)this.applyAndSave(t);return!0}getGrid(){return this.grid}getProofChain(){return this.proofChain}getSolution(){return this.solution}getValueMap(){return this.valueMap}extractValuesFromClue(e){const t=[],a=s=>{s!==void 0&&t.push(String(s))};return a(e.val1),a(e.val2),a(e.item1Val),a(e.item2Val),a(e.targetVal),t}}const it={"2x3":{min:2,max:2},"2x4":{min:3,max:10},"2x5":{min:4,max:17},"2x6":{min:5,max:26},"2x7":{min:6,max:37},"2x8":{min:7,max:50},"2x9":{min:8,max:65},"2x10":{min:9,max:82},"3x3":{min:3,max:9},"3x4":{min:5,max:26},"3x5":{min:7,max:47},"3x6":{min:9,max:72},"3x7":{min:11,max:100},"3x8":{min:13,max:130},"3x9":{min:15,max:160},"3x10":{min:17,max:200},"4x3":{min:5,max:16},"4x4":{min:8,max:44},"4x5":{min:11,max:87},"4x6":{min:14,max:140},"4x7":{min:17,max:200},"4x8":{min:20,max:260},"4x9":{min:23,max:330},"4x10":{min:26,max:400},"5x3":{min:7,max:25},"5x4":{min:11,max:70},"5x5":{min:15,max:130},"5x6":{min:19,max:200},"5x7":{min:23,max:280},"5x8":{min:27,max:370},"5x9":{min:31,max:470},"5x10":{min:35,max:580}},ot=(m,e)=>{const t=`${m}x${e}`;if(it[t])return it[t];const a=(m-1)*e,s=Math.max(5,Math.floor(a*.7)),n=Math.floor(a*5);return{min:s,max:n}};function nt(m){return function(){m|=0,m=m+1831565813|0;var e=Math.imul(m^m>>>15,1|m);return e=e+Math.imul(e^e>>>7,61|e)^e,((e^e>>>14)>>>0)/4294967296}}class Z{constructor(e){this.solution={},this.valueMap=new Map,this.reverseSolution=new Map,this.seed=e,this.random=nt(e),this.solver=new tt}getClueCountBounds(e,t,a=10){let s=1/0,n=0;for(let o=0;o<a;o++){const r=this.seed+o+1,l=new Z(r);try{const i=l.internalGenerate(e,t,"min");i&&(s=Math.min(s,i.clues.length))}catch{}try{const c=new Z(r).internalGenerate(e,t,"max");c&&(n=Math.max(n,c.clues.length))}catch{}}return s===1/0&&(s=0),{min:s,max:n}}generatePuzzle(e,t,a={}){if(e.length<2)throw new G("Puzzle must have at least 2 categories.");const{targetClueCount:s,maxCandidates:n=50,timeoutMs:o=1e4}=a,r=t||this.generateRandomTarget(e);this.validateTarget(e,r);const l=a.constraints;if(l!=null&&l.allowedClueTypes){const i=l.allowedClueTypes,c=e.some(V=>V.type===H.ORDINAL),d=i.includes(h.ORDINAL),f=i.includes(h.CROSS_ORDINAL);if(d&&!c&&!i.includes(h.BINARY))throw new G("Invalid Constraints: Ordinal-based clue types were requested, but no Ordinal categories exist. Please add an ordinal category or allow Binary clues.");if(f&&e.filter(C=>C.type===H.ORDINAL).length<2)throw new G("Invalid Constraints: Cross-Ordinal clues require at least 2 Ordinal Categories.")}return this.internalGenerate(e,r,"standard",{maxCandidates:n,targetClueCount:s,timeoutMs:o,constraints:a.constraints,onTrace:a.onTrace})}validateTarget(e,t){const a=new Set(e.map(s=>s.id));if(!a.has(t.category1Id)||!a.has(t.category2Id))throw new G("Target fact refers to non-existent categories.");if(t.category1Id===t.category2Id)throw new G("Target fact must refer to two different categories.")}generateRandomTarget(e){const t=Math.floor(this.random()*e.length);let a=Math.floor(this.random()*e.length);for(;a===t;)a=Math.floor(this.random()*e.length);const s=e[t],n=e[a],o=Math.floor(this.random()*s.values.length);return{category1Id:s.id,value1:s.values[o],category2Id:n.id}}async generatePuzzleAsync(e,t,a={}){return new Promise((s,n)=>{setTimeout(()=>{try{const o=this.generatePuzzle(e,t,a);s(o)}catch(o){n(o)}},0)})}async getClueCountBoundsAsync(e,t,a=10){return new Promise((s,n)=>{setTimeout(()=>{try{const o=this.getClueCountBounds(e,t,a);s(o)}catch(o){n(o)}},0)})}startSession(e,t){if(e.length<2)throw new G("Must have at least 2 categories.");let a=t;if(!a){const r=Math.floor(this.random()*e.length);let l=Math.floor(this.random()*e.length);for(;l===r;)l=Math.floor(this.random()*e.length);const i=e[r],c=e[l],d=Math.floor(this.random()*i.values.length);a={category1Id:i.id,value1:i.values[d],category2Id:c.id}}const s=new Map,n={},o=new Map;return this.createSolution(e,s,n,o),new at(this,e,n,o,s,a)}internalGenerate(e,t,a,s){if(!e||e.length<2)throw new G("At least 2 categories are required to generate a puzzle.");const n=(s==null?void 0:s.maxCandidates)??1/0,o=s==null?void 0:s.targetClueCount,r=s==null?void 0:s.constraints;s!=null&&s.onTrace&&s.onTrace("Generator: internalGenerate started.");const l=e.find(v=>v.id===t.category1Id);if(l&&!l.values.includes(t.value1))throw new G(`Target value '${t.value1}' does not exist in category '${t.category1Id}'.`);if(r!=null&&r.allowedClueTypes){const v=[h.BINARY,h.ORDINAL,h.CROSS_ORDINAL],T=r.allowedClueTypes.some(p=>v.includes(p));if(r.allowedClueTypes.length>0&&!T)throw new G("Invalid Constraints: The selected clue types are ambiguous on their own. Please allow at least one identity-resolving type (Binary, Ordinal, or Cross-Ordinal).");const u=e.filter(p=>p.type===H.ORDINAL),y=u.length,b=y>0,S=[h.ORDINAL,h.SUPERLATIVE,h.UNARY,h.CROSS_ORDINAL];if(r.allowedClueTypes.some(p=>S.includes(p))&&!b&&!r.allowedClueTypes.includes(h.BINARY))throw new G("Invalid Constraints: Ordinal-based clue types were requested, but no Ordinal categories exist. Please add an ordinal category or allow Binary clues.");if(r.allowedClueTypes.includes(h.CROSS_ORDINAL)&&y<2)throw new G("Invalid Constraints: Cross-Ordinal clues require at least two separate Ordinal categories.");if(r.allowedClueTypes.includes(h.UNARY)&&!u.some(A=>{const I=A.values.map(w=>Number(w)).filter(w=>!isNaN(w)),P=I.some(w=>w%2!==0),L=I.some(w=>w%2===0);return P&&L}))throw new G("Invalid Constraints: Unary clues (Even/Odd) require at least one Ordinal category to contain both odd and even values.")}for(const v of e)if(v.type===H.ORDINAL){if(v.values.some(y=>typeof y!="number"&&isNaN(Number(y))))throw new G(`Category '${v.id}' is ORDINAL but contains non-numeric values.`);if(new Set(v.values).size!==v.values.length)throw new G(`Category '${v.id}' is ORDINAL but contains duplicate values. Ordinal values must be unique.`)}if(this.valueMap=new Map,this.solution={},this.reverseSolution=new Map,s!=null&&s.onTrace&&s.onTrace("Generator: Creating solution..."),this.createSolution(e,this.valueMap,this.solution,this.reverseSolution),s!=null&&s.onTrace&&s.onTrace("Generator: Solution created."),o!==void 0){const v=e.length,T=e[0].values.length,u=ot(v,T);s!=null&&s.onTrace&&s.onTrace(`Generator: Feasibility check complete. Recommended bounds: ${u.min}-${u.max}`);const y=0;let b=o;u.min>0&&o<u.min-y&&(console.warn(`Target clue count ${o} is too low (Estimated min: ${u.min}). Auto-adjusting to ${u.min}.`),b=u.min);try{return this.generateWithBacktracking(e,t,b,n,a,(s==null?void 0:s.timeoutMs)??1e4,s==null?void 0:s.constraints,s==null?void 0:s.onTrace)}catch(S){throw S}}s!=null&&s.onTrace&&s.onTrace("Generator: Generating all possible clues...");let i=this.generateAllPossibleClues(e,s==null?void 0:s.constraints,this.reverseSolution,this.valueMap);s!=null&&s.onTrace&&s.onTrace(`Generator: Generated ${i.length} candidate clues.`);const c=new J(e),d=[],f=100;for(;d.length<f;){if(s!=null&&s.onTrace){const A=d.length,I=c.getGridStats(),P=Math.max(1,I.totalPossible-I.solutionPossible),L=Math.max(0,I.currentPossible-I.solutionPossible),w=Math.min(100,Math.round((P-L)/P*100));if(s.onTrace(`Depth ${A}: ${w}% Solved. Candidates: ${i.length}`),w>=100&&this.isPuzzleSolved(c,this.solution,this.reverseSolution)){s.onTrace("Generator: Puzzle Solved (100%).");break}}let v=null,T=null;if(n<i.length)for(let A=i.length-1;A>0;A--){const I=Math.floor(this.random()*(A+1));[i[A],i[I]]=[i[I],i[A]]}const u=Math.min(i.length,n);let y=0;for(let A=i.length-1;A>=0&&!(y>=u);A--){const I=i[A],P=c.clone(),{deductions:L}=this.solver.applyClue(P,I);if(L===0){i.splice(A,1);continue}y++;let w=0;a==="min"?w=L*1e3:a==="max"?w=100/L:w=this.calculateClueScore(P,t,L,I,d.map(M=>M.clue),this.solution,this.reverseSolution),I.type;const B=this.solution[t.category2Id][t.value1],E=P.isPossible(t.category1Id,t.value1,t.category2Id,B)&&P.getPossibilitiesCount(t.category1Id,t.value1,t.category2Id)===1,R=this.isPuzzleSolved(P,this.solution,this.reverseSolution);E&&(R?T={clue:I,score:w+1e6}:w=-1e6),w>-999999&&(!v||w>v.score)&&(v={clue:I,score:w})}const b=T||v;if(!b)break;const S=b.clue,{deductions:g}=this.solver.applyClue(c,S);d.push({clue:S,deductions:g});const p=i.findIndex(A=>JSON.stringify(A)===JSON.stringify(S));if(p>-1&&i.splice(p,1),this.isPuzzleSolved(c,this.solution,this.reverseSolution))break}const V=new J(e),C=V.getGridStats(),x=C.totalPossible-C.solutionPossible;for(const v of d){const T=this.solver.applyClue(V,v.clue);v.clue.deductions=T.deductions;const u=V.getGridStats(),y=u.totalPossible-u.currentPossible;x>0?v.clue.percentComplete=Math.min(100,Math.max(0,y/x*100)):v.clue.percentComplete=100,v.clue.reasons=T.reasons}return{solution:this.solution,clues:d.map(v=>v.clue),proofChain:d,categories:e,targetFact:t}}generateWithBacktracking(e,t,a,s,n,o=1e4,r,l){const i=this.generateAllPossibleClues(e,r,this.reverseSolution,this.valueMap),c=new J(e);let d=0;const f=Date.now(),V=(x,v,T,u)=>{const S=1+(Date.now()-f)/o*3;if(l&&v.length%1===0){const N=v.length+1,$=x.getGridStats(),O=Math.round(($.totalPossible-$.currentPossible)/($.totalPossible-$.solutionPossible)*100);Math.random()<.05&&l(`Depth ${N}/${a}: ${O}% Solved. Bias: ${S.toFixed(2)} (Backtracks: ${d})`)}if(this.isPuzzleSolved(x,this.solution,this.reverseSolution))return v.length===a?(l&&l(`SOLVED! Exact match at ${a} clues.`),v):null;if(v.length>=a)return null;const p=x.getGridStats(),A=(p.totalPossible-p.currentPossible)/(p.totalPossible-p.solutionPossible),I=v.length+1;let P=[];if(s<T.length)for(let N=T.length-1;N>0;N--){const $=Math.floor(this.random()*(N+1));[T[N],T[$]]=[T[$],T[N]]}const w=Math.max(1,Math.floor((u?3:s===1/0?50:s)/Math.pow(S,2))),B=Math.min(T.length,w);l&&Math.random()<.001&&l(`Pruning: Limit reduced to ${B} (Bias ${S.toFixed(1)})`);let E=0;for(let N=0;N<T.length&&!(E>=B);N++){const $=T[N],O=x.clone(),{deductions:k}=this.solver.applyClue(O,$);if(k===0||(E++,this.isPuzzleSolved(O,this.solution,this.reverseSolution)&&I<a))continue;let W=this.calculateClueScore(O,t,k,$,v.map(F=>F.clue),this.solution,this.reverseSolution);if(a){const F=I/a,X=(p.totalPossible-O.getGridStats().currentPossible)/(p.totalPossible-p.solutionPossible),j=Math.pow(F,1.8),U=X-j;W-=U*k*50}P.push({clue:$,deductions:k,score:W,grid:O,index:N})}let R=[],M,D;if(u){const N=u==="STALL";R=P.sort(($,O)=>{const k=$.deductions-O.deductions;return N?k:-k})}else P.sort((N,$)=>$.score-N.score),M=P[0];if(!u){if(D=P[0],a){const N=Math.pow(I/a,1.8);A>N?D=[...P].sort((O,k)=>O.deductions!==k.deductions?O.deductions-k.deductions:k.score-O.score)[0]:D=[...P].sort((O,k)=>O.deductions!==k.deductions?k.deductions-O.deductions:k.score-O.score)[0]}M&&R.push(M),D&&D!==M&&R.push(D);for(const N of P)N!==M&&N!==D&&R.push(N)}for(const N of R){const $=1+(Date.now()-f)/o*4;if(a&&v.length>4&&$>1.1&&!(!!u||N===M||N===D))break;const O=[...T];O.splice(N.index,1);const k=N===M,q=N===D&&N!==M;let W=u,F="";if(!u&&q&&a){const j=A>I/a,U=`(Prog ${A.toFixed(2)} vs Exp ${(I/a).toFixed(2)})`;W=j?"STALL":"SPEED",F=j?`(Stalling - Weakest) ${U}`:`(Speeding - Strongest) ${U}`}else u&&(F=`(Continued ${u})`);if(l&&(q||u||Math.random()<.05)){const j=u?`STICKY ${u}`:k?"Primary":q?"CORRECTION":"Rest";q?l(`[BACKTRACK] Depth ${v.length}: Primary Strategy Failed. Switching to ${F}. Ded: ${N.deductions}`):u?Math.random()<.1&&l(`Depth ${v.length}: ${Math.round(A*100)}% Solved. Strategy: ${j}. Ded: ${N.deductions}`):l(`Depth ${v.length}: ${Math.round(A*100)}% Solved. Trying ${j} Cand. Ded: ${N.deductions}`)}const X=V(N.grid,[...v,{clue:N.clue,deductions:N.deductions}],O,W);if(X)return X}return d++,null},C=V(c,[],[...i]);if(C)return{solution:this.solution,clues:C.map(v=>v.clue),proofChain:C,categories:e,targetFact:t};throw new G(`Could not generate puzzle with exactly ${a} clues within timeout.`)}createSolution(e,t,a,s){var o;const n=e[0];n.values.forEach(r=>{t.set(r,{[n.id]:r})});for(let r=1;r<e.length;r++){const l=e[r],i=[...l.values].sort(()=>this.random()-.5);let c=0;for(const d of n.values){const f=t.get(d);f&&(f[l.id]=i[c++])}}for(const r of e)a[r.id]={},s.set(r.id,new Map);for(const r of n.values){const l=t.get(r);if(l)for(const i in l)a[i][r]=l[i],(o=s.get(i))==null||o.set(l[i],r)}}generateAllPossibleClues(e,t,a,s){var r,l,i,c,d,f,V,C,x,v,T;const n=[];e[0];const o=u=>!(t!=null&&t.allowedClueTypes)||t.allowedClueTypes.includes(u);if(o(h.BINARY))for(const u of e)for(const y of u.values)for(const b of e){if(u.id>=b.id)continue;const S=(r=a.get(u.id))==null?void 0:r.get(y);if(!S)continue;const g=s.get(S);if(g)for(const p of b.values){const A=g[b.id];p===A?n.push({type:h.BINARY,operator:z.IS,cat1:u.id,val1:y,cat2:b.id,val2:p}):n.push({type:h.BINARY,operator:z.IS_NOT,cat1:u.id,val1:y,cat2:b.id,val2:p})}}for(const u of e.filter(y=>y.type===H.ORDINAL)){const y=[...u.values].sort((g,p)=>g-p),b=y[0],S=y[y.length-1];if(o(h.SUPERLATIVE)){for(const g of e)if(g.id!==u.id)for(const p of g.values){const A=(l=a.get(g.id))==null?void 0:l.get(p);if(!A)continue;const I=s.get(A);if(!I)continue;const P=I[u.id];P===b?n.push({type:h.SUPERLATIVE,operator:Y.MIN,targetCat:g.id,targetVal:p,ordinalCat:u.id}):n.push({type:h.SUPERLATIVE,operator:Y.NOT_MIN,targetCat:g.id,targetVal:p,ordinalCat:u.id}),P===S?n.push({type:h.SUPERLATIVE,operator:Y.MAX,targetCat:g.id,targetVal:p,ordinalCat:u.id}):n.push({type:h.SUPERLATIVE,operator:Y.NOT_MAX,targetCat:g.id,targetVal:p,ordinalCat:u.id})}}if(o(h.ORDINAL)){for(const g of e)if(g.id!==u.id){for(const p of e)if(p.id!==u.id)for(const A of g.values)for(const I of p.values){if(g.id===p.id&&A===I)continue;const P=(i=a.get(g.id))==null?void 0:i.get(A),L=(c=a.get(p.id))==null?void 0:c.get(I);if(!P||!L||P===L)continue;const w=s.get(P),B=s.get(L);if(!w||!B)continue;const E=w[u.id],R=B[u.id];E>R?(n.push({type:h.ORDINAL,operator:_.GREATER_THAN,item1Cat:g.id,item1Val:A,item2Cat:p.id,item2Val:I,ordinalCat:u.id}),n.push({type:h.ORDINAL,operator:_.NOT_LESS_THAN,item1Cat:g.id,item1Val:A,item2Cat:p.id,item2Val:I,ordinalCat:u.id})):E<R&&(n.push({type:h.ORDINAL,operator:_.LESS_THAN,item1Cat:g.id,item1Val:A,item2Cat:p.id,item2Val:I,ordinalCat:u.id}),n.push({type:h.ORDINAL,operator:_.NOT_GREATER_THAN,item1Cat:g.id,item1Val:A,item2Cat:p.id,item2Val:I,ordinalCat:u.id}))}}}}if(o(h.UNARY)){for(const u of e)if(u.type===H.ORDINAL&&u.values.every(y=>typeof y=="number")){for(const y of e)if(y.id!==u.id)for(const b of y.values){const S=(d=a.get(y.id))==null?void 0:d.get(b);if(!S)continue;const g=s.get(S);if(!g)continue;g[u.id]%2===0?n.push({type:h.UNARY,filter:K.IS_EVEN,targetCat:y.id,targetVal:b,ordinalCat:u.id}):n.push({type:h.UNARY,filter:K.IS_ODD,targetCat:y.id,targetVal:b,ordinalCat:u.id})}}}if(o(h.BETWEEN)){const u=e.filter(y=>y.type===H.ORDINAL);for(const y of u)for(const b of e)if(b.id!==y.id)for(const S of b.values){const g=(f=a.get(b.id))==null?void 0:f.get(S);if(!g)continue;const p=s.get(g);if(!p)continue;const A=p[y.id];for(const I of e){if(I.id===y.id)continue;const P=[],L=[];for(const w of I.values){if(I.id===b.id&&w===S)continue;const B=(V=a.get(I.id))==null?void 0:V.get(w);if(!B)continue;const E=s.get(B);if(!E)continue;const R=E[y.id];R<A&&P.push(w),R>A&&L.push(w)}for(const w of P)for(const B of L)n.push({type:h.BETWEEN,targetCat:b.id,targetVal:S,lowerCat:I.id,lowerVal:w,upperCat:I.id,upperVal:B,ordinalCat:y.id})}}}if(o(h.ADJACENCY)){const u=e.filter(y=>y.type===H.ORDINAL);for(const y of u){const b=y.values,S=new Map;b.forEach((g,p)=>S.set(g,p));for(const g of e)if(g.id!==y.id)for(const p of e){if(p.id===y.id)continue;const A=g.id===p.id;for(let I=0;I<g.values.length;I++){const P=g.values[I],L=A?I+1:0;for(let w=L;w<p.values.length;w++){const B=p.values[w],E=(C=a.get(g.id))==null?void 0:C.get(P),R=(x=a.get(p.id))==null?void 0:x.get(B);if(!E||!R)continue;const M=s.get(E),D=s.get(R);if(!M||!D)continue;const N=M[y.id],$=D[y.id],O=S.get(N),k=S.get($);O!==void 0&&k!==void 0&&Math.abs(O-k)===1&&n.push({type:h.ADJACENCY,item1Cat:g.id,item1Val:P,item2Cat:p.id,item2Val:B,ordinalCat:y.id})}}}}}if(o(h.OR)){const u=[...n],y=Math.min(u.length,50);for(let b=0;b<y;b++){const S=u[Math.floor(this.random()*u.length)];let g,p=0;for(;!g&&p<10;){p++;const A=this.random()>.5,I=e[Math.floor(this.random()*e.length)],P=e[Math.floor(this.random()*e.length)];if(I.id===P.id)continue;const L=I.values[Math.floor(this.random()*I.values.length)],w=P.values[Math.floor(this.random()*P.values.length)],B=(v=a.get(I.id))==null?void 0:v.get(L),E=B?s.get(B):void 0,R=E?E[P.id]:void 0;if(A){const M=R===w;g={type:h.BINARY,cat1:I.id,val1:L,cat2:P.id,val2:w,operator:M?z.IS_NOT:z.IS}}else{const M=R===w;g={type:h.BINARY,cat1:I.id,val1:L,cat2:P.id,val2:w,operator:M?z.IS_NOT:z.IS}}}g&&(this.random()>.5?n.push({type:h.OR,clue1:S,clue2:g}):n.push({type:h.OR,clue1:g,clue2:S}))}}if(o(h.ARITHMETIC)){for(const u of e)if(u.type===H.ORDINAL)for(const y of e){if(y.id===u.id)continue;const b=[];for(const g of y.values){const p=(T=a.get(y.id))==null?void 0:T.get(g);if(!p)continue;const A=s.get(p);if(!A)continue;const I=A[u.id];typeof I=="number"&&b.push({val:g,ord:I})}const S=new Map;for(let g=0;g<b.length;g++)for(let p=g+1;p<b.length;p++){const A=b[g],I=b[p],P=Math.abs(A.ord-I.ord);P!==0&&(S.has(P)||S.set(P,[]),S.get(P).push({v1:A.val,v2:I.val}))}for(const[g,p]of S.entries())if(!(p.length<2))for(let A=0;A<p.length;A++)for(let I=A+1;I<p.length;I++){const P=p[A],L=p[I];n.push({type:h.ARITHMETIC,item1Cat:y.id,item1Val:P.v1,item2Cat:y.id,item2Val:P.v2,item3Cat:y.id,item3Val:L.v1,item4Cat:y.id,item4Val:L.v2,ordinalCat:u.id})}}}return n}calculateClueScore(e,t,a,s,n,o,r){var B;const l=s.type,i=(B=r.get(t.category1Id))==null?void 0:B.get(t.value1);let c;i!==void 0&&(c=o[t.category2Id][i]);const d=c!==void 0&&e.isPossible(t.category1Id,t.value1,t.category2Id,c)&&e.getPossibilitiesCount(t.category1Id,t.value1,t.category2Id)===1,f=this.isPuzzleSolved(e,o,r);if(s.type===h.BINARY&&s.operator===z.IS){const E=s;if(E.cat1===t.category1Id&&E.val1===t.value1&&E.cat2===t.category2Id&&E.val2===c||E.cat1===t.category2Id&&E.val1===c&&E.cat2===t.category1Id&&E.val2===t.value1)return-1/0}if(d&&f)return 1e6;if(d&&!f||d&&!f)return-1e6;const V=a,{totalPossible:C,currentPossible:x,solutionPossible:v}=e.getGridStats(),T=C-v,u=C-x,y=T>0?u/T:0;let b=0;switch(l){case h.ORDINAL:b=1.5,s.operator>=2&&(b=5);break;case h.SUPERLATIVE:b=1.2,s.operator>=2&&(b=5);break;case h.UNARY:b=1.2;break;case h.BETWEEN:b=4;break;case h.ADJACENCY:b=3.5;break;case h.OR:b=6;break;case h.ARITHMETIC:b=4.5;break}let S=0;const g=E=>{const R=(N,$)=>{var O;return(O=this.reverseSolution.get(N))==null?void 0:O.get($)};let M=[],D=[];switch(E.type){case h.BINARY:const N=E;M.push(R(N.cat1,N.val1)),N.operator===z.IS_NOT&&D.push(R(N.cat2,N.val2));break;case h.BETWEEN:const $=E;M.push(R($.targetCat,$.targetVal)),D.push(R($.lowerCat,$.lowerVal)),D.push(R($.upperCat,$.upperVal));break;case h.ADJACENCY:const O=E;M.push(R(O.item1Cat,O.item1Val)),D.push(R(O.item2Cat,O.item2Val));break;case h.SUPERLATIVE:const k=E;M.push(R(k.targetCat,k.targetVal));break;case h.ORDINAL:const q=E;M.push(R(q.item1Cat,q.item1Val)),D.push(R(q.item2Cat,q.item2Val));break;case h.UNARY:const W=E;M.push(R(W.targetCat,W.targetVal));break;case h.CROSS_ORDINAL:break;case h.OR:const F=E,X=g(F.clue1),j=g(F.clue2);M.push(...X.primary,...j.primary),D.push(...X.secondary,...j.secondary);break;case h.ARITHMETIC:const U=E;M.push(R(U.item1Cat,U.item1Val)),M.push(R(U.item3Cat,U.item3Val)),D.push(R(U.item2Cat,U.item2Val)),D.push(R(U.item4Cat,U.item4Val));break}return{primary:M.filter(N=>!!N),secondary:D.filter(N=>!!N)}},p=new Set;for(const E of n){const{primary:R,secondary:M}=g(E);R.forEach(D=>p.add(D)),M.forEach(D=>p.add(D))}const{primary:A,secondary:I}=g(s);A.forEach(E=>{p.has(E)&&(S+=1)}),I.forEach(E=>{p.has(E)&&(S+=.5)});const P=s.ordinalCat;if(P)for(const E of n){const R=E.ordinalCat;P===R&&(S+=.5)}if(n.length>0){const E=n[n.length-1];if(s.type===E.type&&(S+=2,s.type===h.BINARY&&s.operator===z.IS&&E.operator===z.IS&&(S+=2)),n.length>1){const N=n[n.length-2];s.type===E.type&&s.type===N.type&&(S+=5)}const R=N=>{switch(N.type){case h.SUPERLATIVE:return 1;case h.BINARY:return N.operator===z.IS?1:3;case h.ORDINAL:return 3;case h.UNARY:return 3;case h.CROSS_ORDINAL:return 4;case h.BETWEEN:return 4;case h.ADJACENCY:return 3;case h.OR:return 5;case h.ARITHMETIC:return 4;default:return 2}},M=R(s),D=R(E);M===D&&(S+=1.5)}const L=Math.pow(.4,S);return(V*b+y*5)*L}checkClueConsistency(e,t,a,s,n){const o=(i,c,d)=>{var V;const f=(V=a.get(i))==null?void 0:V.get(c);if(f)return t[d][f]},r=(i,c)=>{var d;return(d=a.get(i))==null?void 0:d.get(c)},l=(i,c,d)=>{const f=r(i,c);if(!f)return;const V=s.get(f);if(!V)return;const C=V[d];return typeof C=="number"?C:void 0};switch(e.type){case h.ARITHMETIC:{const i=e,c=l(i.item1Cat,i.item1Val,i.ordinalCat),d=l(i.item2Cat,i.item2Val,i.ordinalCat),f=l(i.item3Cat,i.item3Val,i.ordinalCat),V=l(i.item4Cat,i.item4Val,i.ordinalCat);return c===void 0||d===void 0||f===void 0||V===void 0?!1:Math.abs(c-d)===Math.abs(f-V)}case h.BINARY:{const i=e,c=o(i.cat1,i.val1,i.cat2);if(c===void 0)return!1;if(i.operator===z.IS)return c===i.val2;if(i.operator===z.IS_NOT)return c!==i.val2;break}case h.ORDINAL:{const i=e,c=l(i.item1Cat,i.item1Val,i.ordinalCat),d=l(i.item2Cat,i.item2Val,i.ordinalCat);if(c===void 0||d===void 0)return!1;switch(i.operator){case _.GREATER_THAN:return c>d;case _.LESS_THAN:return c<d;case _.NOT_GREATER_THAN:return c<=d;case _.NOT_LESS_THAN:return c>=d}break}case h.SUPERLATIVE:{const i=e,c=l(i.targetCat,i.targetVal,i.ordinalCat);if(c===void 0)return!1;let d=1/0,f=-1/0;for(const V of s.keys()){const C=s.get(V);if(C){const x=C[i.ordinalCat];typeof x=="number"&&(x<d&&(d=x),x>f&&(f=x))}}if(d===1/0)return!1;switch(i.operator){case Y.MIN:return c===d;case Y.MAX:return c===f;case Y.NOT_MIN:return c!==d;case Y.NOT_MAX:return c!==f}break}case h.UNARY:{const i=e,c=l(i.targetCat,i.targetVal,i.ordinalCat);if(c===void 0)return!1;switch(i.filter){case K.IS_ODD:return c%2!==0;case K.IS_EVEN:return c%2===0}break}case h.BETWEEN:{const i=e,c=l(i.targetCat,i.targetVal,i.ordinalCat),d=l(i.lowerCat,i.lowerVal,i.ordinalCat),f=l(i.upperCat,i.upperVal,i.ordinalCat);return c===void 0||d===void 0||f===void 0?!1:c>d&&c<f}case h.ADJACENCY:{const i=e,c=l(i.item1Cat,i.item1Val,i.ordinalCat),d=l(i.item2Cat,i.item2Val,i.ordinalCat);if(c===void 0||d===void 0)return!1;const f=n.find(v=>v.id===i.ordinalCat);if(!f)return!1;const V=f.values,C=V.indexOf(c),x=V.indexOf(d);return Math.abs(C-x)===1}case h.CROSS_ORDINAL:{const i=e,c=l(i.item1Cat,i.item1Val,i.ordinal1),d=l(i.item2Cat,i.item2Val,i.ordinal2);if(c===void 0||d===void 0)return!1;switch(i.operator){case _.GREATER_THAN:return c>d;case _.LESS_THAN:return c<d;case _.NOT_GREATER_THAN:return c<=d;case _.NOT_LESS_THAN:return c>=d}break}case h.OR:{const i=e,c=this.checkClueConsistency(i.clue1,t,a,s,n),d=this.checkClueConsistency(i.clue2,t,a,s,n);return c||d}}return!0}isPuzzleSolved(e,t,a){var n;const s=e.categories;s[0];for(const o of s)for(const r of o.values)for(const l of s){if(o.id>=l.id)continue;const i=(n=a.get(o.id))==null?void 0:n.get(r);if(!i)return!1;const c=t[l.id][i];if(e.getPossibilitiesCount(o.id,r,l.id)>1||!e.isPossible(o.id,r,l.id,c))return!1}return!0}}const Q=self;Q.onmessage=m=>{const{type:e}=m.data;if(e==="start"){const{categories:t,targetFact:a,options:s}=m.data;s&&s.targetClueCount&&(s.targetClueCount=parseInt(String(s.targetClueCount),10));try{const n=new Z(s==null?void 0:s.seed),o={...s,onTrace:l=>{Q.postMessage({type:"trace",message:l})}};let r;try{r=n.generatePuzzle(t,a,o)}catch(l){if(s.targetClueCount&&l.message&&l.message.includes("Could not generate puzzle")){Q.postMessage({type:"trace",message:`⚠️ Strict generation failed (${l.message}). Falling back to best-effort generation...`});const i={...o,targetClueCount:void 0};r=n.generatePuzzle(t,a,i)}else throw l}Q.postMessage({type:"done",puzzle:r})}catch(n){console.error("Worker Generation Error:",n),Q.postMessage({type:"error",message:n.message||"Unknown worker error"})}}}})();
