(function(){"use strict";var B=(f=>(f[f.NOMINAL=0]="NOMINAL",f[f.ORDINAL=1]="ORDINAL",f))(B||{}),g=(f=>(f[f.BINARY=0]="BINARY",f[f.ORDINAL=1]="ORDINAL",f[f.SUPERLATIVE=2]="SUPERLATIVE",f[f.UNARY=3]="UNARY",f[f.CROSS_ORDINAL=4]="CROSS_ORDINAL",f))(g||{}),ee=(f=>(f[f.MATCH=0]="MATCH",f[f.NOT_MATCH=1]="NOT_MATCH",f))(ee||{}),_=(f=>(f[f.IS=0]="IS",f[f.IS_NOT=1]="IS_NOT",f))(_||{}),z=(f=>(f[f.GREATER_THAN=0]="GREATER_THAN",f[f.LESS_THAN=1]="LESS_THAN",f[f.NOT_GREATER_THAN=2]="NOT_GREATER_THAN",f[f.NOT_LESS_THAN=3]="NOT_LESS_THAN",f))(z||{}),G=(f=>(f[f.MIN=0]="MIN",f[f.MAX=1]="MAX",f[f.NOT_MIN=2]="NOT_MIN",f[f.NOT_MAX=3]="NOT_MAX",f))(G||{}),X=(f=>(f[f.IS_ODD=0]="IS_ODD",f[f.IS_EVEN=1]="IS_EVEN",f))(X||{});class ie extends Error{constructor(t){super(t),this.name="LogicPuzzleError"}}class D extends ie{constructor(t){super(t),this.name="ConfigurationError"}}class H{constructor(t){this.validateConfig(t),this.categories=t,this.valueMap=new Map(t.map(e=>[e.id,new Map(e.values.map((i,s)=>[i,s]))])),this.grid=new Map;for(const e of t){const i=new Map;for(const s of e.values){const o=new Map;for(const l of t)e.id!==l.id&&o.set(l.id,Array(l.values.length).fill(!0));i.set(s,o)}this.grid.set(e.id,i)}}validateConfig(t){const e=new Set;let i=-1;for(const s of t){if(e.has(s.id))throw new D(`Duplicate category ID found: ${s.id}`);if(e.add(s.id),new Set(s.values).size!==s.values.length)throw new D(`Category '${s.id}' has duplicate values.`);if(i===-1)i=s.values.length;else if(s.values.length!==i)throw new D(`Category '${s.id}' has ${s.values.length} values, expected ${i}. All categories must be the same size.`)}}setPossibility(t,e,i,s,o){var a,r;const l=(a=this.valueMap.get(i))==null?void 0:a.get(s);if(l!==void 0){const d=this.grid.get(t);if(d){const v=d.get(e);if(v){const c=v.get(i);c&&(c[l]=o)}}}const n=(r=this.valueMap.get(t))==null?void 0:r.get(e);if(n!==void 0){const d=this.grid.get(i);if(d){const v=d.get(s);if(v){const c=v.get(t);c&&(c[n]=o)}}}}isPossible(t,e,i,s){var r;if(t===i)return e===s;const o=(r=this.valueMap.get(i))==null?void 0:r.get(s);if(o===void 0)return!1;const l=this.grid.get(t);if(!l)return!1;const n=l.get(e);if(!n)return!1;const a=n.get(i);return a?a[o]:!1}getPossibilitiesCount(t,e,i){var o,l;const s=(l=(o=this.grid.get(t))==null?void 0:o.get(e))==null?void 0:l.get(i);return s?s.filter(n=>n).length:0}getGridStats(){var n,a,r;let t=0;const e=this.categories.length,i=((n=this.categories[0])==null?void 0:n.values.length)||0;if(i===0||e<2)return{totalPossible:0,currentPossible:0,solutionPossible:0};const s=e*(e-1)/2,o=s*i*i,l=s*i;for(const d of this.categories)for(const v of d.values)for(const c of this.categories){if(d.id>=c.id)continue;const u=(r=(a=this.grid.get(d.id))==null?void 0:a.get(v))==null?void 0:r.get(c.id);u&&(t+=u.filter(p=>p).length)}return{totalPossible:o,currentPossible:t,solutionPossible:l}}clone(){const t=new H(this.categories);return t.grid=new Map([...this.grid.entries()].map(([e,i])=>[e,new Map([...i.entries()].map(([s,o])=>[s,new Map([...o.entries()].map(([l,n])=>[l,[...n]]))]))])),t}}class te{applyClue(t,e){let i=0;switch(e.type){case g.BINARY:i+=this.applyBinaryClue(t,e);break;case g.SUPERLATIVE:i+=this.applySuperlativeClue(t,e);break;case g.ORDINAL:i+=this.applyOrdinalClue(t,e);break;case g.UNARY:i+=this.applyUnaryClue(t,e);break;case g.CROSS_ORDINAL:i+=this.applyCrossOrdinalClue(t,e);break}let s;do s=this.runDeductionLoop(t),i+=s;while(s>0);return{grid:t,deductions:i}}applyCrossOrdinalClue(t,e){let i=0;const s=t.categories,o=s.find(v=>v.id===e.ordinal1),l=s.find(v=>v.id===e.ordinal2);if(!o||!l)return 0;const n=e.operator===ee.NOT_MATCH,a=(v,c,u,p)=>p.values.map((m,h)=>({val:m,idx:h})).filter(m=>t.isPossible(v,c,u,m.val)),r=a(e.item1Cat,e.item1Val,e.ordinal1,o),d=a(e.item2Cat,e.item2Val,e.ordinal2,l);if(n){if(r.length===1&&d.length===1){const v=r[0].idx+e.offset1,c=d[0].idx+e.offset2,u=o.values[v],p=l.values[c];u!==void 0&&p!==void 0&&t.isPossible(e.ordinal1,u,e.ordinal2,p)&&(t.setPossibility(e.ordinal1,u,e.ordinal2,p,!1),i++)}for(const v of r){const c=v.idx+e.offset1;if(o.values[c]!==void 0)for(const p of d){const m=p.idx+e.offset2;l.values[m]}}if(r.length===1){const v=r[0].idx+e.offset1,c=o.values[v];if(c!==void 0)for(const u of d){const p=u.idx+e.offset2,m=l.values[p];m!==void 0&&t.isPossible(e.ordinal1,c,e.ordinal2,m)&&(t.setPossibility(e.item2Cat,e.item2Val,e.ordinal2,u.val,!1),i++)}}if(d.length===1){const v=d[0].idx+e.offset2,c=l.values[v];if(c!==void 0)for(const u of r){const p=u.idx+e.offset1,m=o.values[p];m!==void 0&&t.isPossible(e.ordinal1,m,e.ordinal2,c)&&(t.setPossibility(e.item1Cat,e.item1Val,e.ordinal1,u.val,!1),i++)}}}else{for(const u of r){const p=u.idx+e.offset1,m=o.values[p];if(m===void 0){t.setPossibility(e.item1Cat,e.item1Val,e.ordinal1,u.val,!1),i++;continue}let h=!1;for(const y of d){const b=y.idx+e.offset2,R=l.values[b];if(R!==void 0&&t.isPossible(e.ordinal1,m,e.ordinal2,R)){h=!0;break}}h||(t.setPossibility(e.item1Cat,e.item1Val,e.ordinal1,u.val,!1),i++)}for(const u of d){const p=u.idx+e.offset2,m=l.values[p];if(m===void 0){t.setPossibility(e.item2Cat,e.item2Val,e.ordinal2,u.val,!1),i++;continue}let h=!1;for(const y of r){const b=y.idx+e.offset1,R=o.values[b];if(R!==void 0&&t.isPossible(e.ordinal1,R,e.ordinal2,m)){h=!0;break}}h||(t.setPossibility(e.item2Cat,e.item2Val,e.ordinal2,u.val,!1),i++)}const v=a(e.item1Cat,e.item1Val,e.ordinal1,o),c=a(e.item2Cat,e.item2Val,e.ordinal2,l);if(v.length===1&&c.length===1){const u=v[0].idx+e.offset1,p=c[0].idx+e.offset2,m=o.values[u],h=l.values[p];m!==void 0&&h!==void 0&&t.getPossibilitiesCount(e.ordinal1,m,e.ordinal2)>1&&(t.setPossibility(e.ordinal1,m,e.ordinal2,h,!0),i++)}}return i}applyUnaryClue(t,e){let i=0;const o=t.categories.find(n=>n.id===e.ordinalCat);if(!o||o.type!==B.ORDINAL||!o.values.every(n=>typeof n=="number"))return 0;const l=e.filter===X.IS_EVEN;for(const n of o.values){const a=n;(l?a%2!==0:a%2===0)&&t.isPossible(e.targetCat,e.targetVal,e.ordinalCat,n)&&(t.setPossibility(e.targetCat,e.targetVal,e.ordinalCat,n,!1),i++)}return i}applyBinaryClue(t,e){let i=0;const s=t.categories,o=s.find(n=>n.id===e.cat1),l=s.find(n=>n.id===e.cat2);if(!o||!l)return 0;if(e.operator===_.IS){t.isPossible(e.cat1,e.val1,e.cat2,e.val2),t.setPossibility(e.cat1,e.val1,e.cat2,e.val2,!0);for(const n of l.values)n!==e.val2&&t.isPossible(e.cat1,e.val1,e.cat2,n)&&(t.setPossibility(e.cat1,e.val1,e.cat2,n,!1),i++);for(const n of o.values)n!==e.val1&&t.isPossible(e.cat1,n,e.cat2,e.val2)&&(t.setPossibility(e.cat1,n,e.cat2,e.val2,!1),i++)}else t.isPossible(e.cat1,e.val1,e.cat2,e.val2)&&(t.setPossibility(e.cat1,e.val1,e.cat2,e.val2,!1),i++);return i}runDeductionLoop(t){let e=0;const i=t.categories;for(const s of i)for(const o of s.values)for(const l of i){if(s.id===l.id)continue;const n=l.values.filter(a=>t.isPossible(s.id,o,l.id,a));if(n.length===1){const a=n[0];for(const r of s.values)r!==o&&t.isPossible(s.id,r,l.id,a)&&(t.setPossibility(s.id,r,l.id,a,!1),e++)}for(const a of i){if(s.id===a.id||l.id===a.id)continue;const r=n.length===1?n[0]:null;if(r){const d=a.values.filter(v=>t.isPossible(l.id,r,a.id,v));if(d.length===1){const v=d[0];t.isPossible(s.id,o,a.id,v)===!1||t.getPossibilitiesCount(s.id,o,a.id)>1&&(t.setPossibility(s.id,o,a.id,v,!0),e++)}}for(const d of a.values)t.isPossible(s.id,o,a.id,d)&&(l.values.some(c=>t.isPossible(s.id,o,l.id,c)&&t.isPossible(l.id,c,a.id,d))||(t.setPossibility(s.id,o,a.id,d,!1),e++))}}return e}applyOrdinalClue(t,e){let i=0;const o=t.categories.find(a=>a.id===e.ordinalCat);if(!o||o.type!==B.ORDINAL)return 0;const l=o.values.map((a,r)=>({val:a,idx:r})).filter(a=>t.isPossible(e.item1Cat,e.item1Val,e.ordinalCat,a.val)),n=o.values.map((a,r)=>({val:a,idx:r})).filter(a=>t.isPossible(e.item2Cat,e.item2Val,e.ordinalCat,a.val));if(l.length===0||n.length===0)return 0;if(e.operator===z.GREATER_THAN)for(const a of l)n.some(d=>a.idx>d.idx)||t.isPossible(e.item1Cat,e.item1Val,e.ordinalCat,a.val)&&(t.setPossibility(e.item1Cat,e.item1Val,e.ordinalCat,a.val,!1),i++);else if(e.operator===z.LESS_THAN)for(const a of l)n.some(d=>a.idx<d.idx)||t.isPossible(e.item1Cat,e.item1Val,e.ordinalCat,a.val)&&(t.setPossibility(e.item1Cat,e.item1Val,e.ordinalCat,a.val,!1),i++);else if(e.operator===z.NOT_GREATER_THAN)for(const a of l)n.some(d=>a.idx<=d.idx)||t.isPossible(e.item1Cat,e.item1Val,e.ordinalCat,a.val)&&(t.setPossibility(e.item1Cat,e.item1Val,e.ordinalCat,a.val,!1),i++);else if(e.operator===z.NOT_LESS_THAN)for(const a of l)n.some(d=>a.idx>=d.idx)||t.isPossible(e.item1Cat,e.item1Val,e.ordinalCat,a.val)&&(t.setPossibility(e.item1Cat,e.item1Val,e.ordinalCat,a.val,!1),i++);if(e.operator===z.GREATER_THAN)for(const a of n)l.some(d=>a.idx<d.idx)||t.isPossible(e.item2Cat,e.item2Val,e.ordinalCat,a.val)&&(t.setPossibility(e.item2Cat,e.item2Val,e.ordinalCat,a.val,!1),i++);else if(e.operator===z.LESS_THAN)for(const a of n)l.some(d=>a.idx>d.idx)||t.isPossible(e.item2Cat,e.item2Val,e.ordinalCat,a.val)&&(t.setPossibility(e.item2Cat,e.item2Val,e.ordinalCat,a.val,!1),i++);else if(e.operator===z.NOT_GREATER_THAN)for(const a of n)l.some(d=>a.idx>=d.idx)||t.isPossible(e.item2Cat,e.item2Val,e.ordinalCat,a.val)&&(t.setPossibility(e.item2Cat,e.item2Val,e.ordinalCat,a.val,!1),i++);else if(e.operator===z.NOT_LESS_THAN)for(const a of n)l.some(d=>a.idx<=d.idx)||t.isPossible(e.item2Cat,e.item2Val,e.ordinalCat,a.val)&&(t.setPossibility(e.item2Cat,e.item2Val,e.ordinalCat,a.val,!1),i++);return i}applySuperlativeClue(t,e){const s=t.categories.find(a=>a.id===e.ordinalCat);if(!s||s.type!==B.ORDINAL)return 0;let o,l=!1;switch(e.operator){case G.MAX:o=s.values[s.values.length-1];break;case G.MIN:o=s.values[0];break;case G.NOT_MAX:o=s.values[s.values.length-1],l=!0;break;case G.NOT_MIN:o=s.values[0],l=!0;break;default:return 0}const n={type:g.BINARY,cat1:e.targetCat,val1:e.targetVal,cat2:e.ordinalCat,val2:o,operator:l?_.IS_NOT:_.IS};return this.applyBinaryClue(t,n)}}class ae{constructor(t,e,i,s,o,l){this.generator=t,this.categories=e,this.solution=i,this.reverseSolution=s,this.valueMap=o,this.targetFact=l,this.availableClues=[],this.proofChain=[],this.historyStack=[],this.grid=new H(e),this.solver=new te,this.availableClues=this.generator.generateAllPossibleClues(e,void 0,s,o)}getTotalClueCount(){return this.availableClues.length}getMatchingClueCount(t){return this.filterClues(t).length}getMatchingClues(t,e=50){return this.filterClues(t).slice(0,e)}getScoredMatchingClues(t,e=50){const l=this.filterClues(t).slice(0,200).map(r=>{const d=this.grid.clone(),{deductions:v}=this.solver.applyClue(d,r),c=this.generator.calculateClueScore(this.grid,this.targetFact,v,r,this.proofChain,this.solution,this.reverseSolution);let u=!1;if(r.type===g.BINARY&&r.operator===_.IS){const m=r,h=m.cat1===this.targetFact.category1Id&&m.val1===this.targetFact.value1&&m.cat2===this.targetFact.category2Id,y=m.cat2===this.targetFact.category1Id&&m.val2===this.targetFact.value1&&m.cat1===this.targetFact.category2Id;(h||y)&&(u=!0)}return{clue:r,score:c,deductions:v,isDirectAnswer:u}});l.sort((r,d)=>d.score-r.score);const n=(t==null?void 0:t.minDeductions)??0;return l.filter(r=>r.deductions>=n).slice(0,e)}useClue(t){return this.applyAndSave(t),{remaining:this.availableClues.length,solved:this.generator.isPuzzleSolved(this.grid,this.solution,this.reverseSolution)}}filterClues(t){return this.availableClues.filter(e=>{if(t!=null&&t.allowedClueTypes&&!t.allowedClueTypes.includes(e.type))return!1;if(t!=null&&t.includeSubjects&&(t!=null&&t.excludeSubjects)){const i=t.includeSubjects.filter(s=>t.excludeSubjects.includes(s));if(i.length>0)throw new Error(`Constraint Error: The following subjects are both included and excluded: ${i.join(", ")}`)}if(t!=null&&t.includeSubjects||t!=null&&t.excludeSubjects){const i=this.extractValuesFromClue(e);if(t.includeSubjects&&!t.includeSubjects.some(o=>i.includes(o))||t.excludeSubjects&&t.excludeSubjects.some(o=>i.includes(o)))return!1}return!0})}applyAndSave(t){this.historyStack.push(this.grid.clone()),this.solver.applyClue(this.grid,t),this.proofChain.push(t);const e=this.availableClues.indexOf(t);e>-1&&this.availableClues.splice(e,1)}getNextClue(t){const e=this.filterClues(t);let i=null,s=-1/0;const o=[...e].sort(()=>Math.random()-.5),l=50;let n=0;const a=(t==null?void 0:t.minDeductions)??0;for(const r of o){if(n++,n>l&&i)break;const d=this.grid.clone(),{deductions:v}=this.solver.applyClue(d,r);if(v<a)continue;const c=this.generator.calculateClueScore(this.grid,this.targetFact,v,r,this.proofChain,this.solution,this.reverseSolution);c>s&&(s=c,i=r)}return i?(this.applyAndSave(i),{clue:i,remaining:this.availableClues.length,solved:this.generator.isPuzzleSolved(this.grid,this.solution,this.reverseSolution)}):{clue:null,remaining:e.length,solved:this.generator.isPuzzleSolved(this.grid,this.solution,this.reverseSolution)}}async getNextClueAsync(t){return new Promise((e,i)=>{setTimeout(()=>{try{const s=this.getNextClue(t);e(s)}catch(s){i(s)}},0)})}rollbackLastClue(){if(this.historyStack.length===0)return{success:!1,clue:null};const t=this.historyStack.pop();t&&(this.grid=t);const e=this.proofChain.pop();return e?(this.availableClues.push(e),{success:!0,clue:e}):{success:!1,clue:null}}isUseful(t){return!0}getGrid(){return this.grid}getProofChain(){return this.proofChain}getSolution(){return this.solution}getValueMap(){return this.valueMap}extractValuesFromClue(t){const e=[],i=s=>{s!==void 0&&e.push(String(s))};return i(t.val1),i(t.val2),i(t.item1Val),i(t.item2Val),i(t.targetVal),e}}const se={"2x3":{min:2,max:2},"2x4":{min:3,max:10},"2x5":{min:4,max:17},"2x6":{min:5,max:26},"2x7":{min:6,max:37},"2x8":{min:7,max:50},"2x9":{min:8,max:65},"2x10":{min:9,max:82},"3x3":{min:3,max:9},"3x4":{min:5,max:26},"3x5":{min:7,max:47},"3x6":{min:9,max:72},"3x7":{min:11,max:100},"3x8":{min:13,max:130},"3x9":{min:15,max:160},"3x10":{min:17,max:200},"4x3":{min:5,max:16},"4x4":{min:8,max:44},"4x5":{min:11,max:87},"4x6":{min:14,max:140},"4x7":{min:17,max:200},"4x8":{min:20,max:260},"4x9":{min:23,max:330},"4x10":{min:26,max:400},"5x3":{min:7,max:25},"5x4":{min:11,max:70},"5x5":{min:15,max:130},"5x6":{min:19,max:200},"5x7":{min:23,max:280},"5x8":{min:27,max:370},"5x9":{min:31,max:470},"5x10":{min:35,max:580}},oe=(f,t)=>{const e=`${f}x${t}`;if(se[e])return se[e];const i=(f-1)*t,s=Math.max(5,Math.floor(i*.7)),o=Math.floor(i*5);return{min:s,max:o}};function le(f){return function(){f|=0,f=f+1831565813|0;var t=Math.imul(f^f>>>15,1|f);return t=t+Math.imul(t^t>>>7,61|t)^t,((t^t>>>14)>>>0)/4294967296}}class W{constructor(t){this.solution={},this.valueMap=new Map,this.reverseSolution=new Map,this.seed=t,this.random=le(t),this.solver=new te}getClueCountBounds(t,e,i=10){let s=1/0,o=0;for(let l=0;l<i;l++){const n=this.seed+l+1,a=new W(n);try{const r=a.internalGenerate(t,e,"min");r&&(s=Math.min(s,r.clues.length))}catch{}try{const d=new W(n).internalGenerate(t,e,"max");d&&(o=Math.max(o,d.clues.length))}catch{}}return s===1/0&&(s=0),{min:s,max:o}}generatePuzzle(t,e,i={}){if(t.length<2)throw new D("Puzzle must have at least 2 categories.");const{targetClueCount:s,maxCandidates:o=50,timeoutMs:l=1e4}=i,n=e||this.generateRandomTarget(t);this.validateTarget(t,n);const a=i.constraints;if(a!=null&&a.allowedClueTypes){const r=a.allowedClueTypes,d=t.some(u=>u.type===B.ORDINAL),v=r.includes(g.ORDINAL),c=r.includes(g.CROSS_ORDINAL);if(v&&!d&&!r.includes(g.BINARY))throw new D("Invalid Constraints: Ordinal-based clue types were requested, but no Ordinal categories exist. Please add an ordinal category or allow Binary clues.");if(c&&t.filter(p=>p.type===B.ORDINAL).length<2)throw new D("Invalid Constraints: Cross-Ordinal clues require at least 2 Ordinal Categories.")}return this.internalGenerate(t,n,"standard",{maxCandidates:o,targetClueCount:s,timeoutMs:l,constraints:i.constraints,onTrace:i.onTrace})}validateTarget(t,e){const i=new Set(t.map(s=>s.id));if(!i.has(e.category1Id)||!i.has(e.category2Id))throw new D("Target fact refers to non-existent categories.");if(e.category1Id===e.category2Id)throw new D("Target fact must refer to two different categories.")}generateRandomTarget(t){const e=Math.floor(this.random()*t.length);let i=Math.floor(this.random()*t.length);for(;i===e;)i=Math.floor(this.random()*t.length);const s=t[e],o=t[i],l=Math.floor(this.random()*s.values.length);return{category1Id:s.id,value1:s.values[l],category2Id:o.id}}async generatePuzzleAsync(t,e,i={}){return new Promise((s,o)=>{setTimeout(()=>{try{const l=this.generatePuzzle(t,e,i);s(l)}catch(l){o(l)}},0)})}async getClueCountBoundsAsync(t,e,i=10){return new Promise((s,o)=>{setTimeout(()=>{try{const l=this.getClueCountBounds(t,e,i);s(l)}catch(l){o(l)}},0)})}startSession(t,e){if(t.length<2)throw new D("Must have at least 2 categories.");let i=e;if(!i){const n=Math.floor(this.random()*t.length);let a=Math.floor(this.random()*t.length);for(;a===n;)a=Math.floor(this.random()*t.length);const r=t[n],d=t[a],v=Math.floor(this.random()*r.values.length);i={category1Id:r.id,value1:r.values[v],category2Id:d.id}}const s=new Map,o={},l=new Map;return this.createSolution(t,s,o,l),new ae(this,t,o,l,s,i)}internalGenerate(t,e,i,s){if(!t||t.length<2)throw new D("At least 2 categories are required to generate a puzzle.");const o=(s==null?void 0:s.maxCandidates)??1/0,l=s==null?void 0:s.targetClueCount,n=s==null?void 0:s.constraints;s!=null&&s.onTrace&&s.onTrace("Generator: internalGenerate started.");const a=t.find(u=>u.id===e.category1Id);if(a&&!a.values.includes(e.value1))throw new D(`Target value '${e.value1}' does not exist in category '${e.category1Id}'.`);if(n!=null&&n.allowedClueTypes){const u=[g.BINARY,g.ORDINAL,g.CROSS_ORDINAL],p=n.allowedClueTypes.some(N=>u.includes(N));if(n.allowedClueTypes.length>0&&!p)throw new D("Invalid Constraints: The selected clue types are ambiguous on their own. Please allow at least one identity-resolving type (Binary, Ordinal, or Cross-Ordinal).");const m=t.filter(N=>N.type===B.ORDINAL),h=m.length,y=h>0,b=[g.ORDINAL,g.SUPERLATIVE,g.UNARY,g.CROSS_ORDINAL];if(n.allowedClueTypes.some(N=>b.includes(N))&&!y&&!n.allowedClueTypes.includes(g.BINARY))throw new D("Invalid Constraints: Ordinal-based clue types were requested, but no Ordinal categories exist. Please add an ordinal category or allow Binary clues.");if(n.allowedClueTypes.includes(g.CROSS_ORDINAL)&&h<2)throw new D("Invalid Constraints: Cross-Ordinal clues require at least two separate Ordinal categories.");if(n.allowedClueTypes.includes(g.UNARY)&&!m.some(x=>{const w=x.values.map(I=>Number(I)).filter(I=>!isNaN(I)),A=w.some(I=>I%2!==0),E=w.some(I=>I%2===0);return A&&E}))throw new D("Invalid Constraints: Unary clues (Even/Odd) require at least one Ordinal category to contain both odd and even values.")}for(const u of t)if(u.type===B.ORDINAL&&u.values.some(m=>typeof m!="number"&&isNaN(Number(m))))throw new D(`Category '${u.id}' is ORDINAL but contains non-numeric values.`);if(this.valueMap=new Map,this.solution={},this.reverseSolution=new Map,s!=null&&s.onTrace&&s.onTrace("Generator: Creating solution..."),this.createSolution(t,this.valueMap,this.solution,this.reverseSolution),s!=null&&s.onTrace&&s.onTrace("Generator: Solution created."),l!==void 0){const u=t.length,p=t[0].values.length,m=oe(u,p);s!=null&&s.onTrace&&s.onTrace(`Generator: Feasibility check complete. Recommended bounds: ${m.min}-${m.max}`);const h=0;let y=l;m.min>0&&l<m.min-h&&(console.warn(`Target clue count ${l} is too low (Estimated min: ${m.min}). Auto-adjusting to ${m.min}.`),y=m.min);try{return this.generateWithBacktracking(t,e,y,o,i,(s==null?void 0:s.timeoutMs)??1e4,s==null?void 0:s.constraints,s==null?void 0:s.onTrace)}catch(b){throw b}}s!=null&&s.onTrace&&s.onTrace("Generator: Generating all possible clues...");let r=this.generateAllPossibleClues(t,s==null?void 0:s.constraints,this.reverseSolution,this.valueMap);s!=null&&s.onTrace&&s.onTrace(`Generator: Generated ${r.length} candidate clues.`);const d=new H(t),v=[],c=100;for(;v.length<c;){if(s!=null&&s.onTrace){const x=v.length,w=d.getGridStats(),A=Math.max(1,w.totalPossible-w.solutionPossible),E=Math.max(0,w.currentPossible-w.solutionPossible),I=Math.min(100,Math.round((A-E)/A*100));if(s.onTrace(`Depth ${x}: ${I}% Solved. Candidates: ${r.length}`),I>=100&&this.isPuzzleSolved(d,this.solution,this.reverseSolution)){s.onTrace("Generator: Puzzle Solved (100%).");break}}let u=null,p=null;if(o<r.length)for(let x=r.length-1;x>0;x--){const w=Math.floor(this.random()*(x+1));[r[x],r[w]]=[r[w],r[x]]}const m=Math.min(r.length,o);let h=0;for(let x=r.length-1;x>=0&&!(h>=m);x--){const w=r[x],A=d.clone(),{deductions:E}=this.solver.applyClue(A,w);if(E===0){r.splice(x,1);continue}h++;let I=0;i==="min"?I=E*1e3:i==="max"?I=100/E:I=this.calculateClueScore(A,e,E,w,v.map(U=>U.clue),this.solution,this.reverseSolution),w.type;const k=this.solution[e.category2Id][e.value1],K=A.isPossible(e.category1Id,e.value1,e.category2Id,k)&&A.getPossibilitiesCount(e.category1Id,e.value1,e.category2Id)===1,J=this.isPuzzleSolved(A,this.solution,this.reverseSolution);K&&(J?p={clue:w,score:I+1e6}:I=-1e6),I>-999999&&(!u||I>u.score)&&(u={clue:w,score:I})}const y=p||u;if(!y)break;const b=y.clue,{deductions:R}=this.solver.applyClue(d,b);v.push({clue:b,deductions:R});const N=r.findIndex(x=>JSON.stringify(x)===JSON.stringify(b));if(N>-1&&r.splice(N,1),this.isPuzzleSolved(d,this.solution,this.reverseSolution))break}return{solution:this.solution,clues:v.map(u=>u.clue),proofChain:v,categories:t,targetFact:e}}generateWithBacktracking(t,e,i,s,o,l=1e4,n,a){const r=this.generateAllPossibleClues(t,n,this.reverseSolution,this.valueMap),d=new H(t);let v=0;const c=Date.now(),u=(m,h,y,b)=>{const x=1+(Date.now()-c)/l*3;if(a&&h.length%1===0){const C=h.length+1,T=m.getGridStats(),P=Math.round((T.totalPossible-T.currentPossible)/(T.totalPossible-T.solutionPossible)*100);Math.random()<.05&&a(`Depth ${C}/${i}: ${P}% Solved. Bias: ${x.toFixed(2)} (Backtracks: ${v})`)}if(this.isPuzzleSolved(m,this.solution,this.reverseSolution))return h.length===i?(a&&a(`SOLVED! Exact match at ${i} clues.`),h):null;if(h.length>=i)return null;const A=m.getGridStats(),E=(A.totalPossible-A.currentPossible)/(A.totalPossible-A.solutionPossible),I=h.length+1;let k=[];if(s<y.length)for(let C=y.length-1;C>0;C--){const T=Math.floor(this.random()*(C+1));[y[C],y[T]]=[y[T],y[C]]}const J=Math.max(1,Math.floor((b?3:s===1/0?50:s)/Math.pow(x,2))),U=Math.min(y.length,J);a&&Math.random()<.001&&a(`Pruning: Limit reduced to ${U} (Bias ${x.toFixed(1)})`);let S=0;for(let C=0;C<y.length&&!(S>=U);C++){const T=y[C],P=m.clone(),{deductions:V}=this.solver.applyClue(P,T);if(V===0||(S++,this.isPuzzleSolved(P,this.solution,this.reverseSolution)&&I<i))continue;let j=this.calculateClueScore(P,e,V,T,h.map(Y=>Y.clue),this.solution,this.reverseSolution);if(i){const Y=I/i,Q=(A.totalPossible-P.getGridStats().currentPossible)/(A.totalPossible-A.solutionPossible),$=Math.pow(Y,1.8),Z=Q-$;j-=Z*V*50}k.push({clue:T,deductions:V,score:j,grid:P,index:C})}let M=[],L,O;if(b){const C=b==="STALL";M=k.sort((T,P)=>{const V=T.deductions-P.deductions;return C?V:-V})}else k.sort((C,T)=>T.score-C.score),L=k[0];if(!b){if(O=k[0],i){const C=Math.pow(I/i,1.8);E>C?O=[...k].sort((P,V)=>P.deductions!==V.deductions?P.deductions-V.deductions:V.score-P.score)[0]:O=[...k].sort((P,V)=>P.deductions!==V.deductions?V.deductions-P.deductions:V.score-P.score)[0]}L&&M.push(L),O&&O!==L&&M.push(O);for(const C of k)C!==L&&C!==O&&M.push(C)}for(const C of M){const T=1+(Date.now()-c)/l*4;if(i&&h.length>4&&T>1.1&&!(!!b||C===L||C===O))break;const P=[...y];P.splice(C.index,1);const V=C===L,q=C===O&&C!==L;let j=b,Y="";if(!b&&q&&i){const $=E>I/i,Z=`(Prog ${E.toFixed(2)} vs Exp ${(I/i).toFixed(2)})`;j=$?"STALL":"SPEED",Y=$?`(Stalling - Weakest) ${Z}`:`(Speeding - Strongest) ${Z}`}else b&&(Y=`(Continued ${b})`);if(a&&(q||b||Math.random()<.05)){const $=b?`STICKY ${b}`:V?"Primary":q?"CORRECTION":"Rest";q?a(`[BACKTRACK] Depth ${h.length}: Primary Strategy Failed. Switching to ${Y}. Ded: ${C.deductions}`):b?Math.random()<.1&&a(`Depth ${h.length}: ${Math.round(E*100)}% Solved. Strategy: ${$}. Ded: ${C.deductions}`):a(`Depth ${h.length}: ${Math.round(E*100)}% Solved. Trying ${$} Cand. Ded: ${C.deductions}`)}const Q=u(C.grid,[...h,{clue:C.clue,deductions:C.deductions}],P,j);if(Q)return Q}return v++,null},p=u(d,[],[...r]);if(p)return{solution:this.solution,clues:p.map(h=>h.clue),proofChain:p,categories:t,targetFact:e};throw new D(`Could not generate puzzle with exactly ${i} clues within timeout.`)}createSolution(t,e,i,s){var l;const o=t[0];o.values.forEach(n=>{e.set(n,{[o.id]:n})});for(let n=1;n<t.length;n++){const a=t[n],r=[...a.values].sort(()=>this.random()-.5);let d=0;for(const v of o.values){const c=e.get(v);c&&(c[a.id]=r[d++])}}for(const n of t)i[n.id]={},s.set(n.id,new Map);for(const n of o.values){const a=e.get(n);if(a)for(const r in a)i[r][n]=a[r],(l=s.get(r))==null||l.set(a[r],n)}}generateAllPossibleClues(t,e,i,s){var n,a,r,d,v;const o=[];t[0];const l=c=>!(e!=null&&e.allowedClueTypes)||e.allowedClueTypes.includes(c);if(l(g.BINARY))for(const c of t)for(const u of c.values)for(const p of t){if(c.id>=p.id)continue;const m=(n=i.get(c.id))==null?void 0:n.get(u);if(!m)continue;const h=s.get(m);if(h)for(const y of p.values){const b=h[p.id];y===b?o.push({type:g.BINARY,operator:_.IS,cat1:c.id,val1:u,cat2:p.id,val2:y}):o.push({type:g.BINARY,operator:_.IS_NOT,cat1:c.id,val1:u,cat2:p.id,val2:y})}}for(const c of t.filter(u=>u.type===B.ORDINAL)){const u=[...c.values].sort((h,y)=>h-y),p=u[0],m=u[u.length-1];if(l(g.SUPERLATIVE)){for(const h of t)if(h.id!==c.id)for(const y of h.values){const b=(a=i.get(h.id))==null?void 0:a.get(y);if(!b)continue;const R=s.get(b);if(!R)continue;const N=R[c.id];N===p?o.push({type:g.SUPERLATIVE,operator:G.MIN,targetCat:h.id,targetVal:y,ordinalCat:c.id}):o.push({type:g.SUPERLATIVE,operator:G.NOT_MIN,targetCat:h.id,targetVal:y,ordinalCat:c.id}),N===m?o.push({type:g.SUPERLATIVE,operator:G.MAX,targetCat:h.id,targetVal:y,ordinalCat:c.id}):o.push({type:g.SUPERLATIVE,operator:G.NOT_MAX,targetCat:h.id,targetVal:y,ordinalCat:c.id})}}if(l(g.ORDINAL)){for(const h of t)if(h.id!==c.id){for(const y of t)if(y.id!==c.id)for(const b of h.values)for(const R of y.values){if(h.id===y.id&&b===R)continue;const N=(r=i.get(h.id))==null?void 0:r.get(b),x=(d=i.get(y.id))==null?void 0:d.get(R);if(!N||!x||N===x)continue;const w=s.get(N),A=s.get(x);if(!w||!A)continue;const E=w[c.id],I=A[c.id];E>I?(o.push({type:g.ORDINAL,operator:z.GREATER_THAN,item1Cat:h.id,item1Val:b,item2Cat:y.id,item2Val:R,ordinalCat:c.id}),o.push({type:g.ORDINAL,operator:z.NOT_LESS_THAN,item1Cat:h.id,item1Val:b,item2Cat:y.id,item2Val:R,ordinalCat:c.id})):E<I&&(o.push({type:g.ORDINAL,operator:z.LESS_THAN,item1Cat:h.id,item1Val:b,item2Cat:y.id,item2Val:R,ordinalCat:c.id}),o.push({type:g.ORDINAL,operator:z.NOT_GREATER_THAN,item1Cat:h.id,item1Val:b,item2Cat:y.id,item2Val:R,ordinalCat:c.id}))}}}}if(l(g.UNARY)){for(const c of t)if(c.type===B.ORDINAL&&c.values.every(u=>typeof u=="number")){for(const u of t)if(u.id!==c.id)for(const p of u.values){const m=(v=i.get(u.id))==null?void 0:v.get(p);if(!m)continue;const h=s.get(m);if(!h)continue;h[c.id]%2===0?o.push({type:g.UNARY,filter:X.IS_EVEN,targetCat:u.id,targetVal:p,ordinalCat:c.id}):o.push({type:g.UNARY,filter:X.IS_ODD,targetCat:u.id,targetVal:p,ordinalCat:c.id})}}}return o}calculateClueScore(t,e,i,s,o,l,n){var U;const a=s.type,r=(U=n.get(e.category1Id))==null?void 0:U.get(e.value1);let d;r!==void 0&&(d=l[e.category2Id][r]);const v=d!==void 0&&t.isPossible(e.category1Id,e.value1,e.category2Id,d)&&t.getPossibilitiesCount(e.category1Id,e.value1,e.category2Id)===1,c=this.isPuzzleSolved(t,l,n);if(s.type===g.BINARY&&s.operator===_.IS){const S=s;if(S.cat1===e.category1Id&&S.val1===e.value1&&S.cat2===e.category2Id&&S.val2===d||S.cat1===e.category2Id&&S.val1===d&&S.cat2===e.category1Id&&S.val2===e.value1)return-1/0}if(v&&c)return 1e6;if(v&&!c)return-1e6;const u=i,{totalPossible:p,currentPossible:m,solutionPossible:h}=t.getGridStats(),y=p-h,b=p-m,R=y>0?b/y:0;let N=0;switch(a){case g.ORDINAL:N=1.5,s.operator>=2&&(N=5);break;case g.SUPERLATIVE:N=1.2,s.operator>=2&&(N=5);break;case g.UNARY:N=1.2;break;case g.BINARY:N=1,s.operator===_.IS_NOT&&(N=5);break}let x=0;const w=S=>{const M=(C,T)=>{var P;return(P=this.reverseSolution.get(C))==null?void 0:P.get(T)};let L=[],O=[];switch(S.type){case g.BINARY:const C=S;L.push(M(C.cat1,C.val1)),C.operator===_.IS_NOT&&O.push(M(C.cat2,C.val2));break;case g.SUPERLATIVE:const T=S;L.push(M(T.targetCat,T.targetVal));break;case g.ORDINAL:const P=S;L.push(M(P.item1Cat,P.item1Val)),O.push(M(P.item2Cat,P.item2Val));break;case g.UNARY:const V=S;L.push(M(V.targetCat,V.targetVal));break}return{primary:L.filter(C=>!!C),secondary:O.filter(C=>!!C)}},A=new Set;for(const S of o){const{primary:M,secondary:L}=w(S);M.forEach(O=>A.add(O)),L.forEach(O=>A.add(O))}const{primary:E,secondary:I}=w(s);E.forEach(S=>{A.has(S)&&(x+=1)}),I.forEach(S=>{A.has(S)&&(x+=.5)});const k=s.ordinalCat;if(k)for(const S of o){const M=S.ordinalCat;k===M&&(x+=.5)}if(o.length>0){const S=o[o.length-1];if(s.type===S.type&&(x+=2,s.type===g.BINARY&&s.operator===_.IS&&S.operator===_.IS&&(x+=2)),o.length>1){const C=o[o.length-2];s.type===S.type&&s.type===C.type&&(x+=5)}const M=C=>{switch(C.type){case g.SUPERLATIVE:return 1;case g.BINARY:return C.operator===_.IS?1:3;case g.ORDINAL:return 3;case g.UNARY:return 3;case g.CROSS_ORDINAL:return 4;default:return 2}},L=M(s),O=M(S);L===O&&(x+=1.5)}const K=Math.pow(.4,x);return(u*N+R*5)*K}isPuzzleSolved(t,e,i){var o;const s=t.categories;s[0];for(const l of s)for(const n of l.values)for(const a of s){if(l.id>=a.id)continue;const r=(o=i.get(l.id))==null?void 0:o.get(n);if(!r)return!1;const d=e[a.id][r];if(t.getPossibilitiesCount(l.id,n,a.id)>1||!t.isPossible(l.id,n,a.id,d))return!1}return!0}}const F=self;F.onmessage=f=>{const{type:t}=f.data;if(t==="start"){const{categories:e,targetFact:i,options:s}=f.data;s&&s.targetClueCount&&(s.targetClueCount=parseInt(String(s.targetClueCount),10));try{const o=new W(s==null?void 0:s.seed),l={...s,onTrace:a=>{F.postMessage({type:"trace",message:a})}};let n;try{n=o.generatePuzzle(e,i,l)}catch(a){if(s.targetClueCount&&a.message&&a.message.includes("Could not generate puzzle")){F.postMessage({type:"trace",message:`⚠️ Strict generation failed (${a.message}). Falling back to best-effort generation...`});const r={...l,targetClueCount:void 0};n=o.generatePuzzle(e,i,r)}else throw a}F.postMessage({type:"done",puzzle:n})}catch(o){console.error("Worker Generation Error:",o),F.postMessage({type:"error",message:o.message||"Unknown worker error"})}}}})();
