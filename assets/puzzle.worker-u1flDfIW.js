(function(){"use strict";var B=(v=>(v[v.NOMINAL=0]="NOMINAL",v[v.ORDINAL=1]="ORDINAL",v))(B||{}),g=(v=>(v[v.BINARY=0]="BINARY",v[v.ORDINAL=1]="ORDINAL",v[v.SUPERLATIVE=2]="SUPERLATIVE",v[v.UNARY=3]="UNARY",v[v.CROSS_ORDINAL=4]="CROSS_ORDINAL",v))(g||{}),te=(v=>(v[v.MATCH=0]="MATCH",v[v.NOT_MATCH=1]="NOT_MATCH",v))(te||{}),k=(v=>(v[v.IS=0]="IS",v[v.IS_NOT=1]="IS_NOT",v))(k||{}),E=(v=>(v[v.GREATER_THAN=0]="GREATER_THAN",v[v.LESS_THAN=1]="LESS_THAN",v[v.NOT_GREATER_THAN=2]="NOT_GREATER_THAN",v[v.NOT_LESS_THAN=3]="NOT_LESS_THAN",v))(E||{}),z=(v=>(v[v.MIN=0]="MIN",v[v.MAX=1]="MAX",v[v.NOT_MIN=2]="NOT_MIN",v[v.NOT_MAX=3]="NOT_MAX",v))(z||{}),j=(v=>(v[v.IS_ODD=0]="IS_ODD",v[v.IS_EVEN=1]="IS_EVEN",v))(j||{});class se extends Error{constructor(t){super(t),this.name="LogicPuzzleError"}}class _ extends se{constructor(t){super(t),this.name="ConfigurationError"}}class Y{constructor(t){this.validateConfig(t),this.categories=t,this.valueMap=new Map(t.map(e=>[e.id,new Map(e.values.map((a,i)=>[a,i]))])),this.grid=new Map;for(const e of t){const a=new Map;for(const i of e.values){const l=new Map;for(const r of t)e.id!==r.id&&l.set(r.id,Array(r.values.length).fill(!0));a.set(i,l)}this.grid.set(e.id,a)}}validateConfig(t){const e=new Set;let a=-1;for(const i of t){if(e.has(i.id))throw new _(`Duplicate category ID found: ${i.id}`);if(e.add(i.id),new Set(i.values).size!==i.values.length)throw new _(`Category '${i.id}' has duplicate values.`);if(a===-1)a=i.values.length;else if(i.values.length!==a)throw new _(`Category '${i.id}' has ${i.values.length} values, expected ${a}. All categories must be the same size.`)}}setPossibility(t,e,a,i,l){var o,s;const r=(o=this.valueMap.get(a))==null?void 0:o.get(i);if(r!==void 0){const d=this.grid.get(t);if(d){const u=d.get(e);if(u){const c=u.get(a);c&&(c[r]=l)}}}const n=(s=this.valueMap.get(t))==null?void 0:s.get(e);if(n!==void 0){const d=this.grid.get(a);if(d){const u=d.get(i);if(u){const c=u.get(t);c&&(c[n]=l)}}}}isPossible(t,e,a,i){var s;if(t===a)return e===i;const l=(s=this.valueMap.get(a))==null?void 0:s.get(i);if(l===void 0)return!1;const r=this.grid.get(t);if(!r)return!1;const n=r.get(e);if(!n)return!1;const o=n.get(a);return o?o[l]:!1}getPossibilitiesCount(t,e,a){var l,r;const i=(r=(l=this.grid.get(t))==null?void 0:l.get(e))==null?void 0:r.get(a);return i?i.filter(n=>n).length:0}getGridStats(){var n,o,s;let t=0;const e=this.categories.length,a=((n=this.categories[0])==null?void 0:n.values.length)||0;if(a===0||e<2)return{totalPossible:0,currentPossible:0,solutionPossible:0};const i=e*(e-1)/2,l=i*a*a,r=i*a;for(const d of this.categories)for(const u of d.values)for(const c of this.categories){if(d.id>=c.id)continue;const m=(s=(o=this.grid.get(d.id))==null?void 0:o.get(u))==null?void 0:s.get(c.id);m&&(t+=m.filter(h=>h).length)}return{totalPossible:l,currentPossible:t,solutionPossible:r}}clone(){const t=new Y(this.categories);return t.grid=new Map([...this.grid.entries()].map(([e,a])=>[e,new Map([...a.entries()].map(([i,l])=>[i,new Map([...l.entries()].map(([r,n])=>[r,[...n]]))]))])),t}compareVisualState(t){var i,l;let e=0;const a=this.categories;for(const r of a)for(const n of r.values)for(const o of a){if(r.id>=o.id)continue;const s=(i=this.grid.get(r.id))==null?void 0:i.get(n),d=(l=t.grid.get(r.id))==null?void 0:l.get(n);if(s&&d){const m=s.get(o.id),h=d.get(o.id);if(m&&h)for(let y=0;y<m.length;y++)h[y]&&!m[y]&&e++}const u=t.getPossibilitiesCount(r.id,n,o.id),c=this.getPossibilitiesCount(r.id,n,o.id);u>1&&c===1&&e++}return e}}class ee{applyClue(t,e){let a=0;const i=[];switch(e.type){case g.BINARY:a+=this.applyBinaryClue(t,e,i);break;case g.SUPERLATIVE:a+=this.applySuperlativeClue(t,e,i);break;case g.ORDINAL:a+=this.applyOrdinalClue(t,e,i);break;case g.UNARY:a+=this.applyUnaryClue(t,e,i);break;case g.CROSS_ORDINAL:a+=this.applyCrossOrdinalClue(t,e,i);break}let l;do l=this.runDeductionLoop(t,i),a+=l;while(l>0);return{grid:t,deductions:a,reasons:i}}applyCrossOrdinalClue(t,e,a){let i=0;const l=t.categories,r=l.find(c=>c.id===e.ordinal1),n=l.find(c=>c.id===e.ordinal2);if(!r||!n)return 0;const o=e.operator===te.NOT_MATCH,s=(c,m,h,y)=>y.values.map((f,p)=>({val:f,idx:p})).filter(f=>t.isPossible(c,m,h,f.val)),d=s(e.item1Cat,e.item1Val,e.ordinal1,r),u=s(e.item2Cat,e.item2Val,e.ordinal2,n);if(o){if(d.length===1&&u.length===1){const c=d[0].idx+e.offset1,m=u[0].idx+e.offset2,h=r.values[c],y=n.values[m];h!==void 0&&y!==void 0&&t.isPossible(e.ordinal1,h,e.ordinal2,y)&&(t.setPossibility(e.ordinal1,h,e.ordinal2,y,!1),i++,a.push({type:"cross_ordinal",description:`Cross-Ordinal NOT: ${h} cannot be ${y} because positions are forbidden.`,cells:[{cat:e.ordinal1,val:h},{cat:e.ordinal2,val:y}]}))}for(const c of d){const m=c.idx+e.offset1;if(r.values[m]!==void 0)for(const y of u){const f=y.idx+e.offset2;n.values[f]}}if(d.length===1){const c=d[0].idx+e.offset1,m=r.values[c];if(m!==void 0)for(const h of u){const y=h.idx+e.offset2,f=n.values[y];f!==void 0&&t.isPossible(e.ordinal1,m,e.ordinal2,f)&&(t.setPossibility(e.item2Cat,e.item2Val,e.ordinal2,h.val,!1),i++,a.push({type:"cross_ordinal",description:`Cross-Ordinal NOT: ${e.item2Val} cannot be ${h.val} because it implies forbidden link to ${m}.`,cells:[{cat:e.item2Cat,val:e.item2Val},{cat:e.ordinal2,val:h.val}]}))}}if(u.length===1){const c=u[0].idx+e.offset2,m=n.values[c];if(m!==void 0)for(const h of d){const y=h.idx+e.offset1,f=r.values[y];f!==void 0&&t.isPossible(e.ordinal1,f,e.ordinal2,m)&&(t.setPossibility(e.item1Cat,e.item1Val,e.ordinal1,h.val,!1),i++,a.push({type:"cross_ordinal",description:`Cross-Ordinal NOT: ${e.item1Val} cannot be ${h.val} because it implies forbidden link to ${m}.`,cells:[{cat:e.item1Cat,val:e.item1Val},{cat:e.ordinal1,val:h.val}]}))}}}else{for(const h of d){const y=h.idx+e.offset1,f=r.values[y];if(f===void 0){t.setPossibility(e.item1Cat,e.item1Val,e.ordinal1,h.val,!1),i++,a.push({type:"cross_ordinal",description:`Cross-Ordinal: ${e.item1Val} cannot be ${h.val} because offset ${e.offset1} goes out of bounds.`,cells:[{cat:e.item1Cat,val:e.item1Val},{cat:e.ordinal1,val:h.val}]});continue}let p=!1;for(const C of u){const I=C.idx+e.offset2,S=n.values[I];if(S!==void 0&&t.isPossible(e.ordinal1,f,e.ordinal2,S)){p=!0;break}}p||(t.setPossibility(e.item1Cat,e.item1Val,e.ordinal1,h.val,!1),i++,a.push({type:"cross_ordinal",description:`Cross-Ordinal: ${e.item1Val} as ${h.val} finds no compatible ${e.item2Val} at offset pair.`,cells:[{cat:e.item1Cat,val:e.item1Val},{cat:e.ordinal1,val:h.val}]}))}for(const h of u){const y=h.idx+e.offset2,f=n.values[y];if(f===void 0){t.setPossibility(e.item2Cat,e.item2Val,e.ordinal2,h.val,!1),i++,a.push({type:"cross_ordinal",description:`Cross-Ordinal: ${e.item2Val} cannot be ${h.val} because offset ${e.offset2} goes out of bounds.`,cells:[{cat:e.item2Cat,val:e.item2Val},{cat:e.ordinal1,val:h.val}]});continue}let p=!1;for(const C of d){const I=C.idx+e.offset1,S=r.values[I];if(S!==void 0&&t.isPossible(e.ordinal1,S,e.ordinal2,f)){p=!0;break}}p||(t.setPossibility(e.item2Cat,e.item2Val,e.ordinal2,h.val,!1),i++,a.push({type:"cross_ordinal",description:`Cross-Ordinal: ${e.item2Val} as ${h.val} finds no compatible ${e.item1Val} at offset pair.`,cells:[{cat:e.item2Cat,val:e.item2Val},{cat:e.ordinal2,val:h.val}]}))}const c=s(e.item1Cat,e.item1Val,e.ordinal1,r),m=s(e.item2Cat,e.item2Val,e.ordinal2,n);if(c.length===1&&m.length===1){const h=c[0].idx+e.offset1,y=m[0].idx+e.offset2,f=r.values[h],p=n.values[y];f!==void 0&&p!==void 0&&t.getPossibilitiesCount(e.ordinal1,f,e.ordinal2)>1&&(t.setPossibility(e.ordinal1,f,e.ordinal2,p,!0),i++,a.push({type:"cross_ordinal",description:`Cross-Ordinal Link: ${f} must be ${p} based on forced offsets.`,cells:[{cat:e.ordinal1,val:f},{cat:e.ordinal2,val:p}]}))}}return i}applyUnaryClue(t,e,a){let i=0;const r=t.categories.find(o=>o.id===e.ordinalCat);if(!r||r.type!==B.ORDINAL||!r.values.every(o=>typeof o=="number"))return 0;const n=e.filter===j.IS_EVEN;for(const o of r.values){const s=o;(n?s%2!==0:s%2===0)&&t.isPossible(e.targetCat,e.targetVal,e.ordinalCat,o)&&(t.setPossibility(e.targetCat,e.targetVal,e.ordinalCat,o,!1),i++,a.push({type:"unary",description:`Unary Rule: ${o} eliminated for ${e.targetVal} because it is ${n?"not even":"not odd"}.`,cells:[{cat:e.targetCat,val:e.targetVal},{cat:e.ordinalCat,val:String(o)}]}))}return i}applyBinaryClue(t,e,a){let i=0;const l=t.categories,r=l.find(o=>o.id===e.cat1),n=l.find(o=>o.id===e.cat2);if(!r||!n)return 0;if(e.operator===k.IS){t.getPossibilitiesCount(e.cat1,e.val1,e.cat2)>1&&(i++,a.push({type:"confirmation",description:`Directly from clue: ${e.val1} is ${e.val2}.`,cells:[{cat:e.cat1,val:e.val1},{cat:e.cat2,val:e.val2}]})),t.isPossible(e.cat1,e.val1,e.cat2,e.val2),t.setPossibility(e.cat1,e.val1,e.cat2,e.val2,!0);for(const o of n.values)o!==e.val2&&t.isPossible(e.cat1,e.val1,e.cat2,o)&&(t.setPossibility(e.cat1,e.val1,e.cat2,o,!1),i++,a.push({type:"elimination",description:`Since ${e.val1} is ${e.val2}, it cannot be ${o}.`,cells:[{cat:e.cat1,val:e.val1},{cat:e.cat2,val:o}]}));for(const o of r.values)o!==e.val1&&t.isPossible(e.cat1,o,e.cat2,e.val2)&&(t.setPossibility(e.cat1,o,e.cat2,e.val2,!1),i++,a.push({type:"elimination",description:`Since ${e.val2} is ${e.val1}, it cannot be ${o}.`,cells:[{cat:e.cat1,val:o},{cat:e.cat2,val:e.val2}]}))}else t.isPossible(e.cat1,e.val1,e.cat2,e.val2)&&(t.setPossibility(e.cat1,e.val1,e.cat2,e.val2,!1),i++,a.push({type:"elimination",description:`Directly from clue: ${e.val1} is NOT ${e.val2}.`,cells:[{cat:e.cat1,val:e.val1},{cat:e.cat2,val:e.val2}]}));return i}runDeductionLoop(t,e){let a=0;const i=t.categories;for(const l of i)for(const r of l.values)for(const n of i){if(l.id===n.id)continue;const o=n.values.filter(s=>t.isPossible(l.id,r,n.id,s));if(o.length===1){const s=o[0];for(const d of l.values)d!==r&&t.isPossible(l.id,d,n.id,s)&&(t.setPossibility(l.id,d,n.id,s,!1),a++,e.push({type:"uniqueness",description:`Since ${s} is uniquely ${r} in ${l.id}, it cannot be ${d}.`,cells:[{cat:l.id,val:r},{cat:n.id,val:s},{cat:l.id,val:d}]}))}for(const s of i){if(l.id===s.id||n.id===s.id)continue;const d=o.length===1?o[0]:null;if(d){const u=s.values.filter(c=>t.isPossible(n.id,d,s.id,c));if(u.length===1){const c=u[0];t.isPossible(l.id,r,s.id,c)===!1||t.getPossibilitiesCount(l.id,r,s.id)>1&&(t.setPossibility(l.id,r,s.id,c,!0),a++,e.push({type:"transitivity",description:`Since ${l.id}:${r} is ${n.id}:${d}, and that is ${s.id}:${c}, ${r} must be ${c}.`,cells:[{cat:l.id,val:r},{cat:n.id,val:d},{cat:s.id,val:c}]}))}}for(const u of s.values)t.isPossible(l.id,r,s.id,u)&&(n.values.some(m=>t.isPossible(l.id,r,n.id,m)&&t.isPossible(n.id,m,s.id,u))||(t.setPossibility(l.id,r,s.id,u,!1),a++,e.push({type:"transitivity",description:`Negative Transitivity: No path exists between ${r} and ${u} via ${n.id}.`,cells:[{cat:l.id,val:r},{cat:s.id,val:u}]})))}}return a}applyOrdinalClue(t,e,a){let i=0;const r=t.categories.find(s=>s.id===e.ordinalCat);if(!r||r.type!==B.ORDINAL)return 0;const n=r.values.map((s,d)=>({val:s,idx:d})).filter(s=>t.isPossible(e.item1Cat,e.item1Val,e.ordinalCat,s.val)),o=r.values.map((s,d)=>({val:s,idx:d})).filter(s=>t.isPossible(e.item2Cat,e.item2Val,e.ordinalCat,s.val));if(n.length===0||o.length===0)return 0;if(e.operator===E.GREATER_THAN)for(const s of n)o.some(u=>s.idx>u.idx)||t.isPossible(e.item1Cat,e.item1Val,e.ordinalCat,s.val)&&(t.setPossibility(e.item1Cat,e.item1Val,e.ordinalCat,s.val,!1),i++,a.push({type:"ordinal",description:`${e.item1Val} cannot be ${s.val} (idx ${s.idx}) because it must be > ${e.item2Val}.`,cells:[{cat:e.item1Cat,val:e.item1Val},{cat:e.ordinalCat,val:s.val}]}));else if(e.operator===E.LESS_THAN)for(const s of n)o.some(u=>s.idx<u.idx)||t.isPossible(e.item1Cat,e.item1Val,e.ordinalCat,s.val)&&(t.setPossibility(e.item1Cat,e.item1Val,e.ordinalCat,s.val,!1),i++,a.push({type:"ordinal",description:`${e.item1Val} cannot be ${s.val} (idx ${s.idx}) because it must be < ${e.item2Val}.`,cells:[{cat:e.item1Cat,val:e.item1Val},{cat:e.ordinalCat,val:s.val}]}));else if(e.operator===E.NOT_GREATER_THAN)for(const s of n)o.some(u=>s.idx<=u.idx)||t.isPossible(e.item1Cat,e.item1Val,e.ordinalCat,s.val)&&(t.setPossibility(e.item1Cat,e.item1Val,e.ordinalCat,s.val,!1),i++,a.push({type:"ordinal",description:`${e.item1Val} cannot be ${s.val} (idx ${s.idx}) because it must be <= ${e.item2Val}.`,cells:[{cat:e.item1Cat,val:e.item1Val},{cat:e.ordinalCat,val:s.val}]}));else if(e.operator===E.NOT_LESS_THAN)for(const s of n)o.some(u=>s.idx>=u.idx)||t.isPossible(e.item1Cat,e.item1Val,e.ordinalCat,s.val)&&(t.setPossibility(e.item1Cat,e.item1Val,e.ordinalCat,s.val,!1),i++,a.push({type:"ordinal",description:`${e.item1Val} cannot be ${s.val} (idx ${s.idx}) because it must be >= ${e.item2Val}.`,cells:[{cat:e.item1Cat,val:e.item1Val},{cat:e.ordinalCat,val:s.val}]}));if(e.operator===E.GREATER_THAN)for(const s of o)n.some(u=>s.idx<u.idx)||t.isPossible(e.item2Cat,e.item2Val,e.ordinalCat,s.val)&&(t.setPossibility(e.item2Cat,e.item2Val,e.ordinalCat,s.val,!1),i++,a.push({type:"ordinal",description:`${e.item2Val} cannot be ${s.val} (idx ${s.idx}) because it must be < ${e.item1Val}.`,cells:[{cat:e.item2Cat,val:e.item2Val},{cat:e.ordinalCat,val:s.val}]}));else if(e.operator===E.LESS_THAN)for(const s of o)n.some(u=>s.idx>u.idx)||t.isPossible(e.item2Cat,e.item2Val,e.ordinalCat,s.val)&&(t.setPossibility(e.item2Cat,e.item2Val,e.ordinalCat,s.val,!1),i++,a.push({type:"ordinal",description:`${e.item2Val} cannot be ${s.val} (idx ${s.idx}) because it must be > ${e.item1Val}.`,cells:[{cat:e.item2Cat,val:e.item2Val},{cat:e.ordinalCat,val:s.val}]}));else if(e.operator===E.NOT_GREATER_THAN)for(const s of o)n.some(u=>s.idx>=u.idx)||t.isPossible(e.item2Cat,e.item2Val,e.ordinalCat,s.val)&&(t.setPossibility(e.item2Cat,e.item2Val,e.ordinalCat,s.val,!1),i++,a.push({type:"ordinal",description:`${e.item2Val} cannot be ${s.val} (idx ${s.idx}) because it must be >= ${e.item1Val}.`,cells:[{cat:e.item2Cat,val:e.item2Val},{cat:e.ordinalCat,val:s.val}]}));else if(e.operator===E.NOT_LESS_THAN)for(const s of o)n.some(u=>s.idx<=u.idx)||t.isPossible(e.item2Cat,e.item2Val,e.ordinalCat,s.val)&&(t.setPossibility(e.item2Cat,e.item2Val,e.ordinalCat,s.val,!1),i++,a.push({type:"ordinal",description:`${e.item2Val} cannot be ${s.val} (idx ${s.idx}) because it must be <= ${e.item1Val}.`,cells:[{cat:e.item2Cat,val:e.item2Val},{cat:e.ordinalCat,val:s.val}]}));return i}applySuperlativeClue(t,e,a){const l=t.categories.find(s=>s.id===e.ordinalCat);if(!l||l.type!==B.ORDINAL)return 0;let r,n=!1;switch(e.operator){case z.MAX:r=l.values[l.values.length-1];break;case z.MIN:r=l.values[0];break;case z.NOT_MAX:r=l.values[l.values.length-1],n=!0;break;case z.NOT_MIN:r=l.values[0],n=!0;break;default:return 0}const o={type:g.BINARY,cat1:e.targetCat,val1:e.targetVal,cat2:e.ordinalCat,val2:r,operator:n?k.IS_NOT:k.IS};return this.applyBinaryClue(t,o,a)}}class ae{constructor(t,e,a,i,l,r){this.generator=t,this.categories=e,this.solution=a,this.reverseSolution=i,this.valueMap=l,this.targetFact=r,this.availableClues=[],this.proofChain=[],this.targetSolvedStepIndex=-1,this.historyStack=[],this.grid=new Y(e),this.solver=new ee,this.checkTargetSolved(),this.availableClues=this.generator.generateAllPossibleClues(e,void 0,i,l)}getTotalClueCount(){return this.availableClues.length}getTargetSolvedStepIndex(){return this.targetSolvedStepIndex}getMatchingClueCount(t){return this.filterClues(t).length}getMatchingClues(t,e=50){return this.filterClues(t).slice(0,e)}getScoredMatchingClues(t,e=50){const a=this.filterClues(t),i=[],l=(t==null?void 0:t.minDeductions)??0,r=t==null?void 0:t.maxDeductions;if(r!==void 0&&l>r)throw new _(`Invalid constraints: minDeductions (${l}) cannot be greater than maxDeductions (${r}).`);for(const n of a){const o=this.grid.clone(),{deductions:s}=this.solver.applyClue(o,n);if(s<l||r!==void 0&&s>r)continue;const d=this.generator.calculateClueScore(this.grid,this.targetFact,s,n,this.proofChain,this.solution,this.reverseSolution);let u=!1;if(n.type===g.BINARY&&n.operator===k.IS){const C=n,I=C.cat1===this.targetFact.category1Id&&C.val1===this.targetFact.value1&&C.cat2===this.targetFact.category2Id,S=C.cat2===this.targetFact.category1Id&&C.val2===this.targetFact.value1&&C.cat1===this.targetFact.category2Id;(I||S)&&(u=!0)}const c=o.getGridStats(),m=c.totalPossible-c.solutionPossible,h=c.totalPossible-c.currentPossible;let y=0;m>0?y=Math.min(100,Math.max(0,h/m*100)):y=100;const f=o.compareVisualState(this.grid);i.push({clue:n,score:d,deductions:s,updates:f,isDirectAnswer:u,percentComplete:y})}return i.sort((n,o)=>o.score-n.score).slice(0,e)}useClue(t){if(!this.generator.checkClueConsistency(t,this.solution,this.reverseSolution,this.valueMap))throw new Error("Invalid Clue: This clue contradicts the puzzle solution.");return this.applyAndSave(t),{remaining:this.availableClues.length,solved:this.generator.isPuzzleSolved(this.grid,this.solution,this.reverseSolution)}}filterClues(t){return this.availableClues.filter(e=>{if(t!=null&&t.allowedClueTypes&&!t.allowedClueTypes.includes(e.type))return!1;if(t!=null&&t.includeSubjects&&(t!=null&&t.excludeSubjects)){const a=t.includeSubjects.filter(i=>t.excludeSubjects.includes(i));if(a.length>0)throw new Error(`Constraint Error: The following subjects are both included and excluded: ${a.join(", ")}`)}if(t!=null&&t.includeSubjects||t!=null&&t.excludeSubjects){const a=this.extractValuesFromClue(e);if(t.includeSubjects&&!t.includeSubjects.some(l=>a.includes(l))||t.excludeSubjects&&t.excludeSubjects.some(l=>a.includes(l)))return!1}return!0})}applyAndSave(t){this.historyStack.push(this.grid.clone());const e=this.solver.applyClue(this.grid,t);t.deductions=e.deductions,t.reasons=e.reasons;const a=this.grid.getGridStats(),i=a.totalPossible-a.solutionPossible,l=a.totalPossible-a.currentPossible;i>0?t.percentComplete=Math.min(100,Math.max(0,l/i*100)):t.percentComplete=100;const r=this.historyStack[this.historyStack.length-1];r?t.updates=this.grid.compareVisualState(r):t.updates=t.deductions,this.proofChain.push(t),this.targetSolvedStepIndex===-1&&this.checkTargetSolvedInternal()&&(this.targetSolvedStepIndex=this.proofChain.length-1);const n=this.availableClues.indexOf(t);n>-1&&this.availableClues.splice(n,1)}checkTargetSolvedInternal(){return this.grid.getPossibilitiesCount(this.targetFact.category1Id,this.targetFact.value1,this.targetFact.category2Id)===1}checkTargetSolved(){this.checkTargetSolvedInternal()}getNextClue(t){const e=this.filterClues(t);let a=null,i=-1/0;const l=[...e].sort(()=>Math.random()-.5),r=50;let n=0;const o=(t==null?void 0:t.minDeductions)??0,s=t==null?void 0:t.maxDeductions;if(s!==void 0&&o>s)throw new _(`Invalid constraints: minDeductions (${o}) cannot be greater than maxDeductions (${s}).`);for(const d of l){if(n++,n>r&&a)break;const u=this.grid.clone(),{deductions:c}=this.solver.applyClue(u,d);if(c<o||s!==void 0&&c>s)continue;const m=this.generator.calculateClueScore(this.grid,this.targetFact,c,d,this.proofChain,this.solution,this.reverseSolution),h=u.getGridStats();h.totalPossible-h.solutionPossible,h.totalPossible-h.currentPossible,m>i&&(i=m,a=d)}return a?(this.applyAndSave(a),{clue:a,remaining:this.availableClues.length,solved:this.generator.isPuzzleSolved(this.grid,this.solution,this.reverseSolution)}):{clue:null,remaining:e.length,solved:this.generator.isPuzzleSolved(this.grid,this.solution,this.reverseSolution)}}async getNextClueAsync(t){return new Promise((e,a)=>{setTimeout(()=>{try{const i=this.getNextClue(t);e(i)}catch(i){a(i)}},0)})}rollbackLastClue(){if(this.historyStack.length===0)return{success:!1,clue:null};const t=this.historyStack.pop();t&&(this.grid=t);const e=this.proofChain.pop();return e?(this.availableClues.push(e),{success:!0,clue:e}):{success:!1,clue:null}}isUseful(t){return!0}removeClueAt(t){if(t<0||t>=this.proofChain.length)return!1;const e=this.proofChain[t];return this.proofChain.splice(t,1),this.availableClues.push(e),this.replayProofChain()}moveClue(t,e){if(t<0||t>=this.proofChain.length||e<0||e>=this.proofChain.length)return!1;if(t===e)return!0;const a=this.proofChain[t];return this.proofChain.splice(t,1),this.proofChain.splice(e,0,a),this.replayProofChain()}replayProofChain(){this.grid=new Y(this.categories),this.historyStack=[],this.solver=new ee,this.targetSolvedStepIndex=-1,this.checkTargetSolvedInternal(),this.availableClues.push(...this.proofChain);const t=[...this.proofChain];this.proofChain=[];for(const e of t)this.applyAndSave(e);return!0}getGrid(){return this.grid}getProofChain(){return this.proofChain}getSolution(){return this.solution}getValueMap(){return this.valueMap}extractValuesFromClue(t){const e=[],a=i=>{i!==void 0&&e.push(String(i))};return a(t.val1),a(t.val2),a(t.item1Val),a(t.item2Val),a(t.targetVal),e}}const ie={"2x3":{min:2,max:2},"2x4":{min:3,max:10},"2x5":{min:4,max:17},"2x6":{min:5,max:26},"2x7":{min:6,max:37},"2x8":{min:7,max:50},"2x9":{min:8,max:65},"2x10":{min:9,max:82},"3x3":{min:3,max:9},"3x4":{min:5,max:26},"3x5":{min:7,max:47},"3x6":{min:9,max:72},"3x7":{min:11,max:100},"3x8":{min:13,max:130},"3x9":{min:15,max:160},"3x10":{min:17,max:200},"4x3":{min:5,max:16},"4x4":{min:8,max:44},"4x5":{min:11,max:87},"4x6":{min:14,max:140},"4x7":{min:17,max:200},"4x8":{min:20,max:260},"4x9":{min:23,max:330},"4x10":{min:26,max:400},"5x3":{min:7,max:25},"5x4":{min:11,max:70},"5x5":{min:15,max:130},"5x6":{min:19,max:200},"5x7":{min:23,max:280},"5x8":{min:27,max:370},"5x9":{min:31,max:470},"5x10":{min:35,max:580}},oe=(v,t)=>{const e=`${v}x${t}`;if(ie[e])return ie[e];const a=(v-1)*t,i=Math.max(5,Math.floor(a*.7)),l=Math.floor(a*5);return{min:i,max:l}};function le(v){return function(){v|=0,v=v+1831565813|0;var t=Math.imul(v^v>>>15,1|v);return t=t+Math.imul(t^t>>>7,61|t)^t,((t^t>>>14)>>>0)/4294967296}}class J{constructor(t){this.solution={},this.valueMap=new Map,this.reverseSolution=new Map,this.seed=t,this.random=le(t),this.solver=new ee}getClueCountBounds(t,e,a=10){let i=1/0,l=0;for(let r=0;r<a;r++){const n=this.seed+r+1,o=new J(n);try{const s=o.internalGenerate(t,e,"min");s&&(i=Math.min(i,s.clues.length))}catch{}try{const d=new J(n).internalGenerate(t,e,"max");d&&(l=Math.max(l,d.clues.length))}catch{}}return i===1/0&&(i=0),{min:i,max:l}}generatePuzzle(t,e,a={}){if(t.length<2)throw new _("Puzzle must have at least 2 categories.");const{targetClueCount:i,maxCandidates:l=50,timeoutMs:r=1e4}=a,n=e||this.generateRandomTarget(t);this.validateTarget(t,n);const o=a.constraints;if(o!=null&&o.allowedClueTypes){const s=o.allowedClueTypes,d=t.some(m=>m.type===B.ORDINAL),u=s.includes(g.ORDINAL),c=s.includes(g.CROSS_ORDINAL);if(u&&!d&&!s.includes(g.BINARY))throw new _("Invalid Constraints: Ordinal-based clue types were requested, but no Ordinal categories exist. Please add an ordinal category or allow Binary clues.");if(c&&t.filter(h=>h.type===B.ORDINAL).length<2)throw new _("Invalid Constraints: Cross-Ordinal clues require at least 2 Ordinal Categories.")}return this.internalGenerate(t,n,"standard",{maxCandidates:l,targetClueCount:i,timeoutMs:r,constraints:a.constraints,onTrace:a.onTrace})}validateTarget(t,e){const a=new Set(t.map(i=>i.id));if(!a.has(e.category1Id)||!a.has(e.category2Id))throw new _("Target fact refers to non-existent categories.");if(e.category1Id===e.category2Id)throw new _("Target fact must refer to two different categories.")}generateRandomTarget(t){const e=Math.floor(this.random()*t.length);let a=Math.floor(this.random()*t.length);for(;a===e;)a=Math.floor(this.random()*t.length);const i=t[e],l=t[a],r=Math.floor(this.random()*i.values.length);return{category1Id:i.id,value1:i.values[r],category2Id:l.id}}async generatePuzzleAsync(t,e,a={}){return new Promise((i,l)=>{setTimeout(()=>{try{const r=this.generatePuzzle(t,e,a);i(r)}catch(r){l(r)}},0)})}async getClueCountBoundsAsync(t,e,a=10){return new Promise((i,l)=>{setTimeout(()=>{try{const r=this.getClueCountBounds(t,e,a);i(r)}catch(r){l(r)}},0)})}startSession(t,e){if(t.length<2)throw new _("Must have at least 2 categories.");let a=e;if(!a){const n=Math.floor(this.random()*t.length);let o=Math.floor(this.random()*t.length);for(;o===n;)o=Math.floor(this.random()*t.length);const s=t[n],d=t[o],u=Math.floor(this.random()*s.values.length);a={category1Id:s.id,value1:s.values[u],category2Id:d.id}}const i=new Map,l={},r=new Map;return this.createSolution(t,i,l,r),new ae(this,t,l,r,i,a)}internalGenerate(t,e,a,i){if(!t||t.length<2)throw new _("At least 2 categories are required to generate a puzzle.");const l=(i==null?void 0:i.maxCandidates)??1/0,r=i==null?void 0:i.targetClueCount,n=i==null?void 0:i.constraints;i!=null&&i.onTrace&&i.onTrace("Generator: internalGenerate started.");const o=t.find(f=>f.id===e.category1Id);if(o&&!o.values.includes(e.value1))throw new _(`Target value '${e.value1}' does not exist in category '${e.category1Id}'.`);if(n!=null&&n.allowedClueTypes){const f=[g.BINARY,g.ORDINAL,g.CROSS_ORDINAL],p=n.allowedClueTypes.some(T=>f.includes(T));if(n.allowedClueTypes.length>0&&!p)throw new _("Invalid Constraints: The selected clue types are ambiguous on their own. Please allow at least one identity-resolving type (Binary, Ordinal, or Cross-Ordinal).");const C=t.filter(T=>T.type===B.ORDINAL),I=C.length,S=I>0,A=[g.ORDINAL,g.SUPERLATIVE,g.UNARY,g.CROSS_ORDINAL];if(n.allowedClueTypes.some(T=>A.includes(T))&&!S&&!n.allowedClueTypes.includes(g.BINARY))throw new _("Invalid Constraints: Ordinal-based clue types were requested, but no Ordinal categories exist. Please add an ordinal category or allow Binary clues.");if(n.allowedClueTypes.includes(g.CROSS_ORDINAL)&&I<2)throw new _("Invalid Constraints: Cross-Ordinal clues require at least two separate Ordinal categories.");if(n.allowedClueTypes.includes(g.UNARY)&&!C.some(N=>{const V=N.values.map(R=>Number(R)).filter(R=>!isNaN(R)),$=V.some(R=>R%2!==0),G=V.some(R=>R%2===0);return $&&G}))throw new _("Invalid Constraints: Unary clues (Even/Odd) require at least one Ordinal category to contain both odd and even values.")}for(const f of t)if(f.type===B.ORDINAL&&f.values.some(C=>typeof C!="number"&&isNaN(Number(C))))throw new _(`Category '${f.id}' is ORDINAL but contains non-numeric values.`);if(this.valueMap=new Map,this.solution={},this.reverseSolution=new Map,i!=null&&i.onTrace&&i.onTrace("Generator: Creating solution..."),this.createSolution(t,this.valueMap,this.solution,this.reverseSolution),i!=null&&i.onTrace&&i.onTrace("Generator: Solution created."),r!==void 0){const f=t.length,p=t[0].values.length,C=oe(f,p);i!=null&&i.onTrace&&i.onTrace(`Generator: Feasibility check complete. Recommended bounds: ${C.min}-${C.max}`);const I=0;let S=r;C.min>0&&r<C.min-I&&(console.warn(`Target clue count ${r} is too low (Estimated min: ${C.min}). Auto-adjusting to ${C.min}.`),S=C.min);try{return this.generateWithBacktracking(t,e,S,l,a,(i==null?void 0:i.timeoutMs)??1e4,i==null?void 0:i.constraints,i==null?void 0:i.onTrace)}catch(A){throw A}}i!=null&&i.onTrace&&i.onTrace("Generator: Generating all possible clues...");let s=this.generateAllPossibleClues(t,i==null?void 0:i.constraints,this.reverseSolution,this.valueMap);i!=null&&i.onTrace&&i.onTrace(`Generator: Generated ${s.length} candidate clues.`);const d=new Y(t),u=[],c=100;for(;u.length<c;){if(i!=null&&i.onTrace){const N=u.length,V=d.getGridStats(),$=Math.max(1,V.totalPossible-V.solutionPossible),G=Math.max(0,V.currentPossible-V.solutionPossible),R=Math.min(100,Math.round(($-G)/$*100));if(i.onTrace(`Depth ${N}: ${R}% Solved. Candidates: ${s.length}`),R>=100&&this.isPuzzleSolved(d,this.solution,this.reverseSolution)){i.onTrace("Generator: Puzzle Solved (100%).");break}}let f=null,p=null;if(l<s.length)for(let N=s.length-1;N>0;N--){const V=Math.floor(this.random()*(N+1));[s[N],s[V]]=[s[V],s[N]]}const C=Math.min(s.length,l);let I=0;for(let N=s.length-1;N>=0&&!(I>=C);N--){const V=s[N],$=d.clone(),{deductions:G}=this.solver.applyClue($,V);if(G===0){s.splice(N,1);continue}I++;let R=0;a==="min"?R=G*1e3:a==="max"?R=100/G:R=this.calculateClueScore($,e,G,V,u.map(O=>O.clue),this.solution,this.reverseSolution),V.type;const F=this.solution[e.category2Id][e.value1],x=$.isPossible(e.category1Id,e.value1,e.category2Id,F)&&$.getPossibilitiesCount(e.category1Id,e.value1,e.category2Id)===1,M=this.isPuzzleSolved($,this.solution,this.reverseSolution);x&&(M?p={clue:V,score:R+1e6}:R=-1e6),R>-999999&&(!f||R>f.score)&&(f={clue:V,score:R})}const S=p||f;if(!S)break;const A=S.clue,{deductions:H}=this.solver.applyClue(d,A);u.push({clue:A,deductions:H});const T=s.findIndex(N=>JSON.stringify(N)===JSON.stringify(A));if(T>-1&&s.splice(T,1),this.isPuzzleSolved(d,this.solution,this.reverseSolution))break}const m=new Y(t),h=m.getGridStats(),y=h.totalPossible-h.solutionPossible;for(const f of u){const p=this.solver.applyClue(m,f.clue);f.clue.deductions=p.deductions;const C=m.getGridStats(),I=C.totalPossible-C.currentPossible;y>0?f.clue.percentComplete=Math.min(100,Math.max(0,I/y*100)):f.clue.percentComplete=100,f.clue.reasons=p.reasons}return{solution:this.solution,clues:u.map(f=>f.clue),proofChain:u,categories:t,targetFact:e}}generateWithBacktracking(t,e,a,i,l,r=1e4,n,o){const s=this.generateAllPossibleClues(t,n,this.reverseSolution,this.valueMap),d=new Y(t);let u=0;const c=Date.now(),m=(y,f,p,C)=>{const A=1+(Date.now()-c)/r*3;if(o&&f.length%1===0){const b=f.length+1,w=y.getGridStats(),P=Math.round((w.totalPossible-w.currentPossible)/(w.totalPossible-w.solutionPossible)*100);Math.random()<.05&&o(`Depth ${b}/${a}: ${P}% Solved. Bias: ${A.toFixed(2)} (Backtracks: ${u})`)}if(this.isPuzzleSolved(y,this.solution,this.reverseSolution))return f.length===a?(o&&o(`SOLVED! Exact match at ${a} clues.`),f):null;if(f.length>=a)return null;const T=y.getGridStats(),N=(T.totalPossible-T.currentPossible)/(T.totalPossible-T.solutionPossible),V=f.length+1;let $=[];if(i<p.length)for(let b=p.length-1;b>0;b--){const w=Math.floor(this.random()*(b+1));[p[b],p[w]]=[p[w],p[b]]}const R=Math.max(1,Math.floor((C?3:i===1/0?50:i)/Math.pow(A,2))),F=Math.min(p.length,R);o&&Math.random()<.001&&o(`Pruning: Limit reduced to ${F} (Bias ${A.toFixed(1)})`);let x=0;for(let b=0;b<p.length&&!(x>=F);b++){const w=p[b],P=y.clone(),{deductions:L}=this.solver.applyClue(P,w);if(L===0||(x++,this.isPuzzleSolved(P,this.solution,this.reverseSolution)&&V<a))continue;let K=this.calculateClueScore(P,e,L,w,f.map(q=>q.clue),this.solution,this.reverseSolution);if(a){const q=V/a,Q=(T.totalPossible-P.getGridStats().currentPossible)/(T.totalPossible-T.solutionPossible),U=Math.pow(q,1.8),Z=Q-U;K-=Z*L*50}$.push({clue:w,deductions:L,score:K,grid:P,index:b})}let M=[],O,D;if(C){const b=C==="STALL";M=$.sort((w,P)=>{const L=w.deductions-P.deductions;return b?L:-L})}else $.sort((b,w)=>w.score-b.score),O=$[0];if(!C){if(D=$[0],a){const b=Math.pow(V/a,1.8);N>b?D=[...$].sort((P,L)=>P.deductions!==L.deductions?P.deductions-L.deductions:L.score-P.score)[0]:D=[...$].sort((P,L)=>P.deductions!==L.deductions?L.deductions-P.deductions:L.score-P.score)[0]}O&&M.push(O),D&&D!==O&&M.push(D);for(const b of $)b!==O&&b!==D&&M.push(b)}for(const b of M){const w=1+(Date.now()-c)/r*4;if(a&&f.length>4&&w>1.1&&!(!!C||b===O||b===D))break;const P=[...p];P.splice(b.index,1);const L=b===O,W=b===D&&b!==O;let K=C,q="";if(!C&&W&&a){const U=N>V/a,Z=`(Prog ${N.toFixed(2)} vs Exp ${(V/a).toFixed(2)})`;K=U?"STALL":"SPEED",q=U?`(Stalling - Weakest) ${Z}`:`(Speeding - Strongest) ${Z}`}else C&&(q=`(Continued ${C})`);if(o&&(W||C||Math.random()<.05)){const U=C?`STICKY ${C}`:L?"Primary":W?"CORRECTION":"Rest";W?o(`[BACKTRACK] Depth ${f.length}: Primary Strategy Failed. Switching to ${q}. Ded: ${b.deductions}`):C?Math.random()<.1&&o(`Depth ${f.length}: ${Math.round(N*100)}% Solved. Strategy: ${U}. Ded: ${b.deductions}`):o(`Depth ${f.length}: ${Math.round(N*100)}% Solved. Trying ${U} Cand. Ded: ${b.deductions}`)}const Q=m(b.grid,[...f,{clue:b.clue,deductions:b.deductions}],P,K);if(Q)return Q}return u++,null},h=m(d,[],[...s]);if(h)return{solution:this.solution,clues:h.map(f=>f.clue),proofChain:h,categories:t,targetFact:e};throw new _(`Could not generate puzzle with exactly ${a} clues within timeout.`)}createSolution(t,e,a,i){var r;const l=t[0];l.values.forEach(n=>{e.set(n,{[l.id]:n})});for(let n=1;n<t.length;n++){const o=t[n],s=[...o.values].sort(()=>this.random()-.5);let d=0;for(const u of l.values){const c=e.get(u);c&&(c[o.id]=s[d++])}}for(const n of t)a[n.id]={},i.set(n.id,new Map);for(const n of l.values){const o=e.get(n);if(o)for(const s in o)a[s][n]=o[s],(r=i.get(s))==null||r.set(o[s],n)}}generateAllPossibleClues(t,e,a,i){var n,o,s,d,u;const l=[];t[0];const r=c=>!(e!=null&&e.allowedClueTypes)||e.allowedClueTypes.includes(c);if(r(g.BINARY))for(const c of t)for(const m of c.values)for(const h of t){if(c.id>=h.id)continue;const y=(n=a.get(c.id))==null?void 0:n.get(m);if(!y)continue;const f=i.get(y);if(f)for(const p of h.values){const C=f[h.id];p===C?l.push({type:g.BINARY,operator:k.IS,cat1:c.id,val1:m,cat2:h.id,val2:p}):l.push({type:g.BINARY,operator:k.IS_NOT,cat1:c.id,val1:m,cat2:h.id,val2:p})}}for(const c of t.filter(m=>m.type===B.ORDINAL)){const m=[...c.values].sort((f,p)=>f-p),h=m[0],y=m[m.length-1];if(r(g.SUPERLATIVE)){for(const f of t)if(f.id!==c.id)for(const p of f.values){const C=(o=a.get(f.id))==null?void 0:o.get(p);if(!C)continue;const I=i.get(C);if(!I)continue;const S=I[c.id];S===h?l.push({type:g.SUPERLATIVE,operator:z.MIN,targetCat:f.id,targetVal:p,ordinalCat:c.id}):l.push({type:g.SUPERLATIVE,operator:z.NOT_MIN,targetCat:f.id,targetVal:p,ordinalCat:c.id}),S===y?l.push({type:g.SUPERLATIVE,operator:z.MAX,targetCat:f.id,targetVal:p,ordinalCat:c.id}):l.push({type:g.SUPERLATIVE,operator:z.NOT_MAX,targetCat:f.id,targetVal:p,ordinalCat:c.id})}}if(r(g.ORDINAL)){for(const f of t)if(f.id!==c.id){for(const p of t)if(p.id!==c.id)for(const C of f.values)for(const I of p.values){if(f.id===p.id&&C===I)continue;const S=(s=a.get(f.id))==null?void 0:s.get(C),A=(d=a.get(p.id))==null?void 0:d.get(I);if(!S||!A||S===A)continue;const H=i.get(S),T=i.get(A);if(!H||!T)continue;const N=H[c.id],V=T[c.id];N>V?(l.push({type:g.ORDINAL,operator:E.GREATER_THAN,item1Cat:f.id,item1Val:C,item2Cat:p.id,item2Val:I,ordinalCat:c.id}),l.push({type:g.ORDINAL,operator:E.NOT_LESS_THAN,item1Cat:f.id,item1Val:C,item2Cat:p.id,item2Val:I,ordinalCat:c.id})):N<V&&(l.push({type:g.ORDINAL,operator:E.LESS_THAN,item1Cat:f.id,item1Val:C,item2Cat:p.id,item2Val:I,ordinalCat:c.id}),l.push({type:g.ORDINAL,operator:E.NOT_GREATER_THAN,item1Cat:f.id,item1Val:C,item2Cat:p.id,item2Val:I,ordinalCat:c.id}))}}}}if(r(g.UNARY)){for(const c of t)if(c.type===B.ORDINAL&&c.values.every(m=>typeof m=="number")){for(const m of t)if(m.id!==c.id)for(const h of m.values){const y=(u=a.get(m.id))==null?void 0:u.get(h);if(!y)continue;const f=i.get(y);if(!f)continue;f[c.id]%2===0?l.push({type:g.UNARY,filter:j.IS_EVEN,targetCat:m.id,targetVal:h,ordinalCat:c.id}):l.push({type:g.UNARY,filter:j.IS_ODD,targetCat:m.id,targetVal:h,ordinalCat:c.id})}}}return l}calculateClueScore(t,e,a,i,l,r,n){var F;const o=i.type,s=(F=n.get(e.category1Id))==null?void 0:F.get(e.value1);let d;s!==void 0&&(d=r[e.category2Id][s]);const u=d!==void 0&&t.isPossible(e.category1Id,e.value1,e.category2Id,d)&&t.getPossibilitiesCount(e.category1Id,e.value1,e.category2Id)===1,c=this.isPuzzleSolved(t,r,n);if(i.type===g.BINARY&&i.operator===k.IS){const x=i;if(x.cat1===e.category1Id&&x.val1===e.value1&&x.cat2===e.category2Id&&x.val2===d||x.cat1===e.category2Id&&x.val1===d&&x.cat2===e.category1Id&&x.val2===e.value1)return-1/0}if(u&&c)return 1e6;if(u&&!c)return-1e6;const m=a,{totalPossible:h,currentPossible:y,solutionPossible:f}=t.getGridStats(),p=h-f,C=h-y,I=p>0?C/p:0;let S=0;switch(o){case g.ORDINAL:S=1.5,i.operator>=2&&(S=5);break;case g.SUPERLATIVE:S=1.2,i.operator>=2&&(S=5);break;case g.UNARY:S=1.2;break;case g.BINARY:S=1,i.operator===k.IS_NOT&&(S=5);break}let A=0;const H=x=>{const M=(b,w)=>{var P;return(P=this.reverseSolution.get(b))==null?void 0:P.get(w)};let O=[],D=[];switch(x.type){case g.BINARY:const b=x;O.push(M(b.cat1,b.val1)),b.operator===k.IS_NOT&&D.push(M(b.cat2,b.val2));break;case g.SUPERLATIVE:const w=x;O.push(M(w.targetCat,w.targetVal));break;case g.ORDINAL:const P=x;O.push(M(P.item1Cat,P.item1Val)),D.push(M(P.item2Cat,P.item2Val));break;case g.UNARY:const L=x;O.push(M(L.targetCat,L.targetVal));break}return{primary:O.filter(b=>!!b),secondary:D.filter(b=>!!b)}},T=new Set;for(const x of l){const{primary:M,secondary:O}=H(x);M.forEach(D=>T.add(D)),O.forEach(D=>T.add(D))}const{primary:N,secondary:V}=H(i);N.forEach(x=>{T.has(x)&&(A+=1)}),V.forEach(x=>{T.has(x)&&(A+=.5)});const $=i.ordinalCat;if($)for(const x of l){const M=x.ordinalCat;$===M&&(A+=.5)}if(l.length>0){const x=l[l.length-1];if(i.type===x.type&&(A+=2,i.type===g.BINARY&&i.operator===k.IS&&x.operator===k.IS&&(A+=2)),l.length>1){const b=l[l.length-2];i.type===x.type&&i.type===b.type&&(A+=5)}const M=b=>{switch(b.type){case g.SUPERLATIVE:return 1;case g.BINARY:return b.operator===k.IS?1:3;case g.ORDINAL:return 3;case g.UNARY:return 3;case g.CROSS_ORDINAL:return 4;default:return 2}},O=M(i),D=M(x);O===D&&(A+=1.5)}const G=Math.pow(.4,A);return(m*S+I*5)*G}checkClueConsistency(t,e,a,i){const l=(o,s,d)=>{var c;const u=(c=a.get(o))==null?void 0:c.get(s);if(u)return e[d][u]},r=(o,s)=>{var d;return(d=a.get(o))==null?void 0:d.get(s)},n=(o,s,d)=>{const u=r(o,s);if(!u)return;const c=i.get(u);if(!c)return;const m=c[d];return typeof m=="number"?m:void 0};switch(t.type){case g.BINARY:{const o=t,s=l(o.cat1,o.val1,o.cat2);if(s===void 0)return!1;if(o.operator===k.IS)return s===o.val2;if(o.operator===k.IS_NOT)return s!==o.val2;break}case g.ORDINAL:{const o=t,s=n(o.item1Cat,o.item1Val,o.ordinalCat),d=n(o.item2Cat,o.item2Val,o.ordinalCat);if(s===void 0||d===void 0)return!1;switch(o.operator){case E.GREATER_THAN:return s>d;case E.LESS_THAN:return s<d;case E.NOT_GREATER_THAN:return s<=d;case E.NOT_LESS_THAN:return s>=d}break}case g.SUPERLATIVE:{const o=t,s=n(o.targetCat,o.targetVal,o.ordinalCat);if(s===void 0)return!1;let d=1/0,u=-1/0;for(const c of this.valueMap.keys()){const m=this.valueMap.get(c);if(m){const h=m[o.ordinalCat];typeof h=="number"&&(h<d&&(d=h),h>u&&(u=h))}}if(d===1/0)return!1;switch(o.operator){case z.MIN:return s===d;case z.MAX:return s===u;case z.NOT_MIN:return s!==d;case z.NOT_MAX:return s!==u}break}case g.UNARY:{const o=t,s=n(o.targetCat,o.targetVal,o.ordinalCat);if(s===void 0)return!1;switch(o.filter){case j.IS_ODD:return s%2!==0;case j.IS_EVEN:return s%2===0}break}case g.CROSS_ORDINAL:{const o=t,s=n(o.item1Cat,o.item1Val,o.ordinal1),d=n(o.item2Cat,o.item2Val,o.ordinal2);if(s===void 0||d===void 0)return!1;switch(o.operator){case E.GREATER_THAN:return s>d;case E.LESS_THAN:return s<d;case E.NOT_GREATER_THAN:return s<=d;case E.NOT_LESS_THAN:return s>=d}break}}return!0}isPuzzleSolved(t,e,a){var l;const i=t.categories;i[0];for(const r of i)for(const n of r.values)for(const o of i){if(r.id>=o.id)continue;const s=(l=a.get(r.id))==null?void 0:l.get(n);if(!s)return!1;const d=e[o.id][s];if(t.getPossibilitiesCount(r.id,n,o.id)>1||!t.isPossible(r.id,n,o.id,d))return!1}return!0}}const X=self;X.onmessage=v=>{const{type:t}=v.data;if(t==="start"){const{categories:e,targetFact:a,options:i}=v.data;i&&i.targetClueCount&&(i.targetClueCount=parseInt(String(i.targetClueCount),10));try{const l=new J(i==null?void 0:i.seed),r={...i,onTrace:o=>{X.postMessage({type:"trace",message:o})}};let n;try{n=l.generatePuzzle(e,a,r)}catch(o){if(i.targetClueCount&&o.message&&o.message.includes("Could not generate puzzle")){X.postMessage({type:"trace",message:`⚠️ Strict generation failed (${o.message}). Falling back to best-effort generation...`});const s={...r,targetClueCount:void 0};n=l.generatePuzzle(e,a,s)}else throw o}X.postMessage({type:"done",puzzle:n})}catch(l){console.error("Worker Generation Error:",l),X.postMessage({type:"error",message:l.message||"Unknown worker error"})}}}})();
