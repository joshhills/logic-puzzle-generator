(function(){"use strict";var $=(h=>(h[h.NOMINAL=0]="NOMINAL",h[h.ORDINAL=1]="ORDINAL",h))($||{}),v=(h=>(h[h.BINARY=0]="BINARY",h[h.ORDINAL=1]="ORDINAL",h[h.SUPERLATIVE=2]="SUPERLATIVE",h[h.UNARY=3]="UNARY",h[h.CROSS_ORDINAL=4]="CROSS_ORDINAL",h))(v||{}),te=(h=>(h[h.MATCH=0]="MATCH",h[h.NOT_MATCH=1]="NOT_MATCH",h))(te||{}),z=(h=>(h[h.IS=0]="IS",h[h.IS_NOT=1]="IS_NOT",h))(z||{}),M=(h=>(h[h.GREATER_THAN=0]="GREATER_THAN",h[h.LESS_THAN=1]="LESS_THAN",h[h.NOT_GREATER_THAN=2]="NOT_GREATER_THAN",h[h.NOT_LESS_THAN=3]="NOT_LESS_THAN",h))(M||{}),G=(h=>(h[h.MIN=0]="MIN",h[h.MAX=1]="MAX",h[h.NOT_MIN=2]="NOT_MIN",h[h.NOT_MAX=3]="NOT_MAX",h))(G||{}),j=(h=>(h[h.IS_ODD=0]="IS_ODD",h[h.IS_EVEN=1]="IS_EVEN",h))(j||{});class ie extends Error{constructor(t){super(t),this.name="LogicPuzzleError"}}class D extends ie{constructor(t){super(t),this.name="ConfigurationError"}}class Y{constructor(t){this.validateConfig(t),this.categories=t,this.valueMap=new Map(t.map(e=>[e.id,new Map(e.values.map((a,s)=>[a,s]))])),this.grid=new Map;for(const e of t){const a=new Map;for(const s of e.values){const o=new Map;for(const r of t)e.id!==r.id&&o.set(r.id,Array(r.values.length).fill(!0));a.set(s,o)}this.grid.set(e.id,a)}}validateConfig(t){const e=new Set;let a=-1;for(const s of t){if(e.has(s.id))throw new D(`Duplicate category ID found: ${s.id}`);if(e.add(s.id),new Set(s.values).size!==s.values.length)throw new D(`Category '${s.id}' has duplicate values.`);if(a===-1)a=s.values.length;else if(s.values.length!==a)throw new D(`Category '${s.id}' has ${s.values.length} values, expected ${a}. All categories must be the same size.`)}}setPossibility(t,e,a,s,o){var i,n;const r=(i=this.valueMap.get(a))==null?void 0:i.get(s);if(r!==void 0){const c=this.grid.get(t);if(c){const u=c.get(e);if(u){const d=u.get(a);d&&(d[r]=o)}}}const l=(n=this.valueMap.get(t))==null?void 0:n.get(e);if(l!==void 0){const c=this.grid.get(a);if(c){const u=c.get(s);if(u){const d=u.get(t);d&&(d[l]=o)}}}}isPossible(t,e,a,s){var n;if(t===a)return e===s;const o=(n=this.valueMap.get(a))==null?void 0:n.get(s);if(o===void 0)return!1;const r=this.grid.get(t);if(!r)return!1;const l=r.get(e);if(!l)return!1;const i=l.get(a);return i?i[o]:!1}getPossibilitiesCount(t,e,a){var o,r;const s=(r=(o=this.grid.get(t))==null?void 0:o.get(e))==null?void 0:r.get(a);return s?s.filter(l=>l).length:0}getGridStats(){var l,i,n;let t=0;const e=this.categories.length,a=((l=this.categories[0])==null?void 0:l.values.length)||0;if(a===0||e<2)return{totalPossible:0,currentPossible:0,solutionPossible:0};const s=e*(e-1)/2,o=s*a*a,r=s*a;for(const c of this.categories)for(const u of c.values)for(const d of this.categories){if(c.id>=d.id)continue;const m=(n=(i=this.grid.get(c.id))==null?void 0:i.get(u))==null?void 0:n.get(d.id);m&&(t+=m.filter(g=>g).length)}return{totalPossible:o,currentPossible:t,solutionPossible:r}}clone(){const t=new Y(this.categories);return t.grid=new Map([...this.grid.entries()].map(([e,a])=>[e,new Map([...a.entries()].map(([s,o])=>[s,new Map([...o.entries()].map(([r,l])=>[r,[...l]]))]))])),t}compareVisualState(t){var s,o;let e=0;const a=this.categories;for(const r of a)for(const l of r.values)for(const i of a){if(r.id>=i.id)continue;const n=(s=this.grid.get(r.id))==null?void 0:s.get(l),c=(o=t.grid.get(r.id))==null?void 0:o.get(l);if(n&&c){const m=n.get(i.id),g=c.get(i.id);if(m&&g)for(let y=0;y<m.length;y++)g[y]&&!m[y]&&e++}const u=t.getPossibilitiesCount(r.id,l,i.id),d=this.getPossibilitiesCount(r.id,l,i.id);u>1&&d===1&&e++}return e}}class ee{applyClue(t,e){let a=0;switch(e.type){case v.BINARY:a+=this.applyBinaryClue(t,e);break;case v.SUPERLATIVE:a+=this.applySuperlativeClue(t,e);break;case v.ORDINAL:a+=this.applyOrdinalClue(t,e);break;case v.UNARY:a+=this.applyUnaryClue(t,e);break;case v.CROSS_ORDINAL:a+=this.applyCrossOrdinalClue(t,e);break}let s;do s=this.runDeductionLoop(t),a+=s;while(s>0);return{grid:t,deductions:a}}applyCrossOrdinalClue(t,e){let a=0;const s=t.categories,o=s.find(u=>u.id===e.ordinal1),r=s.find(u=>u.id===e.ordinal2);if(!o||!r)return 0;const l=e.operator===te.NOT_MATCH,i=(u,d,m,g)=>g.values.map((y,f)=>({val:y,idx:f})).filter(y=>t.isPossible(u,d,m,y.val)),n=i(e.item1Cat,e.item1Val,e.ordinal1,o),c=i(e.item2Cat,e.item2Val,e.ordinal2,r);if(l){if(n.length===1&&c.length===1){const u=n[0].idx+e.offset1,d=c[0].idx+e.offset2,m=o.values[u],g=r.values[d];m!==void 0&&g!==void 0&&t.isPossible(e.ordinal1,m,e.ordinal2,g)&&(t.setPossibility(e.ordinal1,m,e.ordinal2,g,!1),a++)}for(const u of n){const d=u.idx+e.offset1;if(o.values[d]!==void 0)for(const g of c){const y=g.idx+e.offset2;r.values[y]}}if(n.length===1){const u=n[0].idx+e.offset1,d=o.values[u];if(d!==void 0)for(const m of c){const g=m.idx+e.offset2,y=r.values[g];y!==void 0&&t.isPossible(e.ordinal1,d,e.ordinal2,y)&&(t.setPossibility(e.item2Cat,e.item2Val,e.ordinal2,m.val,!1),a++)}}if(c.length===1){const u=c[0].idx+e.offset2,d=r.values[u];if(d!==void 0)for(const m of n){const g=m.idx+e.offset1,y=o.values[g];y!==void 0&&t.isPossible(e.ordinal1,y,e.ordinal2,d)&&(t.setPossibility(e.item1Cat,e.item1Val,e.ordinal1,m.val,!1),a++)}}}else{for(const m of n){const g=m.idx+e.offset1,y=o.values[g];if(y===void 0){t.setPossibility(e.item1Cat,e.item1Val,e.ordinal1,m.val,!1),a++;continue}let f=!1;for(const b of c){const C=b.idx+e.offset2,I=r.values[C];if(I!==void 0&&t.isPossible(e.ordinal1,y,e.ordinal2,I)){f=!0;break}}f||(t.setPossibility(e.item1Cat,e.item1Val,e.ordinal1,m.val,!1),a++)}for(const m of c){const g=m.idx+e.offset2,y=r.values[g];if(y===void 0){t.setPossibility(e.item2Cat,e.item2Val,e.ordinal2,m.val,!1),a++;continue}let f=!1;for(const b of n){const C=b.idx+e.offset1,I=o.values[C];if(I!==void 0&&t.isPossible(e.ordinal1,I,e.ordinal2,y)){f=!0;break}}f||(t.setPossibility(e.item2Cat,e.item2Val,e.ordinal2,m.val,!1),a++)}const u=i(e.item1Cat,e.item1Val,e.ordinal1,o),d=i(e.item2Cat,e.item2Val,e.ordinal2,r);if(u.length===1&&d.length===1){const m=u[0].idx+e.offset1,g=d[0].idx+e.offset2,y=o.values[m],f=r.values[g];y!==void 0&&f!==void 0&&t.getPossibilitiesCount(e.ordinal1,y,e.ordinal2)>1&&(t.setPossibility(e.ordinal1,y,e.ordinal2,f,!0),a++)}}return a}applyUnaryClue(t,e){let a=0;const o=t.categories.find(l=>l.id===e.ordinalCat);if(!o||o.type!==$.ORDINAL||!o.values.every(l=>typeof l=="number"))return 0;const r=e.filter===j.IS_EVEN;for(const l of o.values){const i=l;(r?i%2!==0:i%2===0)&&t.isPossible(e.targetCat,e.targetVal,e.ordinalCat,l)&&(t.setPossibility(e.targetCat,e.targetVal,e.ordinalCat,l,!1),a++)}return a}applyBinaryClue(t,e){let a=0;const s=t.categories,o=s.find(l=>l.id===e.cat1),r=s.find(l=>l.id===e.cat2);if(!o||!r)return 0;if(e.operator===z.IS){t.getPossibilitiesCount(e.cat1,e.val1,e.cat2)>1&&a++,t.isPossible(e.cat1,e.val1,e.cat2,e.val2),t.setPossibility(e.cat1,e.val1,e.cat2,e.val2,!0);for(const l of r.values)l!==e.val2&&t.isPossible(e.cat1,e.val1,e.cat2,l)&&(t.setPossibility(e.cat1,e.val1,e.cat2,l,!1),a++);for(const l of o.values)l!==e.val1&&t.isPossible(e.cat1,l,e.cat2,e.val2)&&(t.setPossibility(e.cat1,l,e.cat2,e.val2,!1),a++)}else t.isPossible(e.cat1,e.val1,e.cat2,e.val2)&&(t.setPossibility(e.cat1,e.val1,e.cat2,e.val2,!1),a++);return a}runDeductionLoop(t){let e=0;const a=t.categories;for(const s of a)for(const o of s.values)for(const r of a){if(s.id===r.id)continue;const l=r.values.filter(i=>t.isPossible(s.id,o,r.id,i));if(l.length===1){const i=l[0];for(const n of s.values)n!==o&&t.isPossible(s.id,n,r.id,i)&&(t.setPossibility(s.id,n,r.id,i,!1),e++)}for(const i of a){if(s.id===i.id||r.id===i.id)continue;const n=l.length===1?l[0]:null;if(n){const c=i.values.filter(u=>t.isPossible(r.id,n,i.id,u));if(c.length===1){const u=c[0];t.isPossible(s.id,o,i.id,u)===!1||t.getPossibilitiesCount(s.id,o,i.id)>1&&(t.setPossibility(s.id,o,i.id,u,!0),e++)}}for(const c of i.values)t.isPossible(s.id,o,i.id,c)&&(r.values.some(d=>t.isPossible(s.id,o,r.id,d)&&t.isPossible(r.id,d,i.id,c))||(t.setPossibility(s.id,o,i.id,c,!1),e++))}}return e}applyOrdinalClue(t,e){let a=0;const o=t.categories.find(i=>i.id===e.ordinalCat);if(!o||o.type!==$.ORDINAL)return 0;const r=o.values.map((i,n)=>({val:i,idx:n})).filter(i=>t.isPossible(e.item1Cat,e.item1Val,e.ordinalCat,i.val)),l=o.values.map((i,n)=>({val:i,idx:n})).filter(i=>t.isPossible(e.item2Cat,e.item2Val,e.ordinalCat,i.val));if(r.length===0||l.length===0)return 0;if(e.operator===M.GREATER_THAN)for(const i of r)l.some(c=>i.idx>c.idx)||t.isPossible(e.item1Cat,e.item1Val,e.ordinalCat,i.val)&&(t.setPossibility(e.item1Cat,e.item1Val,e.ordinalCat,i.val,!1),a++);else if(e.operator===M.LESS_THAN)for(const i of r)l.some(c=>i.idx<c.idx)||t.isPossible(e.item1Cat,e.item1Val,e.ordinalCat,i.val)&&(t.setPossibility(e.item1Cat,e.item1Val,e.ordinalCat,i.val,!1),a++);else if(e.operator===M.NOT_GREATER_THAN)for(const i of r)l.some(c=>i.idx<=c.idx)||t.isPossible(e.item1Cat,e.item1Val,e.ordinalCat,i.val)&&(t.setPossibility(e.item1Cat,e.item1Val,e.ordinalCat,i.val,!1),a++);else if(e.operator===M.NOT_LESS_THAN)for(const i of r)l.some(c=>i.idx>=c.idx)||t.isPossible(e.item1Cat,e.item1Val,e.ordinalCat,i.val)&&(t.setPossibility(e.item1Cat,e.item1Val,e.ordinalCat,i.val,!1),a++);if(e.operator===M.GREATER_THAN)for(const i of l)r.some(c=>i.idx<c.idx)||t.isPossible(e.item2Cat,e.item2Val,e.ordinalCat,i.val)&&(t.setPossibility(e.item2Cat,e.item2Val,e.ordinalCat,i.val,!1),a++);else if(e.operator===M.LESS_THAN)for(const i of l)r.some(c=>i.idx>c.idx)||t.isPossible(e.item2Cat,e.item2Val,e.ordinalCat,i.val)&&(t.setPossibility(e.item2Cat,e.item2Val,e.ordinalCat,i.val,!1),a++);else if(e.operator===M.NOT_GREATER_THAN)for(const i of l)r.some(c=>i.idx>=c.idx)||t.isPossible(e.item2Cat,e.item2Val,e.ordinalCat,i.val)&&(t.setPossibility(e.item2Cat,e.item2Val,e.ordinalCat,i.val,!1),a++);else if(e.operator===M.NOT_LESS_THAN)for(const i of l)r.some(c=>i.idx<=c.idx)||t.isPossible(e.item2Cat,e.item2Val,e.ordinalCat,i.val)&&(t.setPossibility(e.item2Cat,e.item2Val,e.ordinalCat,i.val,!1),a++);return a}applySuperlativeClue(t,e){const s=t.categories.find(i=>i.id===e.ordinalCat);if(!s||s.type!==$.ORDINAL)return 0;let o,r=!1;switch(e.operator){case G.MAX:o=s.values[s.values.length-1];break;case G.MIN:o=s.values[0];break;case G.NOT_MAX:o=s.values[s.values.length-1],r=!0;break;case G.NOT_MIN:o=s.values[0],r=!0;break;default:return 0}const l={type:v.BINARY,cat1:e.targetCat,val1:e.targetVal,cat2:e.ordinalCat,val2:o,operator:r?z.IS_NOT:z.IS};return this.applyBinaryClue(t,l)}}class ae{constructor(t,e,a,s,o,r){this.generator=t,this.categories=e,this.solution=a,this.reverseSolution=s,this.valueMap=o,this.targetFact=r,this.availableClues=[],this.proofChain=[],this.targetSolvedStepIndex=-1,this.historyStack=[],this.grid=new Y(e),this.solver=new ee,this.checkTargetSolved(),this.availableClues=this.generator.generateAllPossibleClues(e,void 0,s,o)}getTotalClueCount(){return this.availableClues.length}getTargetSolvedStepIndex(){return this.targetSolvedStepIndex}getMatchingClueCount(t){return this.filterClues(t).length}getMatchingClues(t,e=50){return this.filterClues(t).slice(0,e)}getScoredMatchingClues(t,e=50){const a=this.filterClues(t),s=[],o=(t==null?void 0:t.minDeductions)??0,r=t==null?void 0:t.maxDeductions;if(r!==void 0&&o>r)throw new D(`Invalid constraints: minDeductions (${o}) cannot be greater than maxDeductions (${r}).`);for(const l of a){const i=this.grid.clone(),{deductions:n}=this.solver.applyClue(i,l);if(n<o||r!==void 0&&n>r)continue;const c=this.generator.calculateClueScore(this.grid,this.targetFact,n,l,this.proofChain,this.solution,this.reverseSolution);let u=!1;if(l.type===v.BINARY&&l.operator===z.IS){const C=l,I=C.cat1===this.targetFact.category1Id&&C.val1===this.targetFact.value1&&C.cat2===this.targetFact.category2Id,A=C.cat2===this.targetFact.category1Id&&C.val2===this.targetFact.value1&&C.cat1===this.targetFact.category2Id;(I||A)&&(u=!0)}const d=i.getGridStats(),m=d.totalPossible-d.solutionPossible,g=d.totalPossible-d.currentPossible;let y=0;m>0?y=Math.min(100,Math.max(0,g/m*100)):y=100;const f=i.compareVisualState(this.grid);s.push({clue:l,score:c,deductions:n,updates:f,isDirectAnswer:u,percentComplete:y})}return s.sort((l,i)=>i.score-l.score).slice(0,e)}useClue(t){if(!this.generator.checkClueConsistency(t,this.solution,this.reverseSolution,this.valueMap))throw new Error("Invalid Clue: This clue contradicts the puzzle solution.");return this.applyAndSave(t),{remaining:this.availableClues.length,solved:this.generator.isPuzzleSolved(this.grid,this.solution,this.reverseSolution)}}filterClues(t){return this.availableClues.filter(e=>{if(t!=null&&t.allowedClueTypes&&!t.allowedClueTypes.includes(e.type))return!1;if(t!=null&&t.includeSubjects&&(t!=null&&t.excludeSubjects)){const a=t.includeSubjects.filter(s=>t.excludeSubjects.includes(s));if(a.length>0)throw new Error(`Constraint Error: The following subjects are both included and excluded: ${a.join(", ")}`)}if(t!=null&&t.includeSubjects||t!=null&&t.excludeSubjects){const a=this.extractValuesFromClue(e);if(t.includeSubjects&&!t.includeSubjects.some(o=>a.includes(o))||t.excludeSubjects&&t.excludeSubjects.some(o=>a.includes(o)))return!1}return!0})}applyAndSave(t){this.historyStack.push(this.grid.clone());const e=this.solver.applyClue(this.grid,t);t.deductions=e.deductions;const a=this.grid.getGridStats(),s=a.totalPossible-a.solutionPossible,o=a.totalPossible-a.currentPossible;s>0?t.percentComplete=Math.min(100,Math.max(0,o/s*100)):t.percentComplete=100;const r=this.historyStack[this.historyStack.length-1];r?t.updates=this.grid.compareVisualState(r):t.updates=t.deductions,this.proofChain.push(t),this.targetSolvedStepIndex===-1&&this.checkTargetSolvedInternal()&&(this.targetSolvedStepIndex=this.proofChain.length-1);const l=this.availableClues.indexOf(t);l>-1&&this.availableClues.splice(l,1)}checkTargetSolvedInternal(){return this.grid.getPossibilitiesCount(this.targetFact.category1Id,this.targetFact.value1,this.targetFact.category2Id)===1}checkTargetSolved(){this.checkTargetSolvedInternal()}getNextClue(t){const e=this.filterClues(t);let a=null,s=-1/0;const o=[...e].sort(()=>Math.random()-.5),r=50;let l=0;const i=(t==null?void 0:t.minDeductions)??0,n=t==null?void 0:t.maxDeductions;if(n!==void 0&&i>n)throw new D(`Invalid constraints: minDeductions (${i}) cannot be greater than maxDeductions (${n}).`);for(const c of o){if(l++,l>r&&a)break;const u=this.grid.clone(),{deductions:d}=this.solver.applyClue(u,c);if(d<i||n!==void 0&&d>n)continue;const m=this.generator.calculateClueScore(this.grid,this.targetFact,d,c,this.proofChain,this.solution,this.reverseSolution),g=u.getGridStats();g.totalPossible-g.solutionPossible,g.totalPossible-g.currentPossible,m>s&&(s=m,a=c)}return a?(this.applyAndSave(a),{clue:a,remaining:this.availableClues.length,solved:this.generator.isPuzzleSolved(this.grid,this.solution,this.reverseSolution)}):{clue:null,remaining:e.length,solved:this.generator.isPuzzleSolved(this.grid,this.solution,this.reverseSolution)}}async getNextClueAsync(t){return new Promise((e,a)=>{setTimeout(()=>{try{const s=this.getNextClue(t);e(s)}catch(s){a(s)}},0)})}rollbackLastClue(){if(this.historyStack.length===0)return{success:!1,clue:null};const t=this.historyStack.pop();t&&(this.grid=t);const e=this.proofChain.pop();return e?(this.availableClues.push(e),{success:!0,clue:e}):{success:!1,clue:null}}isUseful(t){return!0}removeClueAt(t){if(t<0||t>=this.proofChain.length)return!1;const e=this.proofChain[t];return this.proofChain.splice(t,1),this.availableClues.push(e),this.replayProofChain()}moveClue(t,e){if(t<0||t>=this.proofChain.length||e<0||e>=this.proofChain.length)return!1;if(t===e)return!0;const a=this.proofChain[t];return this.proofChain.splice(t,1),this.proofChain.splice(e,0,a),this.replayProofChain()}replayProofChain(){this.grid=new Y(this.categories),this.historyStack=[],this.solver=new ee,this.targetSolvedStepIndex=-1,this.checkTargetSolvedInternal(),this.availableClues.push(...this.proofChain);const t=[...this.proofChain];this.proofChain=[];for(const e of t)this.applyAndSave(e);return!0}getGrid(){return this.grid}getProofChain(){return this.proofChain}getSolution(){return this.solution}getValueMap(){return this.valueMap}extractValuesFromClue(t){const e=[],a=s=>{s!==void 0&&e.push(String(s))};return a(t.val1),a(t.val2),a(t.item1Val),a(t.item2Val),a(t.targetVal),e}}const se={"2x3":{min:2,max:2},"2x4":{min:3,max:10},"2x5":{min:4,max:17},"2x6":{min:5,max:26},"2x7":{min:6,max:37},"2x8":{min:7,max:50},"2x9":{min:8,max:65},"2x10":{min:9,max:82},"3x3":{min:3,max:9},"3x4":{min:5,max:26},"3x5":{min:7,max:47},"3x6":{min:9,max:72},"3x7":{min:11,max:100},"3x8":{min:13,max:130},"3x9":{min:15,max:160},"3x10":{min:17,max:200},"4x3":{min:5,max:16},"4x4":{min:8,max:44},"4x5":{min:11,max:87},"4x6":{min:14,max:140},"4x7":{min:17,max:200},"4x8":{min:20,max:260},"4x9":{min:23,max:330},"4x10":{min:26,max:400},"5x3":{min:7,max:25},"5x4":{min:11,max:70},"5x5":{min:15,max:130},"5x6":{min:19,max:200},"5x7":{min:23,max:280},"5x8":{min:27,max:370},"5x9":{min:31,max:470},"5x10":{min:35,max:580}},oe=(h,t)=>{const e=`${h}x${t}`;if(se[e])return se[e];const a=(h-1)*t,s=Math.max(5,Math.floor(a*.7)),o=Math.floor(a*5);return{min:s,max:o}};function ne(h){return function(){h|=0,h=h+1831565813|0;var t=Math.imul(h^h>>>15,1|h);return t=t+Math.imul(t^t>>>7,61|t)^t,((t^t>>>14)>>>0)/4294967296}}class J{constructor(t){this.solution={},this.valueMap=new Map,this.reverseSolution=new Map,this.seed=t,this.random=ne(t),this.solver=new ee}getClueCountBounds(t,e,a=10){let s=1/0,o=0;for(let r=0;r<a;r++){const l=this.seed+r+1,i=new J(l);try{const n=i.internalGenerate(t,e,"min");n&&(s=Math.min(s,n.clues.length))}catch{}try{const c=new J(l).internalGenerate(t,e,"max");c&&(o=Math.max(o,c.clues.length))}catch{}}return s===1/0&&(s=0),{min:s,max:o}}generatePuzzle(t,e,a={}){if(t.length<2)throw new D("Puzzle must have at least 2 categories.");const{targetClueCount:s,maxCandidates:o=50,timeoutMs:r=1e4}=a,l=e||this.generateRandomTarget(t);this.validateTarget(t,l);const i=a.constraints;if(i!=null&&i.allowedClueTypes){const n=i.allowedClueTypes,c=t.some(m=>m.type===$.ORDINAL),u=n.includes(v.ORDINAL),d=n.includes(v.CROSS_ORDINAL);if(u&&!c&&!n.includes(v.BINARY))throw new D("Invalid Constraints: Ordinal-based clue types were requested, but no Ordinal categories exist. Please add an ordinal category or allow Binary clues.");if(d&&t.filter(g=>g.type===$.ORDINAL).length<2)throw new D("Invalid Constraints: Cross-Ordinal clues require at least 2 Ordinal Categories.")}return this.internalGenerate(t,l,"standard",{maxCandidates:o,targetClueCount:s,timeoutMs:r,constraints:a.constraints,onTrace:a.onTrace})}validateTarget(t,e){const a=new Set(t.map(s=>s.id));if(!a.has(e.category1Id)||!a.has(e.category2Id))throw new D("Target fact refers to non-existent categories.");if(e.category1Id===e.category2Id)throw new D("Target fact must refer to two different categories.")}generateRandomTarget(t){const e=Math.floor(this.random()*t.length);let a=Math.floor(this.random()*t.length);for(;a===e;)a=Math.floor(this.random()*t.length);const s=t[e],o=t[a],r=Math.floor(this.random()*s.values.length);return{category1Id:s.id,value1:s.values[r],category2Id:o.id}}async generatePuzzleAsync(t,e,a={}){return new Promise((s,o)=>{setTimeout(()=>{try{const r=this.generatePuzzle(t,e,a);s(r)}catch(r){o(r)}},0)})}async getClueCountBoundsAsync(t,e,a=10){return new Promise((s,o)=>{setTimeout(()=>{try{const r=this.getClueCountBounds(t,e,a);s(r)}catch(r){o(r)}},0)})}startSession(t,e){if(t.length<2)throw new D("Must have at least 2 categories.");let a=e;if(!a){const l=Math.floor(this.random()*t.length);let i=Math.floor(this.random()*t.length);for(;i===l;)i=Math.floor(this.random()*t.length);const n=t[l],c=t[i],u=Math.floor(this.random()*n.values.length);a={category1Id:n.id,value1:n.values[u],category2Id:c.id}}const s=new Map,o={},r=new Map;return this.createSolution(t,s,o,r),new ae(this,t,o,r,s,a)}internalGenerate(t,e,a,s){if(!t||t.length<2)throw new D("At least 2 categories are required to generate a puzzle.");const o=(s==null?void 0:s.maxCandidates)??1/0,r=s==null?void 0:s.targetClueCount,l=s==null?void 0:s.constraints;s!=null&&s.onTrace&&s.onTrace("Generator: internalGenerate started.");const i=t.find(f=>f.id===e.category1Id);if(i&&!i.values.includes(e.value1))throw new D(`Target value '${e.value1}' does not exist in category '${e.category1Id}'.`);if(l!=null&&l.allowedClueTypes){const f=[v.BINARY,v.ORDINAL,v.CROSS_ORDINAL],b=l.allowedClueTypes.some(T=>f.includes(T));if(l.allowedClueTypes.length>0&&!b)throw new D("Invalid Constraints: The selected clue types are ambiguous on their own. Please allow at least one identity-resolving type (Binary, Ordinal, or Cross-Ordinal).");const C=t.filter(T=>T.type===$.ORDINAL),I=C.length,A=I>0,w=[v.ORDINAL,v.SUPERLATIVE,v.UNARY,v.CROSS_ORDINAL];if(l.allowedClueTypes.some(T=>w.includes(T))&&!A&&!l.allowedClueTypes.includes(v.BINARY))throw new D("Invalid Constraints: Ordinal-based clue types were requested, but no Ordinal categories exist. Please add an ordinal category or allow Binary clues.");if(l.allowedClueTypes.includes(v.CROSS_ORDINAL)&&I<2)throw new D("Invalid Constraints: Cross-Ordinal clues require at least two separate Ordinal categories.");if(l.allowedClueTypes.includes(v.UNARY)&&!C.some(P=>{const N=P.values.map(E=>Number(E)).filter(E=>!isNaN(E)),V=N.some(E=>E%2!==0),B=N.some(E=>E%2===0);return V&&B}))throw new D("Invalid Constraints: Unary clues (Even/Odd) require at least one Ordinal category to contain both odd and even values.")}for(const f of t)if(f.type===$.ORDINAL&&f.values.some(C=>typeof C!="number"&&isNaN(Number(C))))throw new D(`Category '${f.id}' is ORDINAL but contains non-numeric values.`);if(this.valueMap=new Map,this.solution={},this.reverseSolution=new Map,s!=null&&s.onTrace&&s.onTrace("Generator: Creating solution..."),this.createSolution(t,this.valueMap,this.solution,this.reverseSolution),s!=null&&s.onTrace&&s.onTrace("Generator: Solution created."),r!==void 0){const f=t.length,b=t[0].values.length,C=oe(f,b);s!=null&&s.onTrace&&s.onTrace(`Generator: Feasibility check complete. Recommended bounds: ${C.min}-${C.max}`);const I=0;let A=r;C.min>0&&r<C.min-I&&(console.warn(`Target clue count ${r} is too low (Estimated min: ${C.min}). Auto-adjusting to ${C.min}.`),A=C.min);try{return this.generateWithBacktracking(t,e,A,o,a,(s==null?void 0:s.timeoutMs)??1e4,s==null?void 0:s.constraints,s==null?void 0:s.onTrace)}catch(w){throw w}}s!=null&&s.onTrace&&s.onTrace("Generator: Generating all possible clues...");let n=this.generateAllPossibleClues(t,s==null?void 0:s.constraints,this.reverseSolution,this.valueMap);s!=null&&s.onTrace&&s.onTrace(`Generator: Generated ${n.length} candidate clues.`);const c=new Y(t),u=[],d=100;for(;u.length<d;){if(s!=null&&s.onTrace){const P=u.length,N=c.getGridStats(),V=Math.max(1,N.totalPossible-N.solutionPossible),B=Math.max(0,N.currentPossible-N.solutionPossible),E=Math.min(100,Math.round((V-B)/V*100));if(s.onTrace(`Depth ${P}: ${E}% Solved. Candidates: ${n.length}`),E>=100&&this.isPuzzleSolved(c,this.solution,this.reverseSolution)){s.onTrace("Generator: Puzzle Solved (100%).");break}}let f=null,b=null;if(o<n.length)for(let P=n.length-1;P>0;P--){const N=Math.floor(this.random()*(P+1));[n[P],n[N]]=[n[N],n[P]]}const C=Math.min(n.length,o);let I=0;for(let P=n.length-1;P>=0&&!(I>=C);P--){const N=n[P],V=c.clone(),{deductions:B}=this.solver.applyClue(V,N);if(B===0){n.splice(P,1);continue}I++;let E=0;a==="min"?E=B*1e3:a==="max"?E=100/B:E=this.calculateClueScore(V,e,B,N,u.map(L=>L.clue),this.solution,this.reverseSolution),N.type;const F=this.solution[e.category2Id][e.value1],S=V.isPossible(e.category1Id,e.value1,e.category2Id,F)&&V.getPossibilitiesCount(e.category1Id,e.value1,e.category2Id)===1,O=this.isPuzzleSolved(V,this.solution,this.reverseSolution);S&&(O?b={clue:N,score:E+1e6}:E=-1e6),E>-999999&&(!f||E>f.score)&&(f={clue:N,score:E})}const A=b||f;if(!A)break;const w=A.clue,{deductions:H}=this.solver.applyClue(c,w);u.push({clue:w,deductions:H});const T=n.findIndex(P=>JSON.stringify(P)===JSON.stringify(w));if(T>-1&&n.splice(T,1),this.isPuzzleSolved(c,this.solution,this.reverseSolution))break}const m=new Y(t),g=m.getGridStats(),y=g.totalPossible-g.solutionPossible;for(const f of u){const b=this.solver.applyClue(m,f.clue);f.clue.deductions=b.deductions;const C=m.getGridStats(),I=C.totalPossible-C.currentPossible;y>0?f.clue.percentComplete=Math.min(100,Math.max(0,I/y*100)):f.clue.percentComplete=100}return{solution:this.solution,clues:u.map(f=>f.clue),proofChain:u,categories:t,targetFact:e}}generateWithBacktracking(t,e,a,s,o,r=1e4,l,i){const n=this.generateAllPossibleClues(t,l,this.reverseSolution,this.valueMap),c=new Y(t);let u=0;const d=Date.now(),m=(y,f,b,C)=>{const w=1+(Date.now()-d)/r*3;if(i&&f.length%1===0){const p=f.length+1,R=y.getGridStats(),x=Math.round((R.totalPossible-R.currentPossible)/(R.totalPossible-R.solutionPossible)*100);Math.random()<.05&&i(`Depth ${p}/${a}: ${x}% Solved. Bias: ${w.toFixed(2)} (Backtracks: ${u})`)}if(this.isPuzzleSolved(y,this.solution,this.reverseSolution))return f.length===a?(i&&i(`SOLVED! Exact match at ${a} clues.`),f):null;if(f.length>=a)return null;const T=y.getGridStats(),P=(T.totalPossible-T.currentPossible)/(T.totalPossible-T.solutionPossible),N=f.length+1;let V=[];if(s<b.length)for(let p=b.length-1;p>0;p--){const R=Math.floor(this.random()*(p+1));[b[p],b[R]]=[b[R],b[p]]}const E=Math.max(1,Math.floor((C?3:s===1/0?50:s)/Math.pow(w,2))),F=Math.min(b.length,E);i&&Math.random()<.001&&i(`Pruning: Limit reduced to ${F} (Bias ${w.toFixed(1)})`);let S=0;for(let p=0;p<b.length&&!(S>=F);p++){const R=b[p],x=y.clone(),{deductions:_}=this.solver.applyClue(x,R);if(_===0||(S++,this.isPuzzleSolved(x,this.solution,this.reverseSolution)&&N<a))continue;let K=this.calculateClueScore(x,e,_,R,f.map(q=>q.clue),this.solution,this.reverseSolution);if(a){const q=N/a,Q=(T.totalPossible-x.getGridStats().currentPossible)/(T.totalPossible-T.solutionPossible),U=Math.pow(q,1.8),Z=Q-U;K-=Z*_*50}V.push({clue:R,deductions:_,score:K,grid:x,index:p})}let O=[],L,k;if(C){const p=C==="STALL";O=V.sort((R,x)=>{const _=R.deductions-x.deductions;return p?_:-_})}else V.sort((p,R)=>R.score-p.score),L=V[0];if(!C){if(k=V[0],a){const p=Math.pow(N/a,1.8);P>p?k=[...V].sort((x,_)=>x.deductions!==_.deductions?x.deductions-_.deductions:_.score-x.score)[0]:k=[...V].sort((x,_)=>x.deductions!==_.deductions?_.deductions-x.deductions:_.score-x.score)[0]}L&&O.push(L),k&&k!==L&&O.push(k);for(const p of V)p!==L&&p!==k&&O.push(p)}for(const p of O){const R=1+(Date.now()-d)/r*4;if(a&&f.length>4&&R>1.1&&!(!!C||p===L||p===k))break;const x=[...b];x.splice(p.index,1);const _=p===L,W=p===k&&p!==L;let K=C,q="";if(!C&&W&&a){const U=P>N/a,Z=`(Prog ${P.toFixed(2)} vs Exp ${(N/a).toFixed(2)})`;K=U?"STALL":"SPEED",q=U?`(Stalling - Weakest) ${Z}`:`(Speeding - Strongest) ${Z}`}else C&&(q=`(Continued ${C})`);if(i&&(W||C||Math.random()<.05)){const U=C?`STICKY ${C}`:_?"Primary":W?"CORRECTION":"Rest";W?i(`[BACKTRACK] Depth ${f.length}: Primary Strategy Failed. Switching to ${q}. Ded: ${p.deductions}`):C?Math.random()<.1&&i(`Depth ${f.length}: ${Math.round(P*100)}% Solved. Strategy: ${U}. Ded: ${p.deductions}`):i(`Depth ${f.length}: ${Math.round(P*100)}% Solved. Trying ${U} Cand. Ded: ${p.deductions}`)}const Q=m(p.grid,[...f,{clue:p.clue,deductions:p.deductions}],x,K);if(Q)return Q}return u++,null},g=m(c,[],[...n]);if(g)return{solution:this.solution,clues:g.map(f=>f.clue),proofChain:g,categories:t,targetFact:e};throw new D(`Could not generate puzzle with exactly ${a} clues within timeout.`)}createSolution(t,e,a,s){var r;const o=t[0];o.values.forEach(l=>{e.set(l,{[o.id]:l})});for(let l=1;l<t.length;l++){const i=t[l],n=[...i.values].sort(()=>this.random()-.5);let c=0;for(const u of o.values){const d=e.get(u);d&&(d[i.id]=n[c++])}}for(const l of t)a[l.id]={},s.set(l.id,new Map);for(const l of o.values){const i=e.get(l);if(i)for(const n in i)a[n][l]=i[n],(r=s.get(n))==null||r.set(i[n],l)}}generateAllPossibleClues(t,e,a,s){var l,i,n,c,u;const o=[];t[0];const r=d=>!(e!=null&&e.allowedClueTypes)||e.allowedClueTypes.includes(d);if(r(v.BINARY))for(const d of t)for(const m of d.values)for(const g of t){if(d.id>=g.id)continue;const y=(l=a.get(d.id))==null?void 0:l.get(m);if(!y)continue;const f=s.get(y);if(f)for(const b of g.values){const C=f[g.id];b===C?o.push({type:v.BINARY,operator:z.IS,cat1:d.id,val1:m,cat2:g.id,val2:b}):o.push({type:v.BINARY,operator:z.IS_NOT,cat1:d.id,val1:m,cat2:g.id,val2:b})}}for(const d of t.filter(m=>m.type===$.ORDINAL)){const m=[...d.values].sort((f,b)=>f-b),g=m[0],y=m[m.length-1];if(r(v.SUPERLATIVE)){for(const f of t)if(f.id!==d.id)for(const b of f.values){const C=(i=a.get(f.id))==null?void 0:i.get(b);if(!C)continue;const I=s.get(C);if(!I)continue;const A=I[d.id];A===g?o.push({type:v.SUPERLATIVE,operator:G.MIN,targetCat:f.id,targetVal:b,ordinalCat:d.id}):o.push({type:v.SUPERLATIVE,operator:G.NOT_MIN,targetCat:f.id,targetVal:b,ordinalCat:d.id}),A===y?o.push({type:v.SUPERLATIVE,operator:G.MAX,targetCat:f.id,targetVal:b,ordinalCat:d.id}):o.push({type:v.SUPERLATIVE,operator:G.NOT_MAX,targetCat:f.id,targetVal:b,ordinalCat:d.id})}}if(r(v.ORDINAL)){for(const f of t)if(f.id!==d.id){for(const b of t)if(b.id!==d.id)for(const C of f.values)for(const I of b.values){if(f.id===b.id&&C===I)continue;const A=(n=a.get(f.id))==null?void 0:n.get(C),w=(c=a.get(b.id))==null?void 0:c.get(I);if(!A||!w||A===w)continue;const H=s.get(A),T=s.get(w);if(!H||!T)continue;const P=H[d.id],N=T[d.id];P>N?(o.push({type:v.ORDINAL,operator:M.GREATER_THAN,item1Cat:f.id,item1Val:C,item2Cat:b.id,item2Val:I,ordinalCat:d.id}),o.push({type:v.ORDINAL,operator:M.NOT_LESS_THAN,item1Cat:f.id,item1Val:C,item2Cat:b.id,item2Val:I,ordinalCat:d.id})):P<N&&(o.push({type:v.ORDINAL,operator:M.LESS_THAN,item1Cat:f.id,item1Val:C,item2Cat:b.id,item2Val:I,ordinalCat:d.id}),o.push({type:v.ORDINAL,operator:M.NOT_GREATER_THAN,item1Cat:f.id,item1Val:C,item2Cat:b.id,item2Val:I,ordinalCat:d.id}))}}}}if(r(v.UNARY)){for(const d of t)if(d.type===$.ORDINAL&&d.values.every(m=>typeof m=="number")){for(const m of t)if(m.id!==d.id)for(const g of m.values){const y=(u=a.get(m.id))==null?void 0:u.get(g);if(!y)continue;const f=s.get(y);if(!f)continue;f[d.id]%2===0?o.push({type:v.UNARY,filter:j.IS_EVEN,targetCat:m.id,targetVal:g,ordinalCat:d.id}):o.push({type:v.UNARY,filter:j.IS_ODD,targetCat:m.id,targetVal:g,ordinalCat:d.id})}}}return o}calculateClueScore(t,e,a,s,o,r,l){var F;const i=s.type,n=(F=l.get(e.category1Id))==null?void 0:F.get(e.value1);let c;n!==void 0&&(c=r[e.category2Id][n]);const u=c!==void 0&&t.isPossible(e.category1Id,e.value1,e.category2Id,c)&&t.getPossibilitiesCount(e.category1Id,e.value1,e.category2Id)===1,d=this.isPuzzleSolved(t,r,l);if(s.type===v.BINARY&&s.operator===z.IS){const S=s;if(S.cat1===e.category1Id&&S.val1===e.value1&&S.cat2===e.category2Id&&S.val2===c||S.cat1===e.category2Id&&S.val1===c&&S.cat2===e.category1Id&&S.val2===e.value1)return-1/0}if(u&&d)return 1e6;if(u&&!d)return-1e6;const m=a,{totalPossible:g,currentPossible:y,solutionPossible:f}=t.getGridStats(),b=g-f,C=g-y,I=b>0?C/b:0;let A=0;switch(i){case v.ORDINAL:A=1.5,s.operator>=2&&(A=5);break;case v.SUPERLATIVE:A=1.2,s.operator>=2&&(A=5);break;case v.UNARY:A=1.2;break;case v.BINARY:A=1,s.operator===z.IS_NOT&&(A=5);break}let w=0;const H=S=>{const O=(p,R)=>{var x;return(x=this.reverseSolution.get(p))==null?void 0:x.get(R)};let L=[],k=[];switch(S.type){case v.BINARY:const p=S;L.push(O(p.cat1,p.val1)),p.operator===z.IS_NOT&&k.push(O(p.cat2,p.val2));break;case v.SUPERLATIVE:const R=S;L.push(O(R.targetCat,R.targetVal));break;case v.ORDINAL:const x=S;L.push(O(x.item1Cat,x.item1Val)),k.push(O(x.item2Cat,x.item2Val));break;case v.UNARY:const _=S;L.push(O(_.targetCat,_.targetVal));break}return{primary:L.filter(p=>!!p),secondary:k.filter(p=>!!p)}},T=new Set;for(const S of o){const{primary:O,secondary:L}=H(S);O.forEach(k=>T.add(k)),L.forEach(k=>T.add(k))}const{primary:P,secondary:N}=H(s);P.forEach(S=>{T.has(S)&&(w+=1)}),N.forEach(S=>{T.has(S)&&(w+=.5)});const V=s.ordinalCat;if(V)for(const S of o){const O=S.ordinalCat;V===O&&(w+=.5)}if(o.length>0){const S=o[o.length-1];if(s.type===S.type&&(w+=2,s.type===v.BINARY&&s.operator===z.IS&&S.operator===z.IS&&(w+=2)),o.length>1){const p=o[o.length-2];s.type===S.type&&s.type===p.type&&(w+=5)}const O=p=>{switch(p.type){case v.SUPERLATIVE:return 1;case v.BINARY:return p.operator===z.IS?1:3;case v.ORDINAL:return 3;case v.UNARY:return 3;case v.CROSS_ORDINAL:return 4;default:return 2}},L=O(s),k=O(S);L===k&&(w+=1.5)}const B=Math.pow(.4,w);return(m*A+I*5)*B}checkClueConsistency(t,e,a,s){const o=(i,n,c)=>{var d;const u=(d=a.get(i))==null?void 0:d.get(n);if(u)return e[c][u]},r=(i,n)=>{var c;return(c=a.get(i))==null?void 0:c.get(n)},l=(i,n,c)=>{const u=r(i,n);if(!u)return;const d=s.get(u);if(!d)return;const m=d[c];return typeof m=="number"?m:void 0};switch(t.type){case v.BINARY:{const i=t,n=o(i.cat1,i.val1,i.cat2);if(n===void 0)return!1;if(i.operator===z.IS)return n===i.val2;if(i.operator===z.IS_NOT)return n!==i.val2;break}case v.ORDINAL:{const i=t,n=l(i.item1Cat,i.item1Val,i.ordinalCat),c=l(i.item2Cat,i.item2Val,i.ordinalCat);if(n===void 0||c===void 0)return!1;switch(i.operator){case M.GREATER_THAN:return n>c;case M.LESS_THAN:return n<c;case M.NOT_GREATER_THAN:return n<=c;case M.NOT_LESS_THAN:return n>=c}break}case v.SUPERLATIVE:{const i=t,n=l(i.targetCat,i.targetVal,i.ordinalCat);if(n===void 0)return!1;let c=1/0,u=-1/0;for(const d of this.valueMap.keys()){const m=this.valueMap.get(d);if(m){const g=m[i.ordinalCat];typeof g=="number"&&(g<c&&(c=g),g>u&&(u=g))}}if(c===1/0)return!1;switch(i.operator){case G.MIN:return n===c;case G.MAX:return n===u;case G.NOT_MIN:return n!==c;case G.NOT_MAX:return n!==u}break}case v.UNARY:{const i=t,n=l(i.targetCat,i.targetVal,i.ordinalCat);if(n===void 0)return!1;switch(i.filter){case j.IS_ODD:return n%2!==0;case j.IS_EVEN:return n%2===0}break}case v.CROSS_ORDINAL:{const i=t,n=l(i.item1Cat,i.item1Val,i.ordinal1),c=l(i.item2Cat,i.item2Val,i.ordinal2);if(n===void 0||c===void 0)return!1;switch(i.operator){case M.GREATER_THAN:return n>c;case M.LESS_THAN:return n<c;case M.NOT_GREATER_THAN:return n<=c;case M.NOT_LESS_THAN:return n>=c}break}}return!0}isPuzzleSolved(t,e,a){var o;const s=t.categories;s[0];for(const r of s)for(const l of r.values)for(const i of s){if(r.id>=i.id)continue;const n=(o=a.get(r.id))==null?void 0:o.get(l);if(!n)return!1;const c=e[i.id][n];if(t.getPossibilitiesCount(r.id,l,i.id)>1||!t.isPossible(r.id,l,i.id,c))return!1}return!0}}const X=self;X.onmessage=h=>{const{type:t}=h.data;if(t==="start"){const{categories:e,targetFact:a,options:s}=h.data;s&&s.targetClueCount&&(s.targetClueCount=parseInt(String(s.targetClueCount),10));try{const o=new J(s==null?void 0:s.seed),r={...s,onTrace:i=>{X.postMessage({type:"trace",message:i})}};let l;try{l=o.generatePuzzle(e,a,r)}catch(i){if(s.targetClueCount&&i.message&&i.message.includes("Could not generate puzzle")){X.postMessage({type:"trace",message:`⚠️ Strict generation failed (${i.message}). Falling back to best-effort generation...`});const n={...r,targetClueCount:void 0};l=o.generatePuzzle(e,a,n)}else throw i}X.postMessage({type:"done",puzzle:l})}catch(o){console.error("Worker Generation Error:",o),X.postMessage({type:"error",message:o.message||"Unknown worker error"})}}}})();
