(function(){"use strict";var D=(c=>(c[c.NOMINAL=0]="NOMINAL",c[c.ORDINAL=1]="ORDINAL",c))(D||{}),p=(c=>(c[c.BINARY=0]="BINARY",c[c.ORDINAL=1]="ORDINAL",c[c.SUPERLATIVE=2]="SUPERLATIVE",c[c.UNARY=3]="UNARY",c[c.CROSS_ORDINAL=4]="CROSS_ORDINAL",c))(p||{}),W=(c=>(c[c.MATCH=0]="MATCH",c[c.NOT_MATCH=1]="NOT_MATCH",c))(W||{}),O=(c=>(c[c.IS=0]="IS",c[c.IS_NOT=1]="IS_NOT",c))(O||{}),L=(c=>(c[c.GREATER_THAN=0]="GREATER_THAN",c[c.LESS_THAN=1]="LESS_THAN",c[c.NOT_GREATER_THAN=2]="NOT_GREATER_THAN",c[c.NOT_LESS_THAN=3]="NOT_LESS_THAN",c))(L||{}),k=(c=>(c[c.MIN=0]="MIN",c[c.MAX=1]="MAX",c[c.NOT_MIN=2]="NOT_MIN",c[c.NOT_MAX=3]="NOT_MAX",c))(k||{}),F=(c=>(c[c.IS_ODD=0]="IS_ODD",c[c.IS_EVEN=1]="IS_EVEN",c))(F||{});class Q extends Error{constructor(e){super(e),this.name="LogicPuzzleError"}}class R extends Q{constructor(e){super(e),this.name="ConfigurationError"}}class U{constructor(e){this.validateConfig(e),this.categories=e,this.valueMap=new Map(e.map(t=>[t.id,new Map(t.values.map((a,s)=>[a,s]))])),this.grid=new Map;for(const t of e){const a=new Map;for(const s of t.values){const o=new Map;for(const l of e)t.id!==l.id&&o.set(l.id,Array(l.values.length).fill(!0));a.set(s,o)}this.grid.set(t.id,a)}}validateConfig(e){const t=new Set;let a=-1;for(const s of e){if(t.has(s.id))throw new R(`Duplicate category ID found: ${s.id}`);if(t.add(s.id),new Set(s.values).size!==s.values.length)throw new R(`Category '${s.id}' has duplicate values.`);if(a===-1)a=s.values.length;else if(s.values.length!==a)throw new R(`Category '${s.id}' has ${s.values.length} values, expected ${a}. All categories must be the same size.`)}}setPossibility(e,t,a,s,o){var i,r;const l=(i=this.valueMap.get(a))==null?void 0:i.get(s);if(l!==void 0){const f=this.grid.get(e);if(f){const h=f.get(t);if(h){const d=h.get(a);d&&(d[l]=o)}}}const n=(r=this.valueMap.get(e))==null?void 0:r.get(t);if(n!==void 0){const f=this.grid.get(a);if(f){const h=f.get(s);if(h){const d=h.get(e);d&&(d[n]=o)}}}}isPossible(e,t,a,s){var r;if(e===a)return t===s;const o=(r=this.valueMap.get(a))==null?void 0:r.get(s);if(o===void 0)return!1;const l=this.grid.get(e);if(!l)return!1;const n=l.get(t);if(!n)return!1;const i=n.get(a);return i?i[o]:!1}getPossibilitiesCount(e,t,a){var o,l;const s=(l=(o=this.grid.get(e))==null?void 0:o.get(t))==null?void 0:l.get(a);return s?s.filter(n=>n).length:0}getGridStats(){var n,i,r;let e=0;const t=this.categories.length,a=((n=this.categories[0])==null?void 0:n.values.length)||0;if(a===0||t<2)return{totalPossible:0,currentPossible:0,solutionPossible:0};const s=t*(t-1)/2,o=s*a*a,l=s*a;for(const f of this.categories)for(const h of f.values)for(const d of this.categories){if(f.id>=d.id)continue;const u=(r=(i=this.grid.get(f.id))==null?void 0:i.get(h))==null?void 0:r.get(d.id);u&&(e+=u.filter(g=>g).length)}return{totalPossible:o,currentPossible:e,solutionPossible:l}}clone(){const e=new U(this.categories);return e.grid=new Map([...this.grid.entries()].map(([t,a])=>[t,new Map([...a.entries()].map(([s,o])=>[s,new Map([...o.entries()].map(([l,n])=>[l,[...n]]))]))])),e}}class J{applyClue(e,t){let a=0;switch(t.type){case p.BINARY:a+=this.applyBinaryClue(e,t);break;case p.SUPERLATIVE:a+=this.applySuperlativeClue(e,t);break;case p.ORDINAL:a+=this.applyOrdinalClue(e,t);break;case p.UNARY:a+=this.applyUnaryClue(e,t);break;case p.CROSS_ORDINAL:a+=this.applyCrossOrdinalClue(e,t);break}let s;do s=this.runDeductionLoop(e),a+=s;while(s>0);return{grid:e,deductions:a}}applyCrossOrdinalClue(e,t){let a=0;const s=e.categories,o=s.find(h=>h.id===t.ordinal1),l=s.find(h=>h.id===t.ordinal2);if(!o||!l)return 0;const n=t.operator===W.NOT_MATCH,i=(h,d,u,g)=>g.values.map((v,m)=>({val:v,idx:m})).filter(v=>e.isPossible(h,d,u,v.val)),r=i(t.item1Cat,t.item1Val,t.ordinal1,o),f=i(t.item2Cat,t.item2Val,t.ordinal2,l);if(n){if(r.length===1&&f.length===1){const h=r[0].idx+t.offset1,d=f[0].idx+t.offset2,u=o.values[h],g=l.values[d];u!==void 0&&g!==void 0&&e.isPossible(t.ordinal1,u,t.ordinal2,g)&&(e.setPossibility(t.ordinal1,u,t.ordinal2,g,!1),a++)}for(const h of r){const d=h.idx+t.offset1;if(o.values[d]!==void 0)for(const g of f){const v=g.idx+t.offset2;l.values[v]}}if(r.length===1){const h=r[0].idx+t.offset1,d=o.values[h];if(d!==void 0)for(const u of f){const g=u.idx+t.offset2,v=l.values[g];v!==void 0&&e.isPossible(t.ordinal1,d,t.ordinal2,v)&&(e.setPossibility(t.item2Cat,t.item2Val,t.ordinal2,u.val,!1),a++)}}if(f.length===1){const h=f[0].idx+t.offset2,d=l.values[h];if(d!==void 0)for(const u of r){const g=u.idx+t.offset1,v=o.values[g];v!==void 0&&e.isPossible(t.ordinal1,v,t.ordinal2,d)&&(e.setPossibility(t.item1Cat,t.item1Val,t.ordinal1,u.val,!1),a++)}}}else{for(const u of r){const g=u.idx+t.offset1,v=o.values[g];if(v===void 0){e.setPossibility(t.item1Cat,t.item1Val,t.ordinal1,u.val,!1),a++;continue}let m=!1;for(const C of f){const y=C.idx+t.offset2,A=l.values[y];if(A!==void 0&&e.isPossible(t.ordinal1,v,t.ordinal2,A)){m=!0;break}}m||(e.setPossibility(t.item1Cat,t.item1Val,t.ordinal1,u.val,!1),a++)}for(const u of f){const g=u.idx+t.offset2,v=l.values[g];if(v===void 0){e.setPossibility(t.item2Cat,t.item2Val,t.ordinal2,u.val,!1),a++;continue}let m=!1;for(const C of r){const y=C.idx+t.offset1,A=o.values[y];if(A!==void 0&&e.isPossible(t.ordinal1,A,t.ordinal2,v)){m=!0;break}}m||(e.setPossibility(t.item2Cat,t.item2Val,t.ordinal2,u.val,!1),a++)}const h=i(t.item1Cat,t.item1Val,t.ordinal1,o),d=i(t.item2Cat,t.item2Val,t.ordinal2,l);if(h.length===1&&d.length===1){const u=h[0].idx+t.offset1,g=d[0].idx+t.offset2,v=o.values[u],m=l.values[g];v!==void 0&&m!==void 0&&e.getPossibilitiesCount(t.ordinal1,v,t.ordinal2)>1&&(e.setPossibility(t.ordinal1,v,t.ordinal2,m,!0),a++)}}return a}applyUnaryClue(e,t){let a=0;const o=e.categories.find(n=>n.id===t.ordinalCat);if(!o||o.type!==D.ORDINAL||!o.values.every(n=>typeof n=="number"))return 0;const l=t.filter===F.IS_EVEN;for(const n of o.values){const i=n;(l?i%2!==0:i%2===0)&&e.isPossible(t.targetCat,t.targetVal,t.ordinalCat,n)&&(e.setPossibility(t.targetCat,t.targetVal,t.ordinalCat,n,!1),a++)}return a}applyBinaryClue(e,t){let a=0;const s=e.categories,o=s.find(n=>n.id===t.cat1),l=s.find(n=>n.id===t.cat2);if(!o||!l)return 0;if(t.operator===O.IS){e.isPossible(t.cat1,t.val1,t.cat2,t.val2),e.setPossibility(t.cat1,t.val1,t.cat2,t.val2,!0);for(const n of l.values)n!==t.val2&&e.isPossible(t.cat1,t.val1,t.cat2,n)&&(e.setPossibility(t.cat1,t.val1,t.cat2,n,!1),a++);for(const n of o.values)n!==t.val1&&e.isPossible(t.cat1,n,t.cat2,t.val2)&&(e.setPossibility(t.cat1,n,t.cat2,t.val2,!1),a++)}else e.isPossible(t.cat1,t.val1,t.cat2,t.val2)&&(e.setPossibility(t.cat1,t.val1,t.cat2,t.val2,!1),a++);return a}runDeductionLoop(e){let t=0;const a=e.categories;for(const s of a)for(const o of s.values)for(const l of a){if(s.id===l.id)continue;const n=l.values.filter(i=>e.isPossible(s.id,o,l.id,i));if(n.length===1){const i=n[0];for(const r of s.values)r!==o&&e.isPossible(s.id,r,l.id,i)&&(e.setPossibility(s.id,r,l.id,i,!1),t++)}for(const i of a){if(s.id===i.id||l.id===i.id)continue;const r=n.length===1?n[0]:null;if(r){const f=i.values.filter(h=>e.isPossible(l.id,r,i.id,h));if(f.length===1){const h=f[0];e.isPossible(s.id,o,i.id,h)===!1||e.getPossibilitiesCount(s.id,o,i.id)>1&&(e.setPossibility(s.id,o,i.id,h,!0),t++)}}for(const f of i.values)e.isPossible(s.id,o,i.id,f)&&(l.values.some(d=>e.isPossible(s.id,o,l.id,d)&&e.isPossible(l.id,d,i.id,f))||(e.setPossibility(s.id,o,i.id,f,!1),t++))}}return t}applyOrdinalClue(e,t){let a=0;const o=e.categories.find(i=>i.id===t.ordinalCat);if(!o||o.type!==D.ORDINAL)return 0;const l=o.values.map((i,r)=>({val:i,idx:r})).filter(i=>e.isPossible(t.item1Cat,t.item1Val,t.ordinalCat,i.val)),n=o.values.map((i,r)=>({val:i,idx:r})).filter(i=>e.isPossible(t.item2Cat,t.item2Val,t.ordinalCat,i.val));if(l.length===0||n.length===0)return 0;if(t.operator===L.GREATER_THAN)for(const i of l)n.some(f=>i.idx>f.idx)||e.isPossible(t.item1Cat,t.item1Val,t.ordinalCat,i.val)&&(e.setPossibility(t.item1Cat,t.item1Val,t.ordinalCat,i.val,!1),a++);else if(t.operator===L.LESS_THAN)for(const i of l)n.some(f=>i.idx<f.idx)||e.isPossible(t.item1Cat,t.item1Val,t.ordinalCat,i.val)&&(e.setPossibility(t.item1Cat,t.item1Val,t.ordinalCat,i.val,!1),a++);else if(t.operator===L.NOT_GREATER_THAN)for(const i of l)n.some(f=>i.idx<=f.idx)||e.isPossible(t.item1Cat,t.item1Val,t.ordinalCat,i.val)&&(e.setPossibility(t.item1Cat,t.item1Val,t.ordinalCat,i.val,!1),a++);else if(t.operator===L.NOT_LESS_THAN)for(const i of l)n.some(f=>i.idx>=f.idx)||e.isPossible(t.item1Cat,t.item1Val,t.ordinalCat,i.val)&&(e.setPossibility(t.item1Cat,t.item1Val,t.ordinalCat,i.val,!1),a++);if(t.operator===L.GREATER_THAN)for(const i of n)l.some(f=>i.idx<f.idx)||e.isPossible(t.item2Cat,t.item2Val,t.ordinalCat,i.val)&&(e.setPossibility(t.item2Cat,t.item2Val,t.ordinalCat,i.val,!1),a++);else if(t.operator===L.LESS_THAN)for(const i of n)l.some(f=>i.idx>f.idx)||e.isPossible(t.item2Cat,t.item2Val,t.ordinalCat,i.val)&&(e.setPossibility(t.item2Cat,t.item2Val,t.ordinalCat,i.val,!1),a++);else if(t.operator===L.NOT_GREATER_THAN)for(const i of n)l.some(f=>i.idx>=f.idx)||e.isPossible(t.item2Cat,t.item2Val,t.ordinalCat,i.val)&&(e.setPossibility(t.item2Cat,t.item2Val,t.ordinalCat,i.val,!1),a++);else if(t.operator===L.NOT_LESS_THAN)for(const i of n)l.some(f=>i.idx<=f.idx)||e.isPossible(t.item2Cat,t.item2Val,t.ordinalCat,i.val)&&(e.setPossibility(t.item2Cat,t.item2Val,t.ordinalCat,i.val,!1),a++);return a}applySuperlativeClue(e,t){const s=e.categories.find(i=>i.id===t.ordinalCat);if(!s||s.type!==D.ORDINAL)return 0;let o,l=!1;switch(t.operator){case k.MAX:o=s.values[s.values.length-1];break;case k.MIN:o=s.values[0];break;case k.NOT_MAX:o=s.values[s.values.length-1],l=!0;break;case k.NOT_MIN:o=s.values[0],l=!0;break;default:return 0}const n={type:p.BINARY,cat1:t.targetCat,val1:t.targetVal,cat2:t.ordinalCat,val2:o,operator:l?O.IS_NOT:O.IS};return this.applyBinaryClue(e,n)}}class Z{constructor(e,t,a,s,o,l){this.generator=e,this.categories=t,this.solution=a,this.reverseSolution=s,this.valueMap=o,this.targetFact=l,this.availableClues=[],this.proofChain=[],this.historyStack=[],this.grid=new U(t),this.solver=new J,this.availableClues=this.generator.generateAllPossibleClues(t,void 0,s,o)}getNextClue(e){const t=this.availableClues.filter(i=>!(e!=null&&e.allowedClueTypes&&!e.allowedClueTypes.includes(i.type)));let a=null,s=-1/0;const o=[...t].sort(()=>Math.random()-.5),l=50;let n=0;for(const i of o){if(n++,n>l&&a)break;this.generator.publicCalculateScore(this.grid,this.targetFact,0,i,this.proofChain,this.solution,this.reverseSolution);const r=this.grid.clone(),{deductions:f}=this.solver.applyClue(r,i);if(f===0&&!this.isUseful(r))continue;const h=this.generator.publicCalculateScore(this.grid,this.targetFact,f,i,this.proofChain,this.solution,this.reverseSolution);h>s&&(s=h,a=i)}if(a){this.historyStack.push(this.grid.clone()),this.solver.applyClue(this.grid,a),this.proofChain.push(a);const i=this.availableClues.indexOf(a);return i>-1&&this.availableClues.splice(i,1),{clue:a,remaining:this.availableClues.length,solved:this.generator.isPuzzleSolved(this.grid,this.solution,this.reverseSolution)}}return{clue:null,remaining:t.length,solved:this.generator.isPuzzleSolved(this.grid,this.solution,this.reverseSolution)}}rollbackLastClue(){if(this.historyStack.length===0)return{success:!1,clue:null};const e=this.historyStack.pop();e&&(this.grid=e);const t=this.proofChain.pop();return t?(this.availableClues.push(t),{success:!0,clue:t}):{success:!1,clue:null}}isUseful(e){return!0}getGrid(){return this.grid}getProofChain(){return this.proofChain}getSolution(){return this.solution}getValueMap(){return this.valueMap}}const K={"2x3":{min:2,max:2},"2x4":{min:3,max:10},"2x5":{min:4,max:17},"2x6":{min:5,max:26},"2x7":{min:6,max:37},"2x8":{min:7,max:50},"2x9":{min:8,max:65},"2x10":{min:9,max:82},"3x3":{min:3,max:9},"3x4":{min:5,max:26},"3x5":{min:7,max:47},"3x6":{min:9,max:72},"3x7":{min:11,max:100},"3x8":{min:13,max:130},"3x9":{min:15,max:160},"3x10":{min:17,max:200},"4x3":{min:5,max:16},"4x4":{min:8,max:44},"4x5":{min:11,max:87},"4x6":{min:14,max:140},"4x7":{min:17,max:200},"4x8":{min:20,max:260},"4x9":{min:23,max:330},"4x10":{min:26,max:400},"5x3":{min:7,max:25},"5x4":{min:11,max:70},"5x5":{min:15,max:130},"5x6":{min:19,max:200},"5x7":{min:23,max:280},"5x8":{min:27,max:370},"5x9":{min:31,max:470},"5x10":{min:35,max:580}},tt=(c,e)=>{const t=`${c}x${e}`;if(K[t])return K[t];const a=(c-1)*e,s=Math.max(5,Math.floor(a*.7)),o=Math.floor(a*5);return{min:s,max:o}};function et(c){return function(){c|=0,c=c+1831565813|0;var e=Math.imul(c^c>>>15,1|c);return e=e+Math.imul(e^e>>>7,61|e)^e,((e^e>>>14)>>>0)/4294967296}}class X{constructor(e){this.solution={},this.valueMap=new Map,this.reverseSolution=new Map,this.seed=e,this.random=et(e),this.solver=new J}getClueCountBounds(e,t,a=10){let s=1/0,o=0;for(let l=0;l<a;l++){const n=this.seed+l+1,i=new X(n);try{const r=i.internalGenerate(e,t,"min");r&&(s=Math.min(s,r.clues.length))}catch{}try{const f=new X(n).internalGenerate(e,t,"max");f&&(o=Math.max(o,f.clues.length))}catch{}}return s===1/0&&(s=0),{min:s,max:o}}generatePuzzle(e,t,a={}){const{targetClueCount:s,maxCandidates:o=50,timeoutMs:l=1e4}=a;if(e.length<2)throw new R("Must have at least 2 categories.");if(s!==void 0&&s<1)throw new R("Target clue count must be at least 1");if(o<1)throw new R("maxCandidates must be at least 1");let n=t;if(!n){const r=Math.floor(this.random()*e.length);let f=Math.floor(this.random()*e.length);for(;f===r;)f=Math.floor(this.random()*e.length);const h=e[r],d=e[f],u=Math.floor(this.random()*h.values.length);n={category1Id:h.id,value1:h.values[u],category2Id:d.id}}const i=new Set(e.map(r=>r.id));if(!i.has(n.category1Id)||!i.has(n.category2Id))throw new R("Target fact refers to non-existent categories.");if(n.category1Id===n.category2Id)throw new R("Target fact must refer to two different categories.");return this.internalGenerate(e,n,"standard",{maxCandidates:o,targetClueCount:s,timeoutMs:l,constraints:a.constraints,onTrace:a.onTrace})}startSession(e,t){if(e.length<2)throw new R("Must have at least 2 categories.");let a=t;if(!a){const n=Math.floor(this.random()*e.length);let i=Math.floor(this.random()*e.length);for(;i===n;)i=Math.floor(this.random()*e.length);const r=e[n],f=e[i],h=Math.floor(this.random()*r.values.length);a={category1Id:r.id,value1:r.values[h],category2Id:f.id}}const s=new Map,o={},l=new Map;return this.createSolution(e,s,o,l),new Z(this,e,o,l,s,a)}internalGenerate(e,t,a,s){if(!e||e.length<2)throw new R("At least 2 categories are required to generate a puzzle.");const o=(s==null?void 0:s.maxCandidates)??1/0,l=s==null?void 0:s.targetClueCount,n=s==null?void 0:s.constraints;s!=null&&s.onTrace&&s.onTrace("Generator: internalGenerate started.");const i=e.find(u=>u.id===t.category1Id);if(i&&!i.values.includes(t.value1))throw new R(`Target value '${t.value1}' does not exist in category '${t.category1Id}'.`);if(n!=null&&n.allowedClueTypes){const u=e.some(m=>m.type===D.ORDINAL),g=[p.ORDINAL,p.SUPERLATIVE,p.UNARY,p.CROSS_ORDINAL],v=n.allowedClueTypes.some(m=>g.includes(m));if(n.allowedClueTypes.every(m=>g.includes(m)),v&&!u&&!u&&!n.allowedClueTypes.includes(p.BINARY))throw new R("Invalid Constraints: Ordinal-based clue types were requested, but no Ordinal categories exist. Please add an ordinal category or allow Binary clues.")}for(const u of e)if(u.type===D.ORDINAL&&u.values.some(v=>typeof v!="number"&&isNaN(Number(v))))throw new R(`Category '${u.id}' is ORDINAL but contains non-numeric values.`);if(this.valueMap=new Map,this.solution={},this.reverseSolution=new Map,s!=null&&s.onTrace&&s.onTrace("Generator: Creating solution..."),this.createSolution(e,this.valueMap,this.solution,this.reverseSolution),s!=null&&s.onTrace&&s.onTrace("Generator: Solution created."),l!==void 0){const u=e.length,g=e[0].values.length,v=tt(u,g);s!=null&&s.onTrace&&s.onTrace(`Generator: Feasibility check complete. Recommended bounds: ${v.min}-${v.max}`);const m=0;let C=l;v.min>0&&l<v.min-m&&(console.warn(`Target clue count ${l} is too low (Estimated min: ${v.min}). Auto-adjusting to ${v.min}.`),C=v.min);try{return this.generateWithBacktracking(e,t,C,o,a,(s==null?void 0:s.timeoutMs)??1e4,s==null?void 0:s.constraints,s==null?void 0:s.onTrace)}catch(y){throw y}}s!=null&&s.onTrace&&s.onTrace("Generator: Generating all possible clues...");let r=this.generateAllPossibleClues(e,s==null?void 0:s.constraints,this.reverseSolution,this.valueMap);s!=null&&s.onTrace&&s.onTrace(`Generator: Generated ${r.length} candidate clues.`);const f=new U(e),h=[],d=100;for(;h.length<d;){if(s!=null&&s.onTrace){const x=h.length,I=f.getGridStats(),T=Math.max(1,I.totalPossible-I.solutionPossible),E=Math.max(0,I.currentPossible-I.solutionPossible),w=Math.min(100,Math.round((T-E)/T*100));if(s.onTrace(`Depth ${x}: ${w}% Solved. Candidates: ${r.length}`),w>=100&&this.isPuzzleSolved(f,this.solution,this.reverseSolution)){s.onTrace("Generator: Puzzle Solved (100%).");break}}let u=null,g=null;if(o<r.length)for(let x=r.length-1;x>0;x--){const I=Math.floor(this.random()*(x+1));[r[x],r[I]]=[r[I],r[x]]}const v=Math.min(r.length,o);let m=0;for(let x=r.length-1;x>=0&&!(m>=v);x--){const I=r[x],T=f.clone(),{deductions:E}=this.solver.applyClue(T,I);if(E===0){r.splice(x,1);continue}m++;let w=0;a==="min"?w=E*1e3:a==="max"?w=100/E:w=this.publicCalculateScore(T,t,E,I,h.map(P=>P.clue),this.solution,this.reverseSolution),I.type;const B=this.solution[t.category2Id][t.value1],$=T.isPossible(t.category1Id,t.value1,t.category2Id,B)&&T.getPossibilitiesCount(t.category1Id,t.value1,t.category2Id)===1,Y=this.isPuzzleSolved(T,this.solution,this.reverseSolution);$&&(Y?g={clue:I,score:w+1e6}:w=-1e6),w>-999999&&(!u||w>u.score)&&(u={clue:I,score:w})}const C=g||u;if(!C)break;const y=C.clue,{deductions:A}=this.solver.applyClue(f,y);h.push({clue:y,deductions:A});const N=r.findIndex(x=>JSON.stringify(x)===JSON.stringify(y));if(N>-1&&r.splice(N,1),this.isPuzzleSolved(f,this.solution,this.reverseSolution))break}return{solution:this.solution,clues:h.map(u=>u.clue),proofChain:h,categories:e,targetFact:t}}generateWithBacktracking(e,t,a,s,o,l=1e4,n,i){const r=this.generateAllPossibleClues(e,n,this.reverseSolution,this.valueMap),f=new U(e);let h=0;const d=Date.now(),u=(v,m,C)=>{if(Date.now()-d>l)return null;const y=1+h*.05;if(i&&m.length%1===0){const P=m.length,b=v.getGridStats(),S=Math.round((b.totalPossible-b.currentPossible)/(b.totalPossible-b.solutionPossible)*100);Math.random()<.05&&i(`Depth ${P}/${a}: ${S}% Solved. Bias: ${y.toFixed(2)} (Backtracks: ${h})`)}if(this.isPuzzleSolved(v,this.solution,this.reverseSolution))return m.length===a?(i&&i(`SOLVED! Exact match at ${a} clues.`),m):null;if(m.length>=a)return null;const N=v.getGridStats(),x=(N.totalPossible-N.currentPossible)/(N.totalPossible-N.solutionPossible),I=m.length+1,T=x<I/a*y;let E=[];if(s<C.length)for(let P=C.length-1;P>0;P--){const b=Math.floor(this.random()*(P+1));[C[P],C[b]]=[C[b],C[P]]}const B=Math.max(1,Math.floor((s===1/0?50:s)/Math.pow(y,3))),$=Math.min(C.length,B);i&&Math.random()<.001&&i(`Pruning: Limit reduced to ${$} (Bias ${y.toFixed(1)})`);let Y=0;for(let P=0;P<C.length&&!(Y>=$);P++){const b=C[P],S=v.clone(),{deductions:M}=this.solver.applyClue(S,b);if(M===0||(Y++,this.isPuzzleSolved(S,this.solution,this.reverseSolution)&&I<a))continue;const V=this.publicCalculateScore(S,t,M,b,m.map(st=>st.clue),this.solution,this.reverseSolution);let z=0;T?z=M*10:z=1/M*10;const G=I>=a-2,q=I===a;G&&(z*=10,q&&(z*=10));let j=z+V;q&&this.isPuzzleSolved(S,this.solution,this.reverseSolution)&&(j+=1e6),j+=this.random(),E.push({clue:b,deductions:M,score:j,grid:S,index:P})}E.sort((P,b)=>b.score-P.score);for(const P of E){const b=[...C];b.splice(P.index,1);const S=u(P.grid,[...m,{clue:P.clue,deductions:P.deductions}],b);if(S)return S}return h++,null},g=u(f,[],[...r]);if(g)return{solution:this.solution,clues:g.map(v=>v.clue),proofChain:g,categories:e,targetFact:t};throw new R(`Could not generate puzzle with exactly ${a} clues within timeout.`)}createSolution(e,t,a,s){var l;const o=e[0];o.values.forEach(n=>{t.set(n,{[o.id]:n})});for(let n=1;n<e.length;n++){const i=e[n],r=[...i.values].sort(()=>this.random()-.5);let f=0;for(const h of o.values){const d=t.get(h);d&&(d[i.id]=r[f++])}}for(const n of e)a[n.id]={},s.set(n.id,new Map);for(const n of o.values){const i=t.get(n);if(i)for(const r in i)a[r][n]=i[r],(l=s.get(r))==null||l.set(i[r],n)}}generateAllPossibleClues(e,t,a,s){var n,i,r,f,h;const o=[];e[0];const l=d=>!(t!=null&&t.allowedClueTypes)||t.allowedClueTypes.includes(d);if(l(p.BINARY))for(const d of e)for(const u of d.values)for(const g of e){if(d.id>=g.id)continue;const v=(n=a.get(d.id))==null?void 0:n.get(u);if(!v)continue;const m=s.get(v);if(m)for(const C of g.values){const y=m[g.id];C===y?o.push({type:p.BINARY,operator:O.IS,cat1:d.id,val1:u,cat2:g.id,val2:C}):o.push({type:p.BINARY,operator:O.IS_NOT,cat1:d.id,val1:u,cat2:g.id,val2:C})}}for(const d of e.filter(u=>u.type===D.ORDINAL)){const u=[...d.values].sort((m,C)=>m-C),g=u[0],v=u[u.length-1];if(l(p.SUPERLATIVE)){for(const m of e)if(m.id!==d.id)for(const C of m.values){const y=(i=a.get(m.id))==null?void 0:i.get(C);if(!y)continue;const A=s.get(y);if(!A)continue;const N=A[d.id];N===g?o.push({type:p.SUPERLATIVE,operator:k.MIN,targetCat:m.id,targetVal:C,ordinalCat:d.id}):o.push({type:p.SUPERLATIVE,operator:k.NOT_MIN,targetCat:m.id,targetVal:C,ordinalCat:d.id}),N===v?o.push({type:p.SUPERLATIVE,operator:k.MAX,targetCat:m.id,targetVal:C,ordinalCat:d.id}):o.push({type:p.SUPERLATIVE,operator:k.NOT_MAX,targetCat:m.id,targetVal:C,ordinalCat:d.id})}}if(l(p.ORDINAL)){for(const m of e)if(m.id!==d.id){for(const C of e)if(C.id!==d.id)for(const y of m.values)for(const A of C.values){if(m.id===C.id&&y===A)continue;const N=(r=a.get(m.id))==null?void 0:r.get(y),x=(f=a.get(C.id))==null?void 0:f.get(A);if(!N||!x||N===x)continue;const I=s.get(N),T=s.get(x);if(!I||!T)continue;const E=I[d.id],w=T[d.id];E>w?(o.push({type:p.ORDINAL,operator:L.GREATER_THAN,item1Cat:m.id,item1Val:y,item2Cat:C.id,item2Val:A,ordinalCat:d.id}),o.push({type:p.ORDINAL,operator:L.NOT_LESS_THAN,item1Cat:m.id,item1Val:y,item2Cat:C.id,item2Val:A,ordinalCat:d.id})):E<w&&(o.push({type:p.ORDINAL,operator:L.LESS_THAN,item1Cat:m.id,item1Val:y,item2Cat:C.id,item2Val:A,ordinalCat:d.id}),o.push({type:p.ORDINAL,operator:L.NOT_GREATER_THAN,item1Cat:m.id,item1Val:y,item2Cat:C.id,item2Val:A,ordinalCat:d.id}))}}}}if(l(p.UNARY)){for(const d of e)if(d.type===D.ORDINAL&&d.values.every(u=>typeof u=="number")){for(const u of e)if(u.id!==d.id)for(const g of u.values){const v=(h=a.get(u.id))==null?void 0:h.get(g);if(!v)continue;const m=s.get(v);if(!m)continue;m[d.id]%2===0?o.push({type:p.UNARY,filter:F.IS_EVEN,targetCat:u.id,targetVal:g,ordinalCat:d.id}):o.push({type:p.UNARY,filter:F.IS_ODD,targetCat:u.id,targetVal:g,ordinalCat:d.id})}}}return o}publicCalculateScore(e,t,a,s,o,l,n){var P;const i=s.type,r=(P=n.get(t.category1Id))==null?void 0:P.get(t.value1);let f;r!==void 0&&(f=l[t.category2Id][r]);const h=f!==void 0&&e.isPossible(t.category1Id,t.value1,t.category2Id,f)&&e.getPossibilitiesCount(t.category1Id,t.value1,t.category2Id)===1,d=this.isPuzzleSolved(e,l,n);if(s.type===p.BINARY&&s.operator===O.IS){const b=s;if(b.cat1===t.category1Id&&b.val1===t.value1&&b.cat2===t.category2Id&&b.val2===f||b.cat1===t.category2Id&&b.val1===f&&b.cat2===t.category1Id&&b.val2===t.value1)return-1/0}if(h&&d)return 1e6;if(h&&!d)return-1e6;const u=a,{totalPossible:g,currentPossible:v,solutionPossible:m}=e.getGridStats(),C=g-m,y=g-v,A=C>0?y/C:0;let N=0;switch(i){case p.ORDINAL:N=1.5,s.operator>=2&&(N=5);break;case p.SUPERLATIVE:N=1.2,s.operator>=2&&(N=5);break;case p.UNARY:N=1.2;break;case p.BINARY:N=1,s.operator===O.IS_NOT&&(N=5);break}let x=0;const I=b=>{const S=(V,z)=>{var G;return(G=this.reverseSolution.get(V))==null?void 0:G.get(z)};let M=[],_=[];switch(b.type){case p.BINARY:const V=b;M.push(S(V.cat1,V.val1)),V.operator===O.IS_NOT&&_.push(S(V.cat2,V.val2));break;case p.SUPERLATIVE:const z=b;M.push(S(z.targetCat,z.targetVal));break;case p.ORDINAL:const G=b;M.push(S(G.item1Cat,G.item1Val)),_.push(S(G.item2Cat,G.item2Val));break;case p.UNARY:const q=b;M.push(S(q.targetCat,q.targetVal));break}return{primary:M.filter(V=>!!V),secondary:_.filter(V=>!!V)}},T=new Set;for(const b of o){const{primary:S,secondary:M}=I(b);S.forEach(_=>T.add(_)),M.forEach(_=>T.add(_))}const{primary:E,secondary:w}=I(s);E.forEach(b=>{T.has(b)&&(x+=1)}),w.forEach(b=>{T.has(b)&&(x+=.5)});const B=s.ordinalCat;if(B)for(const b of o){const S=b.ordinalCat;B===S&&(x+=.5)}if(o.length>0){const b=o[o.length-1];if(s.type===b.type&&(x+=2,s.type===p.BINARY&&s.operator===O.IS&&b.operator===O.IS&&(x+=2)),o.length>1){const V=o[o.length-2];s.type===b.type&&s.type===V.type&&(x+=5)}const S=V=>{switch(V.type){case p.SUPERLATIVE:return 1;case p.BINARY:return V.operator===O.IS?1:3;case p.ORDINAL:return 3;case p.UNARY:return 3;case p.CROSS_ORDINAL:return 4;default:return 2}},M=S(s),_=S(b);M===_&&(x+=1.5)}const $=Math.pow(.4,x);return(u*N+A*5)*$}isPuzzleSolved(e,t,a){var o;const s=e.categories;s[0];for(const l of s)for(const n of l.values)for(const i of s){if(l.id>=i.id)continue;const r=(o=a.get(l.id))==null?void 0:o.get(n);if(!r)return!1;const f=t[i.id][r];if(e.getPossibilitiesCount(l.id,n,i.id)>1||!e.isPossible(l.id,n,i.id,f))return!1}return!0}}const H=self;H.onmessage=c=>{const{type:e}=c.data;if(e==="start"){const{categories:t,targetFact:a,options:s}=c.data;try{const o=new X(s==null?void 0:s.seed),l={...s,onTrace:i=>{H.postMessage({type:"trace",message:i})}};let n;try{n=o.generatePuzzle(t,a,l)}catch(i){if(s.targetClueCount&&i.message&&i.message.includes("Could not generate puzzle")){H.postMessage({type:"trace",message:`⚠️ Strict generation failed (${i.message}). Falling back to best-effort generation...`});const r={...l,targetClueCount:void 0};n=o.generatePuzzle(t,a,r)}else throw i}H.postMessage({type:"done",puzzle:n})}catch(o){console.error("Worker Generation Error:",o),H.postMessage({type:"error",message:o.message||"Unknown worker error"})}}}})();
