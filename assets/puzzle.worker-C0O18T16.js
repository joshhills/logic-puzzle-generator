(function(){"use strict";var B=(d=>(d[d.NOMINAL=0]="NOMINAL",d[d.ORDINAL=1]="ORDINAL",d))(B||{}),C=(d=>(d[d.BINARY=0]="BINARY",d[d.ORDINAL=1]="ORDINAL",d[d.SUPERLATIVE=2]="SUPERLATIVE",d[d.UNARY=3]="UNARY",d[d.CROSS_ORDINAL=4]="CROSS_ORDINAL",d))(C||{}),ee=(d=>(d[d.MATCH=0]="MATCH",d[d.NOT_MATCH=1]="NOT_MATCH",d))(ee||{}),k=(d=>(d[d.IS=0]="IS",d[d.IS_NOT=1]="IS_NOT",d))(k||{}),D=(d=>(d[d.GREATER_THAN=0]="GREATER_THAN",d[d.LESS_THAN=1]="LESS_THAN",d[d.NOT_GREATER_THAN=2]="NOT_GREATER_THAN",d[d.NOT_LESS_THAN=3]="NOT_LESS_THAN",d))(D||{}),G=(d=>(d[d.MIN=0]="MIN",d[d.MAX=1]="MAX",d[d.NOT_MIN=2]="NOT_MIN",d[d.NOT_MAX=3]="NOT_MAX",d))(G||{}),W=(d=>(d[d.IS_ODD=0]="IS_ODD",d[d.IS_EVEN=1]="IS_EVEN",d))(W||{});class ie extends Error{constructor(t){super(t),this.name="LogicPuzzleError"}}class _ extends ie{constructor(t){super(t),this.name="ConfigurationError"}}class H{constructor(t){this.validateConfig(t),this.categories=t,this.valueMap=new Map(t.map(e=>[e.id,new Map(e.values.map((i,s)=>[i,s]))])),this.grid=new Map;for(const e of t){const i=new Map;for(const s of e.values){const o=new Map;for(const n of t)e.id!==n.id&&o.set(n.id,Array(n.values.length).fill(!0));i.set(s,o)}this.grid.set(e.id,i)}}validateConfig(t){const e=new Set;let i=-1;for(const s of t){if(e.has(s.id))throw new _(`Duplicate category ID found: ${s.id}`);if(e.add(s.id),new Set(s.values).size!==s.values.length)throw new _(`Category '${s.id}' has duplicate values.`);if(i===-1)i=s.values.length;else if(s.values.length!==i)throw new _(`Category '${s.id}' has ${s.values.length} values, expected ${i}. All categories must be the same size.`)}}setPossibility(t,e,i,s,o){var a,r;const n=(a=this.valueMap.get(i))==null?void 0:a.get(s);if(n!==void 0){const c=this.grid.get(t);if(c){const m=c.get(e);if(m){const f=m.get(i);f&&(f[n]=o)}}}const l=(r=this.valueMap.get(t))==null?void 0:r.get(e);if(l!==void 0){const c=this.grid.get(i);if(c){const m=c.get(s);if(m){const f=m.get(t);f&&(f[l]=o)}}}}isPossible(t,e,i,s){var r;if(t===i)return e===s;const o=(r=this.valueMap.get(i))==null?void 0:r.get(s);if(o===void 0)return!1;const n=this.grid.get(t);if(!n)return!1;const l=n.get(e);if(!l)return!1;const a=l.get(i);return a?a[o]:!1}getPossibilitiesCount(t,e,i){var o,n;const s=(n=(o=this.grid.get(t))==null?void 0:o.get(e))==null?void 0:n.get(i);return s?s.filter(l=>l).length:0}getGridStats(){var l,a,r;let t=0;const e=this.categories.length,i=((l=this.categories[0])==null?void 0:l.values.length)||0;if(i===0||e<2)return{totalPossible:0,currentPossible:0,solutionPossible:0};const s=e*(e-1)/2,o=s*i*i,n=s*i;for(const c of this.categories)for(const m of c.values)for(const f of this.categories){if(c.id>=f.id)continue;const u=(r=(a=this.grid.get(c.id))==null?void 0:a.get(m))==null?void 0:r.get(f.id);u&&(t+=u.filter(p=>p).length)}return{totalPossible:o,currentPossible:t,solutionPossible:n}}clone(){const t=new H(this.categories);return t.grid=new Map([...this.grid.entries()].map(([e,i])=>[e,new Map([...i.entries()].map(([s,o])=>[s,new Map([...o.entries()].map(([n,l])=>[n,[...l]]))]))])),t}}class te{applyClue(t,e){let i=0;switch(e.type){case C.BINARY:i+=this.applyBinaryClue(t,e);break;case C.SUPERLATIVE:i+=this.applySuperlativeClue(t,e);break;case C.ORDINAL:i+=this.applyOrdinalClue(t,e);break;case C.UNARY:i+=this.applyUnaryClue(t,e);break;case C.CROSS_ORDINAL:i+=this.applyCrossOrdinalClue(t,e);break}let s;do s=this.runDeductionLoop(t),i+=s;while(s>0);return{grid:t,deductions:i}}applyCrossOrdinalClue(t,e){let i=0;const s=t.categories,o=s.find(m=>m.id===e.ordinal1),n=s.find(m=>m.id===e.ordinal2);if(!o||!n)return 0;const l=e.operator===ee.NOT_MATCH,a=(m,f,u,p)=>p.values.map((v,h)=>({val:v,idx:h})).filter(v=>t.isPossible(m,f,u,v.val)),r=a(e.item1Cat,e.item1Val,e.ordinal1,o),c=a(e.item2Cat,e.item2Val,e.ordinal2,n);if(l){if(r.length===1&&c.length===1){const m=r[0].idx+e.offset1,f=c[0].idx+e.offset2,u=o.values[m],p=n.values[f];u!==void 0&&p!==void 0&&t.isPossible(e.ordinal1,u,e.ordinal2,p)&&(t.setPossibility(e.ordinal1,u,e.ordinal2,p,!1),i++)}for(const m of r){const f=m.idx+e.offset1;if(o.values[f]!==void 0)for(const p of c){const v=p.idx+e.offset2;n.values[v]}}if(r.length===1){const m=r[0].idx+e.offset1,f=o.values[m];if(f!==void 0)for(const u of c){const p=u.idx+e.offset2,v=n.values[p];v!==void 0&&t.isPossible(e.ordinal1,f,e.ordinal2,v)&&(t.setPossibility(e.item2Cat,e.item2Val,e.ordinal2,u.val,!1),i++)}}if(c.length===1){const m=c[0].idx+e.offset2,f=n.values[m];if(f!==void 0)for(const u of r){const p=u.idx+e.offset1,v=o.values[p];v!==void 0&&t.isPossible(e.ordinal1,v,e.ordinal2,f)&&(t.setPossibility(e.item1Cat,e.item1Val,e.ordinal1,u.val,!1),i++)}}}else{for(const u of r){const p=u.idx+e.offset1,v=o.values[p];if(v===void 0){t.setPossibility(e.item1Cat,e.item1Val,e.ordinal1,u.val,!1),i++;continue}let h=!1;for(const y of c){const b=y.idx+e.offset2,R=n.values[b];if(R!==void 0&&t.isPossible(e.ordinal1,v,e.ordinal2,R)){h=!0;break}}h||(t.setPossibility(e.item1Cat,e.item1Val,e.ordinal1,u.val,!1),i++)}for(const u of c){const p=u.idx+e.offset2,v=n.values[p];if(v===void 0){t.setPossibility(e.item2Cat,e.item2Val,e.ordinal2,u.val,!1),i++;continue}let h=!1;for(const y of r){const b=y.idx+e.offset1,R=o.values[b];if(R!==void 0&&t.isPossible(e.ordinal1,R,e.ordinal2,v)){h=!0;break}}h||(t.setPossibility(e.item2Cat,e.item2Val,e.ordinal2,u.val,!1),i++)}const m=a(e.item1Cat,e.item1Val,e.ordinal1,o),f=a(e.item2Cat,e.item2Val,e.ordinal2,n);if(m.length===1&&f.length===1){const u=m[0].idx+e.offset1,p=f[0].idx+e.offset2,v=o.values[u],h=n.values[p];v!==void 0&&h!==void 0&&t.getPossibilitiesCount(e.ordinal1,v,e.ordinal2)>1&&(t.setPossibility(e.ordinal1,v,e.ordinal2,h,!0),i++)}}return i}applyUnaryClue(t,e){let i=0;const o=t.categories.find(l=>l.id===e.ordinalCat);if(!o||o.type!==B.ORDINAL||!o.values.every(l=>typeof l=="number"))return 0;const n=e.filter===W.IS_EVEN;for(const l of o.values){const a=l;(n?a%2!==0:a%2===0)&&t.isPossible(e.targetCat,e.targetVal,e.ordinalCat,l)&&(t.setPossibility(e.targetCat,e.targetVal,e.ordinalCat,l,!1),i++)}return i}applyBinaryClue(t,e){let i=0;const s=t.categories,o=s.find(l=>l.id===e.cat1),n=s.find(l=>l.id===e.cat2);if(!o||!n)return 0;if(e.operator===k.IS){t.isPossible(e.cat1,e.val1,e.cat2,e.val2),t.setPossibility(e.cat1,e.val1,e.cat2,e.val2,!0);for(const l of n.values)l!==e.val2&&t.isPossible(e.cat1,e.val1,e.cat2,l)&&(t.setPossibility(e.cat1,e.val1,e.cat2,l,!1),i++);for(const l of o.values)l!==e.val1&&t.isPossible(e.cat1,l,e.cat2,e.val2)&&(t.setPossibility(e.cat1,l,e.cat2,e.val2,!1),i++)}else t.isPossible(e.cat1,e.val1,e.cat2,e.val2)&&(t.setPossibility(e.cat1,e.val1,e.cat2,e.val2,!1),i++);return i}runDeductionLoop(t){let e=0;const i=t.categories;for(const s of i)for(const o of s.values)for(const n of i){if(s.id===n.id)continue;const l=n.values.filter(a=>t.isPossible(s.id,o,n.id,a));if(l.length===1){const a=l[0];for(const r of s.values)r!==o&&t.isPossible(s.id,r,n.id,a)&&(t.setPossibility(s.id,r,n.id,a,!1),e++)}for(const a of i){if(s.id===a.id||n.id===a.id)continue;const r=l.length===1?l[0]:null;if(r){const c=a.values.filter(m=>t.isPossible(n.id,r,a.id,m));if(c.length===1){const m=c[0];t.isPossible(s.id,o,a.id,m)===!1||t.getPossibilitiesCount(s.id,o,a.id)>1&&(t.setPossibility(s.id,o,a.id,m,!0),e++)}}for(const c of a.values)t.isPossible(s.id,o,a.id,c)&&(n.values.some(f=>t.isPossible(s.id,o,n.id,f)&&t.isPossible(n.id,f,a.id,c))||(t.setPossibility(s.id,o,a.id,c,!1),e++))}}return e}applyOrdinalClue(t,e){let i=0;const o=t.categories.find(a=>a.id===e.ordinalCat);if(!o||o.type!==B.ORDINAL)return 0;const n=o.values.map((a,r)=>({val:a,idx:r})).filter(a=>t.isPossible(e.item1Cat,e.item1Val,e.ordinalCat,a.val)),l=o.values.map((a,r)=>({val:a,idx:r})).filter(a=>t.isPossible(e.item2Cat,e.item2Val,e.ordinalCat,a.val));if(n.length===0||l.length===0)return 0;if(e.operator===D.GREATER_THAN)for(const a of n)l.some(c=>a.idx>c.idx)||t.isPossible(e.item1Cat,e.item1Val,e.ordinalCat,a.val)&&(t.setPossibility(e.item1Cat,e.item1Val,e.ordinalCat,a.val,!1),i++);else if(e.operator===D.LESS_THAN)for(const a of n)l.some(c=>a.idx<c.idx)||t.isPossible(e.item1Cat,e.item1Val,e.ordinalCat,a.val)&&(t.setPossibility(e.item1Cat,e.item1Val,e.ordinalCat,a.val,!1),i++);else if(e.operator===D.NOT_GREATER_THAN)for(const a of n)l.some(c=>a.idx<=c.idx)||t.isPossible(e.item1Cat,e.item1Val,e.ordinalCat,a.val)&&(t.setPossibility(e.item1Cat,e.item1Val,e.ordinalCat,a.val,!1),i++);else if(e.operator===D.NOT_LESS_THAN)for(const a of n)l.some(c=>a.idx>=c.idx)||t.isPossible(e.item1Cat,e.item1Val,e.ordinalCat,a.val)&&(t.setPossibility(e.item1Cat,e.item1Val,e.ordinalCat,a.val,!1),i++);if(e.operator===D.GREATER_THAN)for(const a of l)n.some(c=>a.idx<c.idx)||t.isPossible(e.item2Cat,e.item2Val,e.ordinalCat,a.val)&&(t.setPossibility(e.item2Cat,e.item2Val,e.ordinalCat,a.val,!1),i++);else if(e.operator===D.LESS_THAN)for(const a of l)n.some(c=>a.idx>c.idx)||t.isPossible(e.item2Cat,e.item2Val,e.ordinalCat,a.val)&&(t.setPossibility(e.item2Cat,e.item2Val,e.ordinalCat,a.val,!1),i++);else if(e.operator===D.NOT_GREATER_THAN)for(const a of l)n.some(c=>a.idx>=c.idx)||t.isPossible(e.item2Cat,e.item2Val,e.ordinalCat,a.val)&&(t.setPossibility(e.item2Cat,e.item2Val,e.ordinalCat,a.val,!1),i++);else if(e.operator===D.NOT_LESS_THAN)for(const a of l)n.some(c=>a.idx<=c.idx)||t.isPossible(e.item2Cat,e.item2Val,e.ordinalCat,a.val)&&(t.setPossibility(e.item2Cat,e.item2Val,e.ordinalCat,a.val,!1),i++);return i}applySuperlativeClue(t,e){const s=t.categories.find(a=>a.id===e.ordinalCat);if(!s||s.type!==B.ORDINAL)return 0;let o,n=!1;switch(e.operator){case G.MAX:o=s.values[s.values.length-1];break;case G.MIN:o=s.values[0];break;case G.NOT_MAX:o=s.values[s.values.length-1],n=!0;break;case G.NOT_MIN:o=s.values[0],n=!0;break;default:return 0}const l={type:C.BINARY,cat1:e.targetCat,val1:e.targetVal,cat2:e.ordinalCat,val2:o,operator:n?k.IS_NOT:k.IS};return this.applyBinaryClue(t,l)}}class ae{constructor(t,e,i,s,o,n){this.generator=t,this.categories=e,this.solution=i,this.reverseSolution=s,this.valueMap=o,this.targetFact=n,this.availableClues=[],this.proofChain=[],this.historyStack=[],this.grid=new H(e),this.solver=new te,this.availableClues=this.generator.generateAllPossibleClues(e,void 0,s,o)}getNextClue(t){const e=this.availableClues.filter(a=>!(t!=null&&t.allowedClueTypes&&!t.allowedClueTypes.includes(a.type)));let i=null,s=-1/0;const o=[...e].sort(()=>Math.random()-.5),n=50;let l=0;for(const a of o){if(l++,l>n&&i)break;this.generator.calculateClueScore(this.grid,this.targetFact,0,a,this.proofChain,this.solution,this.reverseSolution);const r=this.grid.clone(),{deductions:c}=this.solver.applyClue(r,a);if(c===0&&!this.isUseful(r))continue;const m=this.generator.calculateClueScore(this.grid,this.targetFact,c,a,this.proofChain,this.solution,this.reverseSolution);m>s&&(s=m,i=a)}if(i){this.historyStack.push(this.grid.clone()),this.solver.applyClue(this.grid,i),this.proofChain.push(i);const a=this.availableClues.indexOf(i);return a>-1&&this.availableClues.splice(a,1),{clue:i,remaining:this.availableClues.length,solved:this.generator.isPuzzleSolved(this.grid,this.solution,this.reverseSolution)}}return{clue:null,remaining:e.length,solved:this.generator.isPuzzleSolved(this.grid,this.solution,this.reverseSolution)}}async getNextClueAsync(t){return new Promise((e,i)=>{setTimeout(()=>{try{const s=this.getNextClue(t);e(s)}catch(s){i(s)}},0)})}rollbackLastClue(){if(this.historyStack.length===0)return{success:!1,clue:null};const t=this.historyStack.pop();t&&(this.grid=t);const e=this.proofChain.pop();return e?(this.availableClues.push(e),{success:!0,clue:e}):{success:!1,clue:null}}isUseful(t){return!0}getGrid(){return this.grid}getProofChain(){return this.proofChain}getSolution(){return this.solution}getValueMap(){return this.valueMap}}const se={"2x3":{min:2,max:2},"2x4":{min:3,max:10},"2x5":{min:4,max:17},"2x6":{min:5,max:26},"2x7":{min:6,max:37},"2x8":{min:7,max:50},"2x9":{min:8,max:65},"2x10":{min:9,max:82},"3x3":{min:3,max:9},"3x4":{min:5,max:26},"3x5":{min:7,max:47},"3x6":{min:9,max:72},"3x7":{min:11,max:100},"3x8":{min:13,max:130},"3x9":{min:15,max:160},"3x10":{min:17,max:200},"4x3":{min:5,max:16},"4x4":{min:8,max:44},"4x5":{min:11,max:87},"4x6":{min:14,max:140},"4x7":{min:17,max:200},"4x8":{min:20,max:260},"4x9":{min:23,max:330},"4x10":{min:26,max:400},"5x3":{min:7,max:25},"5x4":{min:11,max:70},"5x5":{min:15,max:130},"5x6":{min:19,max:200},"5x7":{min:23,max:280},"5x8":{min:27,max:370},"5x9":{min:31,max:470},"5x10":{min:35,max:580}},oe=(d,t)=>{const e=`${d}x${t}`;if(se[e])return se[e];const i=(d-1)*t,s=Math.max(5,Math.floor(i*.7)),o=Math.floor(i*5);return{min:s,max:o}};function ne(d){return function(){d|=0,d=d+1831565813|0;var t=Math.imul(d^d>>>15,1|d);return t=t+Math.imul(t^t>>>7,61|t)^t,((t^t>>>14)>>>0)/4294967296}}class j{constructor(t){this.solution={},this.valueMap=new Map,this.reverseSolution=new Map,this.seed=t,this.random=ne(t),this.solver=new te}getClueCountBounds(t,e,i=10){let s=1/0,o=0;for(let n=0;n<i;n++){const l=this.seed+n+1,a=new j(l);try{const r=a.internalGenerate(t,e,"min");r&&(s=Math.min(s,r.clues.length))}catch{}try{const c=new j(l).internalGenerate(t,e,"max");c&&(o=Math.max(o,c.clues.length))}catch{}}return s===1/0&&(s=0),{min:s,max:o}}generatePuzzle(t,e,i={}){if(t.length<2)throw new _("Puzzle must have at least 2 categories.");const{targetClueCount:s,maxCandidates:o=50,timeoutMs:n=1e4}=i,l=e||this.generateRandomTarget(t);this.validateTarget(t,l);const a=i.constraints;if(a!=null&&a.allowedClueTypes){const r=a.allowedClueTypes,c=t.some(u=>u.type===B.ORDINAL),m=r.includes(C.ORDINAL),f=r.includes(C.CROSS_ORDINAL);if(m&&!c&&!r.includes(C.BINARY))throw new _("Invalid Constraints: Ordinal-based clue types were requested, but no Ordinal categories exist. Please add an ordinal category or allow Binary clues.");if(f&&t.filter(p=>p.type===B.ORDINAL).length<2)throw new _("Invalid Constraints: Cross-Ordinal clues require at least 2 Ordinal Categories.")}return this.internalGenerate(t,l,"standard",{maxCandidates:o,targetClueCount:s,timeoutMs:n,constraints:i.constraints,onTrace:i.onTrace})}validateTarget(t,e){const i=new Set(t.map(s=>s.id));if(!i.has(e.category1Id)||!i.has(e.category2Id))throw new _("Target fact refers to non-existent categories.");if(e.category1Id===e.category2Id)throw new _("Target fact must refer to two different categories.")}generateRandomTarget(t){const e=Math.floor(this.random()*t.length);let i=Math.floor(this.random()*t.length);for(;i===e;)i=Math.floor(this.random()*t.length);const s=t[e],o=t[i],n=Math.floor(this.random()*s.values.length);return{category1Id:s.id,value1:s.values[n],category2Id:o.id}}async generatePuzzleAsync(t,e,i={}){return new Promise((s,o)=>{setTimeout(()=>{try{const n=this.generatePuzzle(t,e,i);s(n)}catch(n){o(n)}},0)})}async getClueCountBoundsAsync(t,e,i=10){return new Promise((s,o)=>{setTimeout(()=>{try{const n=this.getClueCountBounds(t,e,i);s(n)}catch(n){o(n)}},0)})}startSession(t,e){if(t.length<2)throw new _("Must have at least 2 categories.");let i=e;if(!i){const l=Math.floor(this.random()*t.length);let a=Math.floor(this.random()*t.length);for(;a===l;)a=Math.floor(this.random()*t.length);const r=t[l],c=t[a],m=Math.floor(this.random()*r.values.length);i={category1Id:r.id,value1:r.values[m],category2Id:c.id}}const s=new Map,o={},n=new Map;return this.createSolution(t,s,o,n),new ae(this,t,o,n,s,i)}internalGenerate(t,e,i,s){if(!t||t.length<2)throw new _("At least 2 categories are required to generate a puzzle.");const o=(s==null?void 0:s.maxCandidates)??1/0,n=s==null?void 0:s.targetClueCount,l=s==null?void 0:s.constraints;s!=null&&s.onTrace&&s.onTrace("Generator: internalGenerate started.");const a=t.find(u=>u.id===e.category1Id);if(a&&!a.values.includes(e.value1))throw new _(`Target value '${e.value1}' does not exist in category '${e.category1Id}'.`);if(l!=null&&l.allowedClueTypes){const u=[C.BINARY,C.ORDINAL,C.CROSS_ORDINAL],p=l.allowedClueTypes.some(S=>u.includes(S));if(l.allowedClueTypes.length>0&&!p)throw new _("Invalid Constraints: The selected clue types are ambiguous on their own. Please allow at least one identity-resolving type (Binary, Ordinal, or Cross-Ordinal).");const v=t.filter(S=>S.type===B.ORDINAL),h=v.length,y=h>0,b=[C.ORDINAL,C.SUPERLATIVE,C.UNARY,C.CROSS_ORDINAL];if(l.allowedClueTypes.some(S=>b.includes(S))&&!y&&!l.allowedClueTypes.includes(C.BINARY))throw new _("Invalid Constraints: Ordinal-based clue types were requested, but no Ordinal categories exist. Please add an ordinal category or allow Binary clues.");if(l.allowedClueTypes.includes(C.CROSS_ORDINAL)&&h<2)throw new _("Invalid Constraints: Cross-Ordinal clues require at least two separate Ordinal categories.");if(l.allowedClueTypes.includes(C.UNARY)&&!v.some(x=>{const w=x.values.map(I=>Number(I)).filter(I=>!isNaN(I)),A=w.some(I=>I%2!==0),V=w.some(I=>I%2===0);return A&&V}))throw new _("Invalid Constraints: Unary clues (Even/Odd) require at least one Ordinal category to contain both odd and even values.")}for(const u of t)if(u.type===B.ORDINAL&&u.values.some(v=>typeof v!="number"&&isNaN(Number(v))))throw new _(`Category '${u.id}' is ORDINAL but contains non-numeric values.`);if(this.valueMap=new Map,this.solution={},this.reverseSolution=new Map,s!=null&&s.onTrace&&s.onTrace("Generator: Creating solution..."),this.createSolution(t,this.valueMap,this.solution,this.reverseSolution),s!=null&&s.onTrace&&s.onTrace("Generator: Solution created."),n!==void 0){const u=t.length,p=t[0].values.length,v=oe(u,p);s!=null&&s.onTrace&&s.onTrace(`Generator: Feasibility check complete. Recommended bounds: ${v.min}-${v.max}`);const h=0;let y=n;v.min>0&&n<v.min-h&&(console.warn(`Target clue count ${n} is too low (Estimated min: ${v.min}). Auto-adjusting to ${v.min}.`),y=v.min);try{return this.generateWithBacktracking(t,e,y,o,i,(s==null?void 0:s.timeoutMs)??1e4,s==null?void 0:s.constraints,s==null?void 0:s.onTrace)}catch(b){throw b}}s!=null&&s.onTrace&&s.onTrace("Generator: Generating all possible clues...");let r=this.generateAllPossibleClues(t,s==null?void 0:s.constraints,this.reverseSolution,this.valueMap);s!=null&&s.onTrace&&s.onTrace(`Generator: Generated ${r.length} candidate clues.`);const c=new H(t),m=[],f=100;for(;m.length<f;){if(s!=null&&s.onTrace){const x=m.length,w=c.getGridStats(),A=Math.max(1,w.totalPossible-w.solutionPossible),V=Math.max(0,w.currentPossible-w.solutionPossible),I=Math.min(100,Math.round((A-V)/A*100));if(s.onTrace(`Depth ${x}: ${I}% Solved. Candidates: ${r.length}`),I>=100&&this.isPuzzleSolved(c,this.solution,this.reverseSolution)){s.onTrace("Generator: Puzzle Solved (100%).");break}}let u=null,p=null;if(o<r.length)for(let x=r.length-1;x>0;x--){const w=Math.floor(this.random()*(x+1));[r[x],r[w]]=[r[w],r[x]]}const v=Math.min(r.length,o);let h=0;for(let x=r.length-1;x>=0&&!(h>=v);x--){const w=r[x],A=c.clone(),{deductions:V}=this.solver.applyClue(A,w);if(V===0){r.splice(x,1);continue}h++;let I=0;i==="min"?I=V*1e3:i==="max"?I=100/V:I=this.calculateClueScore(A,e,V,w,m.map(U=>U.clue),this.solution,this.reverseSolution),w.type;const z=this.solution[e.category2Id][e.value1],K=A.isPossible(e.category1Id,e.value1,e.category2Id,z)&&A.getPossibilitiesCount(e.category1Id,e.value1,e.category2Id)===1,J=this.isPuzzleSolved(A,this.solution,this.reverseSolution);K&&(J?p={clue:w,score:I+1e6}:I=-1e6),I>-999999&&(!u||I>u.score)&&(u={clue:w,score:I})}const y=p||u;if(!y)break;const b=y.clue,{deductions:R}=this.solver.applyClue(c,b);m.push({clue:b,deductions:R});const S=r.findIndex(x=>JSON.stringify(x)===JSON.stringify(b));if(S>-1&&r.splice(S,1),this.isPuzzleSolved(c,this.solution,this.reverseSolution))break}return{solution:this.solution,clues:m.map(u=>u.clue),proofChain:m,categories:t,targetFact:e}}generateWithBacktracking(t,e,i,s,o,n=1e4,l,a){const r=this.generateAllPossibleClues(t,l,this.reverseSolution,this.valueMap),c=new H(t);let m=0;const f=Date.now(),u=(v,h,y,b)=>{const x=1+(Date.now()-f)/n*3;if(a&&h.length%1===0){const g=h.length+1,T=v.getGridStats(),N=Math.round((T.totalPossible-T.currentPossible)/(T.totalPossible-T.solutionPossible)*100);Math.random()<.05&&a(`Depth ${g}/${i}: ${N}% Solved. Bias: ${x.toFixed(2)} (Backtracks: ${m})`)}if(this.isPuzzleSolved(v,this.solution,this.reverseSolution))return h.length===i?(a&&a(`SOLVED! Exact match at ${i} clues.`),h):null;if(h.length>=i)return null;const A=v.getGridStats(),V=(A.totalPossible-A.currentPossible)/(A.totalPossible-A.solutionPossible),I=h.length+1;let z=[];if(s<y.length)for(let g=y.length-1;g>0;g--){const T=Math.floor(this.random()*(g+1));[y[g],y[T]]=[y[T],y[g]]}const J=Math.max(1,Math.floor((b?3:s===1/0?50:s)/Math.pow(x,2))),U=Math.min(y.length,J);a&&Math.random()<.001&&a(`Pruning: Limit reduced to ${U} (Bias ${x.toFixed(1)})`);let P=0;for(let g=0;g<y.length&&!(P>=U);g++){const T=y[g],N=v.clone(),{deductions:E}=this.solver.applyClue(N,T);if(E===0||(P++,this.isPuzzleSolved(N,this.solution,this.reverseSolution)&&I<i))continue;let X=this.calculateClueScore(N,e,E,T,h.map(Y=>Y.clue),this.solution,this.reverseSolution);if(i){const Y=I/i,Q=(A.totalPossible-N.getGridStats().currentPossible)/(A.totalPossible-A.solutionPossible),$=Math.pow(Y,1.8),Z=Q-$;X-=Z*E*50}z.push({clue:T,deductions:E,score:X,grid:N,index:g})}let M=[],L,O;if(b){const g=b==="STALL";M=z.sort((T,N)=>{const E=T.deductions-N.deductions;return g?E:-E})}else z.sort((g,T)=>T.score-g.score),L=z[0];if(!b){if(O=z[0],i){const g=Math.pow(I/i,1.8);V>g?O=[...z].sort((N,E)=>N.deductions!==E.deductions?N.deductions-E.deductions:E.score-N.score)[0]:O=[...z].sort((N,E)=>N.deductions!==E.deductions?E.deductions-N.deductions:E.score-N.score)[0]}L&&M.push(L),O&&O!==L&&M.push(O);for(const g of z)g!==L&&g!==O&&M.push(g)}for(const g of M){const T=1+(Date.now()-f)/n*4;if(i&&h.length>4&&T>1.1&&!(!!b||g===L||g===O))break;const N=[...y];N.splice(g.index,1);const E=g===L,F=g===O&&g!==L;let X=b,Y="";if(!b&&F&&i){const $=V>I/i,Z=`(Prog ${V.toFixed(2)} vs Exp ${(I/i).toFixed(2)})`;X=$?"STALL":"SPEED",Y=$?`(Stalling - Weakest) ${Z}`:`(Speeding - Strongest) ${Z}`}else b&&(Y=`(Continued ${b})`);if(a&&(F||b||Math.random()<.05)){const $=b?`STICKY ${b}`:E?"Primary":F?"CORRECTION":"Rest";F?a(`[BACKTRACK] Depth ${h.length}: Primary Strategy Failed. Switching to ${Y}. Ded: ${g.deductions}`):b?Math.random()<.1&&a(`Depth ${h.length}: ${Math.round(V*100)}% Solved. Strategy: ${$}. Ded: ${g.deductions}`):a(`Depth ${h.length}: ${Math.round(V*100)}% Solved. Trying ${$} Cand. Ded: ${g.deductions}`)}const Q=u(g.grid,[...h,{clue:g.clue,deductions:g.deductions}],N,X);if(Q)return Q}return m++,null},p=u(c,[],[...r]);if(p)return{solution:this.solution,clues:p.map(h=>h.clue),proofChain:p,categories:t,targetFact:e};throw new _(`Could not generate puzzle with exactly ${i} clues within timeout.`)}createSolution(t,e,i,s){var n;const o=t[0];o.values.forEach(l=>{e.set(l,{[o.id]:l})});for(let l=1;l<t.length;l++){const a=t[l],r=[...a.values].sort(()=>this.random()-.5);let c=0;for(const m of o.values){const f=e.get(m);f&&(f[a.id]=r[c++])}}for(const l of t)i[l.id]={},s.set(l.id,new Map);for(const l of o.values){const a=e.get(l);if(a)for(const r in a)i[r][l]=a[r],(n=s.get(r))==null||n.set(a[r],l)}}generateAllPossibleClues(t,e,i,s){var l,a,r,c,m;const o=[];t[0];const n=f=>!(e!=null&&e.allowedClueTypes)||e.allowedClueTypes.includes(f);if(n(C.BINARY))for(const f of t)for(const u of f.values)for(const p of t){if(f.id>=p.id)continue;const v=(l=i.get(f.id))==null?void 0:l.get(u);if(!v)continue;const h=s.get(v);if(h)for(const y of p.values){const b=h[p.id];y===b?o.push({type:C.BINARY,operator:k.IS,cat1:f.id,val1:u,cat2:p.id,val2:y}):o.push({type:C.BINARY,operator:k.IS_NOT,cat1:f.id,val1:u,cat2:p.id,val2:y})}}for(const f of t.filter(u=>u.type===B.ORDINAL)){const u=[...f.values].sort((h,y)=>h-y),p=u[0],v=u[u.length-1];if(n(C.SUPERLATIVE)){for(const h of t)if(h.id!==f.id)for(const y of h.values){const b=(a=i.get(h.id))==null?void 0:a.get(y);if(!b)continue;const R=s.get(b);if(!R)continue;const S=R[f.id];S===p?o.push({type:C.SUPERLATIVE,operator:G.MIN,targetCat:h.id,targetVal:y,ordinalCat:f.id}):o.push({type:C.SUPERLATIVE,operator:G.NOT_MIN,targetCat:h.id,targetVal:y,ordinalCat:f.id}),S===v?o.push({type:C.SUPERLATIVE,operator:G.MAX,targetCat:h.id,targetVal:y,ordinalCat:f.id}):o.push({type:C.SUPERLATIVE,operator:G.NOT_MAX,targetCat:h.id,targetVal:y,ordinalCat:f.id})}}if(n(C.ORDINAL)){for(const h of t)if(h.id!==f.id){for(const y of t)if(y.id!==f.id)for(const b of h.values)for(const R of y.values){if(h.id===y.id&&b===R)continue;const S=(r=i.get(h.id))==null?void 0:r.get(b),x=(c=i.get(y.id))==null?void 0:c.get(R);if(!S||!x||S===x)continue;const w=s.get(S),A=s.get(x);if(!w||!A)continue;const V=w[f.id],I=A[f.id];V>I?(o.push({type:C.ORDINAL,operator:D.GREATER_THAN,item1Cat:h.id,item1Val:b,item2Cat:y.id,item2Val:R,ordinalCat:f.id}),o.push({type:C.ORDINAL,operator:D.NOT_LESS_THAN,item1Cat:h.id,item1Val:b,item2Cat:y.id,item2Val:R,ordinalCat:f.id})):V<I&&(o.push({type:C.ORDINAL,operator:D.LESS_THAN,item1Cat:h.id,item1Val:b,item2Cat:y.id,item2Val:R,ordinalCat:f.id}),o.push({type:C.ORDINAL,operator:D.NOT_GREATER_THAN,item1Cat:h.id,item1Val:b,item2Cat:y.id,item2Val:R,ordinalCat:f.id}))}}}}if(n(C.UNARY)){for(const f of t)if(f.type===B.ORDINAL&&f.values.every(u=>typeof u=="number")){for(const u of t)if(u.id!==f.id)for(const p of u.values){const v=(m=i.get(u.id))==null?void 0:m.get(p);if(!v)continue;const h=s.get(v);if(!h)continue;h[f.id]%2===0?o.push({type:C.UNARY,filter:W.IS_EVEN,targetCat:u.id,targetVal:p,ordinalCat:f.id}):o.push({type:C.UNARY,filter:W.IS_ODD,targetCat:u.id,targetVal:p,ordinalCat:f.id})}}}return o}calculateClueScore(t,e,i,s,o,n,l){var U;const a=s.type,r=(U=l.get(e.category1Id))==null?void 0:U.get(e.value1);let c;r!==void 0&&(c=n[e.category2Id][r]);const m=c!==void 0&&t.isPossible(e.category1Id,e.value1,e.category2Id,c)&&t.getPossibilitiesCount(e.category1Id,e.value1,e.category2Id)===1,f=this.isPuzzleSolved(t,n,l);if(s.type===C.BINARY&&s.operator===k.IS){const P=s;if(P.cat1===e.category1Id&&P.val1===e.value1&&P.cat2===e.category2Id&&P.val2===c||P.cat1===e.category2Id&&P.val1===c&&P.cat2===e.category1Id&&P.val2===e.value1)return-1/0}if(m&&f)return 1e6;if(m&&!f)return-1e6;const u=i,{totalPossible:p,currentPossible:v,solutionPossible:h}=t.getGridStats(),y=p-h,b=p-v,R=y>0?b/y:0;let S=0;switch(a){case C.ORDINAL:S=1.5,s.operator>=2&&(S=5);break;case C.SUPERLATIVE:S=1.2,s.operator>=2&&(S=5);break;case C.UNARY:S=1.2;break;case C.BINARY:S=1,s.operator===k.IS_NOT&&(S=5);break}let x=0;const w=P=>{const M=(g,T)=>{var N;return(N=this.reverseSolution.get(g))==null?void 0:N.get(T)};let L=[],O=[];switch(P.type){case C.BINARY:const g=P;L.push(M(g.cat1,g.val1)),g.operator===k.IS_NOT&&O.push(M(g.cat2,g.val2));break;case C.SUPERLATIVE:const T=P;L.push(M(T.targetCat,T.targetVal));break;case C.ORDINAL:const N=P;L.push(M(N.item1Cat,N.item1Val)),O.push(M(N.item2Cat,N.item2Val));break;case C.UNARY:const E=P;L.push(M(E.targetCat,E.targetVal));break}return{primary:L.filter(g=>!!g),secondary:O.filter(g=>!!g)}},A=new Set;for(const P of o){const{primary:M,secondary:L}=w(P);M.forEach(O=>A.add(O)),L.forEach(O=>A.add(O))}const{primary:V,secondary:I}=w(s);V.forEach(P=>{A.has(P)&&(x+=1)}),I.forEach(P=>{A.has(P)&&(x+=.5)});const z=s.ordinalCat;if(z)for(const P of o){const M=P.ordinalCat;z===M&&(x+=.5)}if(o.length>0){const P=o[o.length-1];if(s.type===P.type&&(x+=2,s.type===C.BINARY&&s.operator===k.IS&&P.operator===k.IS&&(x+=2)),o.length>1){const g=o[o.length-2];s.type===P.type&&s.type===g.type&&(x+=5)}const M=g=>{switch(g.type){case C.SUPERLATIVE:return 1;case C.BINARY:return g.operator===k.IS?1:3;case C.ORDINAL:return 3;case C.UNARY:return 3;case C.CROSS_ORDINAL:return 4;default:return 2}},L=M(s),O=M(P);L===O&&(x+=1.5)}const K=Math.pow(.4,x);return(u*S+R*5)*K}isPuzzleSolved(t,e,i){var o;const s=t.categories;s[0];for(const n of s)for(const l of n.values)for(const a of s){if(n.id>=a.id)continue;const r=(o=i.get(n.id))==null?void 0:o.get(l);if(!r)return!1;const c=e[a.id][r];if(t.getPossibilitiesCount(n.id,l,a.id)>1||!t.isPossible(n.id,l,a.id,c))return!1}return!0}}const q=self;q.onmessage=d=>{const{type:t}=d.data;if(t==="start"){const{categories:e,targetFact:i,options:s}=d.data;s&&s.targetClueCount&&(s.targetClueCount=parseInt(String(s.targetClueCount),10));try{const o=new j(s==null?void 0:s.seed),n={...s,onTrace:a=>{q.postMessage({type:"trace",message:a})}};let l;try{l=o.generatePuzzle(e,i,n)}catch(a){if(s.targetClueCount&&a.message&&a.message.includes("Could not generate puzzle")){q.postMessage({type:"trace",message:`⚠️ Strict generation failed (${a.message}). Falling back to best-effort generation...`});const r={...n,targetClueCount:void 0};l=o.generatePuzzle(e,i,r)}else throw a}q.postMessage({type:"done",puzzle:l})}catch(o){console.error("Worker Generation Error:",o),q.postMessage({type:"error",message:o.message||"Unknown worker error"})}}}})();
